{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>This is just a placeholder file for the webpage re-direct. All the content for this section is actually in the <code>introduction.md</code> file.</p>"},{"location":"example-I2C/","title":"I<sup>2</sup>C","text":""},{"location":"example-I2C/#device-scan","title":"Device Scan","text":"<p>This sketch allows users to scan for devices connected to the primary I<sup>2</sup>C bus of the RAM5 Thing Plus. The example code can be found in the GitHub repository. However, users can also simply click on the button (below), to download the code; or expand the box (below), to copy the code.</p> <code>i2c_scanner.ino</code> <pre><code>// --------------------------------------\n// i2c_scanner\n//\n// Modified from https://playground.arduino.cc/Main/I2cScanner/\n// --------------------------------------\n\n#include &lt;Wire.h&gt;\n\n// Set I2C bus to use: Wire, Wire1, etc.\n#define WIRE Wire\n\nint toggle = 0;\n\nvoid setup() {\n  WIRE.begin();\n\n  pinMode(8, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial)\n    delay(10);\n  Serial.println(\"\\nI2C Scanner\");\n}\n\n\nvoid loop() {\n  if (toggle == 0) {\n    digitalWrite(8, HIGH);\n    toggle = 1;\n  } else {\n    digitalWrite(8, LOW);\n    toggle = 0;\n  }\n\n\n  byte error, address;\n  int nDevices;\n\n  Serial.println(\"Scanning...\");\n\n  nDevices = 0;\n  for (address = 1; address &lt; 127; address++) {\n    // The i2c_scanner uses the return value of\n    // the Write.endTransmisstion to see if\n    // a device did acknowledge to the address.\n    WIRE.beginTransmission(address);\n    error = WIRE.endTransmission();\n\n    if (error == 0) {\n      Serial.print(\"I2C device found at address 0x\");\n      if (address &lt; 16)\n        Serial.print(\"0\");\n      Serial.print(address, HEX);\n      Serial.println(\"  !\");\n\n      nDevices++;\n    } else if (error == 4) {\n      Serial.print(\"Unknown error at address 0x\");\n      if (address &lt; 16)\n        Serial.print(\"0\");\n      Serial.println(address, HEX);\n    }\n  }\n  if (nDevices == 0)\n    Serial.println(\"No I2C devices found\\n\");\n  else\n    Serial.println(\"done\\n\");\n\n  delay(700);  // wait 5 seconds for next scan\n}\n</code></pre> <p>  Download the Example Sketch </p>"},{"location":"example-I2C/#peripheral-devices","title":"Peripheral Devices","text":"<p>The RA6M5 Thing Plus features a Qwiic connector to seamlessly integrate with devices from SparkFun's Qwiic Ecosystem. While users are free to utilize any I<sup>2</sup>C device, we recommend the Qwiic devices from our catalog.</p> Optional Hardware <ul> <li> <p> <p>SparkFun Qwiic Cable Kit KIT-15081</p> <li> <p> <p>Qwiic Cable - Grove Adapter (100mm) PRT-15109</p> <li> <p> <p>SparkFun Qwiic OLED - (1.3in., 128x64) LCD-23453</p> <li> <p> <p>SparkFun GPS Breakout - XA1110 (Qwiic) GPS-14414</p> <li> <p> <p>SparkFun Qwiic Joystick COM-15168</p> <li> <p> <p>SparkFun Qwiic Mux Breakout - 8 Channel (TCA9548A) BOB-16784</p> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>SparkFun Qwiic Mini ToF Imager - VL53L5CX SEN-19013</p>"},{"location":"example-I2C/#max17048-fuel-gauge","title":"MAX17048 Fuel Gauge","text":"<p>The MAX17048 fuel gauge measures the approximate charge/discharge rate, state of charge, and voltage of a connected LiPo battery. We recommend the SparkFun MAX1704x Arduino library be utilized in the Arduino IDE, to connect to the MAX17048 on the RA6M5 Thing Plus. Once the library is installed in the Arduino IDE, users will find several example sketches listed in the File &gt; Examples &gt; SparkFun MAX1704x Fuel Gauge Arduino Library &gt; drop-down menu. We recommend the following examples for users:</p> <ul> <li><code>Example1_Simple.ino</code></li> <li><code>Example4_MAX17048_KitchenSink.ino</code></li> </ul> Optional Hardware <ul> <li> <p> <p>Lithium Ion Battery - 2Ah PRT-13855</p> <li> <p> <p>Lithium Ion Battery - 400mAh PRT-13851</p> <li> <p> <p>Lithium Ion Battery - 1Ah PRT-13813</p> <li> <p> <p>Lithium Ion Battery - 110mAh PRT-13853</p> <code>Example1_Simple.ino</code><code>Example4_MAX17048_KitchenSink.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; SparkFun MAX1704x Fuel Gauge Arduino Library &gt; Example1_Simple drop-down menu.</p> <code>Example1_Simple.ino</code> <pre><code>/******************************************************************************\nExample1_Simple\nBy: Paul Clark\nDate: October 23rd 2020\n\nBased extensively on:\nMAX17043_Simple_Serial.cpp\nSparkFun MAX17043 Example Code\nJim Lindblom @ SparkFun Electronics\nOriginal Creation Date: June 22, 2015\n\nThis file demonstrates the simple API of the SparkFun MAX17043 Arduino library.\n\nThis example will print the gauge's voltage and state-of-charge (SOC) readings\nto Serial (115200 baud)\n\nThis code is released under the MIT license.\n\nDistributed as-is; no warranty is given.\n******************************************************************************/\n\n#include &lt;Wire.h&gt; // Needed for I2C\n\n#include &lt;SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h&gt; // Click here to get the library: http://librarymanager/All#SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library\n\nSFE_MAX1704X lipo; // Defaults to the MAX17043\n\n//SFE_MAX1704X lipo(MAX1704X_MAX17043); // Create a MAX17043\n//SFE_MAX1704X lipo(MAX1704X_MAX17044); // Create a MAX17044\n//SFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n//SFE_MAX1704X lipo(MAX1704X_MAX17049); // Create a MAX17049\n\ndouble voltage = 0; // Variable to keep track of LiPo voltage\ndouble soc = 0; // Variable to keep track of LiPo state-of-charge (SOC)\nbool alert; // Variable to keep track of whether alert has been triggered\n\nvoid setup()\n{\n    Serial.begin(115200); // Start serial, to output debug data\n  while (!Serial)\n    ; //Wait for user to open terminal\n  Serial.println(F(\"MAX17043 Example\"));\n\n  Wire.begin();\n\n  lipo.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial\n\n  // Set up the MAX17043 LiPo fuel gauge:\n  if (lipo.begin() == false) // Connect to the MAX17043 using the default wire port\n  {\n    Serial.println(F(\"MAX17043 not detected. Please check wiring. Freezing.\"));\n    while (1)\n      ;\n  }\n\n    // Quick start restarts the MAX17043 in hopes of getting a more accurate\n    // guess for the SOC.\n    lipo.quickStart();\n\n    // We can set an interrupt to alert when the battery SoC gets too low.\n    // We can alert at anywhere between 1% - 32%:\n    lipo.setThreshold(20); // Set alert threshold to 20%.\n}\n\nvoid loop()\n{\n  // lipo.getVoltage() returns a voltage value (e.g. 3.93)\n  voltage = lipo.getVoltage();\n  // lipo.getSOC() returns the estimated state of charge (e.g. 79%)\n  soc = lipo.getSOC();\n  // lipo.getAlert() returns a 0 or 1 (0=alert not triggered)\n  alert = lipo.getAlert();\n\n  // Print the variables:\n  Serial.print(\"Voltage: \");\n  Serial.print(voltage);  // Print the battery voltage\n  Serial.println(\" V\");\n\n  Serial.print(\"Percentage: \");\n  Serial.print(soc); // Print the battery state of charge\n  Serial.println(\" %\");\n\n  Serial.print(\"Alert: \");\n  Serial.println(alert);\n  Serial.println();\n\n  delay(500);\n}\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; SparkFun MAX1704x Fuel Gauge Arduino Library &gt; Example4_MAX17048_KitchenSink drop-down menu.</p> <code>Example4_MAX17048_KitchenSink.ino</code> <pre><code>/******************************************************************************\nExample4: test all the things on the MAX17048\nBy: Paul Clark, SparkFun Electronics\nDate: October 23rd 2020\n\nThis example is an everything-but-the-kitchen-sink test of the MAX17048.\n\nThis code is released under the MIT license.\n\nDistributed as-is; no warranty is given.\n******************************************************************************/\n\n#include &lt;Wire.h&gt; // Needed for I2C\n\n#include &lt;SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h&gt; // Click here to get the library: http://librarymanager/All#SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library\n\nSFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n\nvoid setup()\n{\n    Serial.begin(115200); // Start serial, to output debug data\n  while (!Serial)\n    ; //Wait for user to open terminal\n  Serial.println(F(\"MAX17048 Example\"));\n\n  Wire.begin();\n\n  lipo.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial\n\n  // Set up the MAX17048 LiPo fuel gauge:\n  if (lipo.begin() == false) // Connect to the MAX17048 using the default wire port\n  {\n    Serial.println(F(\"MAX17048 not detected. Please check wiring. Freezing.\"));\n    while (1)\n      ;\n  }\n\n  // Just because we can, let's reset the MAX17048\n  Serial.println(F(\"Resetting the MAX17048...\"));\n  delay(1000); // Give it time to get its act back together\n\n  // Read and print the reset indicator\n  Serial.print(F(\"Reset Indicator was: \"));\n  bool RI = lipo.isReset(true); // Read the RI flag and clear it automatically if it is set\n  Serial.println(RI); // Print the RI\n  // If RI was set, check it is now clear\n  if (RI)\n  {\n    Serial.print(F(\"Reset Indicator is now: \"));\n    RI = lipo.isReset(); // Read the RI flag\n    Serial.println(RI); // Print the RI    \n  }\n\n  // To quick-start or not to quick-start? That is the question!\n  // Read the following and then decide if you do want to quick-start the fuel gauge.\n  // \"Most systems should not use quick-start because the ICs handle most startup problems transparently,\n  //  such as intermittent battery-terminal connection during insertion. If battery voltage stabilizes\n  //  faster than 17ms then do not use quick-start. The quick-start command restarts fuel-gauge calculations\n  //  in the same manner as initial power-up of the IC. If the system power-up sequence is so noisy that the\n  //  initial estimate of SOC has unacceptable error, the system microcontroller might be able to reduce the\n  //  error by using quick-start.\"\n  // If you still want to try a quick-start then uncomment the next line:\n    //lipo.quickStart();\n\n  // Read and print the device ID\n  Serial.print(F(\"Device ID: 0x\"));\n  uint8_t id = lipo.getID(); // Read the device ID\n  if (id &lt; 0x10) Serial.print(F(\"0\")); // Print the leading zero if required\n  Serial.println(id, HEX); // Print the ID as hexadecimal\n\n  // Read and print the device version\n  Serial.print(F(\"Device version: 0x\"));\n  uint8_t ver = lipo.getVersion(); // Read the device version\n  if (ver &lt; 0x10) Serial.print(F(\"0\")); // Print the leading zero if required\n  Serial.println(ver, HEX); // Print the version as hexadecimal\n\n  // Read and print the battery threshold\n  Serial.print(F(\"Battery empty threshold is currently: \"));\n  Serial.print(lipo.getThreshold());\n  Serial.println(F(\"%\"));\n\n    // We can set an interrupt to alert when the battery SoC gets too low.\n    // We can alert at anywhere between 1% and 32%:\n    lipo.setThreshold(20); // Set alert threshold to 20%.\n\n  // Read and print the battery empty threshold\n  Serial.print(F(\"Battery empty threshold is now: \"));\n  Serial.print(lipo.getThreshold());\n  Serial.println(F(\"%\"));\n\n  // Read and print the high voltage threshold\n  Serial.print(F(\"High voltage threshold is currently: \"));\n  float highVoltage = ((float)lipo.getVALRTMax()) * 0.02; // 1 LSb is 20mV. Convert to Volts.\n  Serial.print(highVoltage, 2);\n  Serial.println(F(\"V\"));\n\n  // Set the high voltage threshold\n  lipo.setVALRTMax((float)4.1); // Set high voltage threshold (Volts)\n\n  // Read and print the high voltage threshold\n  Serial.print(F(\"High voltage threshold is now: \"));\n  highVoltage = ((float)lipo.getVALRTMax()) * 0.02; // 1 LSb is 20mV. Convert to Volts.\n  Serial.print(highVoltage, 2);\n  Serial.println(F(\"V\"));\n\n  // Read and print the low voltage threshold\n  Serial.print(F(\"Low voltage threshold is currently: \"));\n  float lowVoltage = ((float)lipo.getVALRTMin()) * 0.02; // 1 LSb is 20mV. Convert to Volts.\n  Serial.print(lowVoltage, 2);\n  Serial.println(F(\"V\"));\n\n  // Set the low voltage threshold\n  lipo.setVALRTMin((float)3.9); // Set low voltage threshold (Volts)\n\n  // Read and print the low voltage threshold\n  Serial.print(F(\"Low voltage threshold is now: \"));\n  lowVoltage = ((float)lipo.getVALRTMin()) * 0.02; // 1 LSb is 20mV. Convert to Volts.\n  Serial.print(lowVoltage, 2);\n  Serial.println(F(\"V\"));\n\n  // Enable the State Of Change alert\n  Serial.print(F(\"Enabling the 1% State Of Change alert: \"));\n  if (lipo.enableSOCAlert())\n  {\n    Serial.println(F(\"success.\"));\n  }\n  else\n  {\n    Serial.println(F(\"FAILED!\"));\n  }\n\n  // Read and print the HIBRT Active Threshold\n  Serial.print(F(\"Hibernate active threshold is: \"));\n  float actThr = ((float)lipo.getHIBRTActThr()) * 0.00125; // 1 LSb is 1.25mV. Convert to Volts.\n  Serial.print(actThr, 5);\n  Serial.println(F(\"V\"));\n\n  // Read and print the HIBRT Hibernate Threshold\n  Serial.print(F(\"Hibernate hibernate threshold is: \"));\n  float hibThr = ((float)lipo.getHIBRTHibThr()) * 0.208; // 1 LSb is 0.208%/hr. Convert to %/hr.\n  Serial.print(hibThr, 3);\n  Serial.println(F(\"%/h\"));\n}\n\nvoid loop()\n{\n  // Print the variables:\n  Serial.print(\"Voltage: \");\n  Serial.print(lipo.getVoltage());  // Print the battery voltage\n  Serial.print(\"V\");\n\n  Serial.print(\" Percentage: \");\n  Serial.print(lipo.getSOC(), 2); // Print the battery state of charge with 2 decimal places\n  Serial.print(\"%\");\n\n  Serial.print(\" Change Rate: \");\n  Serial.print(lipo.getChangeRate(), 2); // Print the battery change rate with 2 decimal places\n  Serial.print(\"%/hr\");\n\n  Serial.print(\" Alert: \");\n  Serial.print(lipo.getAlert()); // Print the generic alert flag\n\n  Serial.print(\" Voltage High Alert: \");\n  Serial.print(lipo.isVoltageHigh()); // Print the alert flag\n\n  Serial.print(\" Voltage Low Alert: \");\n  Serial.print(lipo.isVoltageLow()); // Print the alert flag\n\n  Serial.print(\" Empty Alert: \");\n  Serial.print(lipo.isLow()); // Print the alert flag\n\n  Serial.print(\" SOC 1% Change Alert: \");\n  Serial.print(lipo.isChange()); // Print the alert flag\n\n  Serial.print(\" Hibernating: \");\n  Serial.print(lipo.isHibernating()); // Print the alert flag\n\n  Serial.println();\n\n  delay(500);\n}\n</code></pre>"},{"location":"example-I2C/#bme688-environmental-sensor","title":"BME688 Environmental Sensor","text":"<p>Users are free to utilize any hardware they already have; however, we recommend the BME688 environmental sensor. The board includes a Qwiic connector on the edge of the board and can be easily attached to the RA6M5 Thing Plus with a Qwiic cable. In addition, a hookup guide and Arduino library for the sensor are available.</p> Optional Hardware <ul> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>Flexible Qwiic Cable - 50mm PRT-17260</p> Install Arduino Library <p>Users will need to install the Bosch BME68x Arduino library for the sensor. In the Arduino IDE, users can install it by searching for <code>BME68x Sensor Library</code>, in the Library Manager:</p> <pre><code>BME68x Sensor Library\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; BME68x Sensor library &gt; forced_mode drop-down menu. For more details on utilizing the BME68x breakout board, please refer to our hookup guide for the sensor.</p> <code>forced_mode.ino</code> <p>I<sup>2</sup>C Modifications</p> <p>By default, this example utilizes the SPI bus; therefore, some modifications must be made:</p> <ul> <li> <p>The chip select pin no longer needs to be defined:</p> <pre><code>#ifndef PIN_CS\n#define PIN_CS SS\n#endif\n</code></pre> </li> <li> <p>The I<sup>2</sup>C bus must be initialized, instead of the SPI bus:</p> <pre><code>SPI.begin();\nWire.begin();\n</code></pre> </li> <li> <p>The sensor must be initialized with the Wire class, instead of the SPI class:</p> <pre><code>/* initializes the sensor based on SPIWire library */\nbme.begin(PIN_CS, SPI);\nbme.begin(BME68X_I2C_ADDR_LOW, Wire)\n</code></pre> </li> </ul> <pre><code>/**\n * Copyright (C) 2021 Bosch Sensortec GmbH\n *\n * SPDX-License-Identifier: BSD-3-Clause\n * \n */\n\n#include \"Arduino.h\"\n#include \"bme68xLibrary.h\"\n\n#ifndef PIN_CS\n#define PIN_CS SS\n#endif\n\nBme68x bme;\n\n/**\n * @brief Initializes the sensor and hardware settings\n */\nvoid setup(void)\n{\n    SPI.begin();\n    Serial.begin(115200);\n\n    while (!Serial)\n        delay(10);\n\n    /* initializes the sensor based on SPI library */\n    bme.begin(PIN_CS, SPI);\n\n    if(bme.checkStatus())\n    {\n        if (bme.checkStatus() == BME68X_ERROR)\n        {\n            Serial.println(\"Sensor error:\" + bme.statusString());\n            return;\n        }\n        else if (bme.checkStatus() == BME68X_WARNING)\n        {\n            Serial.println(\"Sensor Warning:\" + bme.statusString());\n        }\n    }\n\n    /* Set the default configuration for temperature, pressure and humidity */\n    bme.setTPH();\n\n    /* Set the heater configuration to 300 deg C for 100ms for Forced mode */\n    bme.setHeaterProf(300, 100);\n\n    Serial.println(\"TimeStamp(ms), Temperature(deg C), Pressure(Pa), Humidity(%), Gas resistance(ohm), Status\");\n}\n\nvoid loop(void)\n{\n    bme68xData data;\n\n    bme.setOpMode(BME68X_FORCED_MODE);\n    delayMicroseconds(bme.getMeasDur());\n\n    if (bme.fetchData())\n    {\n        bme.getData(data);\n        Serial.print(String(millis()) + \", \");\n        Serial.print(String(data.temperature) + \", \");\n        Serial.print(String(data.pressure) + \", \");\n        Serial.print(String(data.humidity) + \", \");\n        Serial.print(String(data.gas_resistance) + \", \");\n        Serial.println(data.status, HEX);\n    }\n}\n</code></pre>"},{"location":"example-QSPI/","title":"Flash Memory","text":""},{"location":"example-QSPI/#mx25l12833f","title":"MX25L12833F","text":"<p>The Renesas-Arduino core includes a built-in FATFileSystem library to control the QSPI flash memory. This example code demonstrates how to initialize the flash memory, a file is written, and data is read from the file. Users can also find other example sketches in the File &gt; Examples &gt; Storage drop-down menu.</p> <code>QSPI_Flash_FileSystem_Test.ino</code> <p>// Always close the file after writing to save changes</p> <pre><code>??? code\n    ```cpp\n      Name: QSPI_Flash_FileSystem_Test.ino\n      Purpose: This sketch test the onboard QSPI Flash memory\n      file system by writing and reading a file.\n\n      @author Arduino Team\n      @version 1.0 20/06/23\n    */\n\n    // Include necessary libraries and drivers\n    #include \"QSPIFlashBlockDevice.h\"\n    #include \"FATFileSystem.h\"\n\n    ```\n</code></pre> <p>fclose(fp);</p> <pre><code>??? code\n    ```cpp\n    #define QSPI_FS_NAME \"qspi\"\n    #define TEST_FILE \"test.txt\"\n\n    // Instantiate flash block device and file system\n    QSPIFlashBlockDevice block_device(PIN_QSPI_CLK, PIN_QSPI_SS, PIN_QSPI_D0, PIN_QSPI_D1, PIN_QSPI_D2, PIN_QSPI_D3); \n    FATFileSystem fs(QSPI_FS_NAME);\n\n    // Define full path to the test file\n    std::string file_test_name = std::string(\"/\") + std::string(QSPI_FS_NAME) + std::string(\"/\") + std::string(TEST_FILE); \n\n    void setup() {\n      // Initialize serial communication and wait a connection\n      Serial.begin(9600);\n      while(!Serial);\n\n    ```\n</code></pre> <p>}</p> <pre><code>??? code\n    ```cpp\n    Serial.println();\n    Serial.println(\"- SIMPLE QSPI FLASH TEST\");\n    Serial.println();\n\n    // Try to mount the QSPI Flash file system\n    // If mounting fails, try to format the file system\n    int err =  fs.mount(&amp;block_device);\n    if (err) {\n      Serial.println(\"- No filesystem found, formatting... \");\n      err = fs.reformat(&amp;block_device);\n    }\n    if (err) {\n      // If formatting fails, print error and halt\n      Serial.println(\"- Error formatting QSPI Flash \");\n      while(1);\n    }\n\n    ```\n</code></pre>"},{"location":"example-QSPI/#eslov-connector","title":"ESLOV Connector","text":"<p>The Portenta C33 board features an onboard ESLOV connector to extend the I2C communication bus. This connector simplifies connecting various sensors, actuators, and other modules to the Portenta C33 without soldering or wiring; Nicla family boards can also be connected to the Portenta C33 through this connector. </p> <p></p> <p>The ESLOV connector is a small 5-pin connector with a 1.00 mm pitch. The mechanical details of the connector can be found in the connector's datasheet.</p> <p>The pin layout of the ESLOV connector is the following:</p> <ol> <li>VCC</li> <li>INT</li> <li>SCL</li> <li>SDA</li> <li>GND</li> </ol> <p><code>VCC</code> pin works as a 5 V output if the board is connected to a USB-C\u00ae cable. The manufacturer part number of the ESLOV connector is SM05B-SRSS, and its matching receptacle manufacturer part number is SHR-05V-S-B.</p>"},{"location":"example-QSPI/#external-memory","title":"External Memory","text":"<p>The Portenta C33 board features an onboard 16 MB QSPI Flash memory, the MX25L12833F from Macronix\u00ae. Having an onboard QSPI Flash memory enhances the capabilities of the Portenta C33, enabling you to develop and run more complex and data-intensive applications.</p> <p></p> <p>Some key advantages of having an onboard QSPI Flash memory are the following:</p> <ul> <li>Storage capacity: The MX25L12833F QSPI Flash memory adds significant non-volatile storage to the board.</li> <li>Extended functionality: The additional memory space allows more complex applications to be developed and run on your Portenta C33. This application includes data logging, image processing, audio processing, and executing complex algorithms.</li> <li>Firmware updates: The MX25L12833F QSPI Flash memory can also store firmware or software updates for your Arduino board. This means you can update the firmware without requiring a complete reprogramming of the board.</li> </ul> <p>The Arduino Renesas Core has built-in libraries and drivers that immediately let you use the onboard QSPI Flash memory. Let's walk through an example code demonstrating some of the onboard Flash memory capabilities; the main tasks performed in the sketch are initializing the Flash memory, writing to a file, and reading from a file.</p> <p>```arduino /**   QSPI Flash File System test   Name: QSPI_Flash_FileSystem_Test.ino   Purpose: This sketch test the onboard QSPI Flash memory   file system by writing and reading a file.</p> <p>@author Arduino Team   @version 1.0 20/06/23 */</p> <p>// Include necessary libraries and drivers</p>"},{"location":"example-QSPI/#include-qspiflashblockdeviceh","title":"include \"QSPIFlashBlockDevice.h\"","text":""},{"location":"example-QSPI/#include-fatfilesystemh","title":"include \"FATFileSystem.h\"","text":"<p>// Define constants for file system and test file name</p>"},{"location":"example-QSPI/#define-qspi_fs_name-qspi","title":"define QSPI_FS_NAME \"qspi\"","text":""},{"location":"example-QSPI/#define-test_file-testtxt","title":"define TEST_FILE \"test.txt\"","text":"<p>// Instantiate flash block device and file system QSPIFlashBlockDevice block_device(PIN_QSPI_CLK, PIN_QSPI_SS, PIN_QSPI_D0, PIN_QSPI_D1, PIN_QSPI_D2, PIN_QSPI_D3);  FATFileSystem fs(QSPI_FS_NAME);</p> <p>// Define full path to the test file std::string file_test_name = std::string(\"/\") + std::string(QSPI_FS_NAME) + std::string(\"/\") + std::string(TEST_FILE); </p> <p>void setup() {   // Initialize serial communication and wait a connection   Serial.begin(9600);   while(!Serial);</p> <p>// Print test start message   Serial.println();   Serial.println(\"- SIMPLE QSPI FLASH TEST\");   Serial.println();</p> <p>// Try to mount the QSPI Flash file system   // If mounting fails, try to format the file system   int err =  fs.mount(&amp;block_device);   if (err) {     Serial.println(\"- No filesystem found, formatting... \");     err = fs.reformat(&amp;block_device);   }   if (err) {     // If formatting fails, print error and halt     Serial.println(\"- Error formatting QSPI Flash \");     while(1);   }</p> <p>// Try to open a test file for writing   // If file opened successfully, write some text to the file   FILE* fp = fopen(file_test_name.c_str(), \"w\");   if(fp != NULL) {</p>"},{"location":"example-SD_card/","title":"\u00b5SD Card","text":"<p>Data Corruption</p> <p>To avoid any data loss or corrupting the SD card, users should disable all activity with the SD card before removing it from the RA6M5 Thing Plus.</p> <p>The FATFileSystem library built into the Renesas-Arduino core, supports \u00b5SD cards with a FAT32 file system (i.e. SD cards up to 32GB in size).</p> <ul> <li>While users may be able to use cards with a higher storage capacity, we highly advise against it. As users may experience data loss due to a corrupt file system (i.e. SD cards with a storage capacity greater than 32GB are not meant to be formatted with a FAT32 file system).</li> </ul>"},{"location":"example-SD_card/#sd-card-test","title":"SD Card - Test","text":"<p>The Renesas-Arduino core includes a built-in FATFileSystem library that controls the SD host interface. The library that supports SD cards with a FAT32 file system (i.e. SD cards up to 32GB in size). Users can find an example sketch in the File &gt; Examples &gt; Storage &gt; TestSDCARD drop-down menu.</p> Optional Hardware <ul> <li> <p> <p>microSD Card - 1GB (Class 4) COM-15107</p> <li> <p> <p>microSD Card - 32GB (Class 10) COM-19041</p> <li> <p> <p>microSD USB Reader COM-13004</p> <code>TestSDCARD.ino</code> <pre><code>/*\n  Portenta H33 - TestSDCARD with Fat FS\n\n  The sketch shows how to mount an SDCARD and list its content.\n\n  The circuit:\n   - Portenta H33 + Portenta Breakout \n\n  created January 31th, 2023\n  by Daniele Aimo\n\n  This example code is in the public domain.\n*/\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include \"SDCardBlockDevice.h\"\n#include \"FATFileSystem.h\"\n\n#define TEST_FS_NAME \"fs\"\n#define TEST_FOLDER_NAME \"TEST_FOLDER\"\n#define TEST_FILE \"test.txt\"\n#define DELETE_FILE_DIMENSION 150\n\n\nSDCardBlockDevice block_device(PIN_SDHI_CLK, PIN_SDHI_CMD, PIN_SDHI_D0, PIN_SDHI_D1, PIN_SDHI_D2, PIN_SDHI_D3, PIN_SDHI_CD, PIN_SDHI_WP);\nFATFileSystem fs(TEST_FS_NAME);\n\nstd::string root_folder       = std::string(\"/\") + std::string(TEST_FS_NAME);\nstd::string folder_test_name  = root_folder + std::string(\"/\") + std::string(TEST_FOLDER_NAME);\nstd::string file_test_name    = folder_test_name + std::string(\"/\") + std::string(TEST_FILE); \n\nvoid setup() {\n  /*\n   *  SERIAL INITIALIZATION\n   */\n  Serial.begin(9600);\n  while(!Serial) {\n\n  }\n\n  /* list to store all directory in the root */\n  std::vector&lt;std::string&gt; dir_list;\n\n  Serial.println();\n  Serial.println(\"##### TEST SD CARD with FAT FS\");\n  Serial.println();\n\n  /* \n   *  MOUNTING SDCARD AS FATFS filesystem\n   */\n  Serial.println(\"Mounting SDCARD...\");\n  int err =  fs.mount(&amp;block_device);\n  if (err) {\n    // Reformat if we can't mount the filesystem\n    // this should only happen on the first boot\n    Serial.println(\"No filesystem found, formatting... \");\n    err = fs.reformat(&amp;block_device);\n  }\n  if (err) {\n     Serial.println(\"Error formatting SDCARD \");\n     while(1);\n  }\n\n  /* \n   *  READING root folder\n   */\n\n  DIR *dir;\n  struct dirent *ent;\n  int dirIndex = 0;\n\n  Serial.println(\"*** List SD CARD content: \");\n  if ((dir = opendir(root_folder.c_str())) != NULL) {\n    while ((ent = readdir (dir)) != NULL) {\n\n      if(ent-&gt;d_type == DT_REG) {\n        Serial.print(\"- [File]: \");\n      }\n\n      else if(ent-&gt;d_type == DT_DIR) {\n        Serial.print(\"- [Fold]: \");\n        dir_list.push_back(ent-&gt;d_name);\n      }\n      Serial.println(ent-&gt;d_name);\n      dirIndex++;\n    }\n    closedir (dir);\n  } \n  else {\n    // Could not open directory\n    Serial.println(\"Error opening SDCARD\\n\");\n    while(1);\n  }\n\n  if(dirIndex == 0) {\n    Serial.println(\"Empty SDCARD\");\n  }\n\n  bool found_test_folder = false;\n\n  /* \n   *  LISTING CONTENT of the first level folders (the one immediately present in root folder)\n   */\n\n  if(dir_list.size()) {\n    Serial.println();\n    Serial.println(\"Listing content of folders in root: \");\n  }\n  for(unsigned int i = 0; i &lt; dir_list.size(); i++) {\n    if(dir_list[i] == TEST_FOLDER_NAME) {\n      found_test_folder = true;\n    }\n    Serial.print(\"- \");\n    Serial.print(dir_list[i].c_str());\n    Serial.println(\":\");\n\n    std::string d = root_folder + std::string(\"/\") + dir_list[i];\n    if ((dir = opendir(d.c_str())) != NULL) {\n      while ((ent = readdir (dir)) != NULL) {\n        if(ent-&gt;d_type == DT_REG) {\n          Serial.print(\"   - [File]: \");\n        }\n        else if(ent-&gt;d_type == DT_DIR) {\n          Serial.print(\"   - [Fold]: \");\n        }\n        Serial.println(ent-&gt;d_name);\n      }\n      closedir (dir);\n    }\n    else {\n      Serial.print(\"ERROR OPENING SUB-FOLDER \");\n      Serial.println(d.c_str());\n    }\n  }\n\n  /* \n   *  CREATING TEST FOLDER (if does not exist already)\n   */\n\n  err = 0;\n  if(!found_test_folder) {\n    Serial.println(\"TEST FOLDER NOT FOUND... creating folder test\"); \n    err = mkdir(folder_test_name.c_str(), S_IRWXU | S_IRWXG | S_IRWXO);\n    if(err != 0) {\n      Serial.print(\"FAILED folder creation with error \");\n      Serial.println(err);\n    }\n  }\n\n  /* \n   *  READING TEST FILE CONTENT\n   */\n\n  if(err == 0) {\n    int file_dimension = 0; \n    FILE* fp = fopen(file_test_name.c_str(), \"r\");\n    if(fp != NULL) {\n      Serial.print(\"Opened file: \");\n      Serial.print(file_test_name.c_str());\n      Serial.println(\" for reading\");\n\n      fseek(fp, 0L, SEEK_END);\n      int numbytes = ftell(fp);\n      fseek(fp, 0L, SEEK_SET);  \n\n      Serial.print(\"Bytes in the file: \");\n      Serial.println(numbytes);\n      file_dimension = numbytes;\n\n      if(numbytes &gt; 0) {\n        Serial.println();\n        Serial.println(\"-------------------- START FILE CONTENT --------------------\");\n      }\n\n      for(int i = 0; i &lt; numbytes; i++) {\n        char ch;\n        fread(&amp;ch, sizeof(char), 1, fp);\n        Serial.print(ch);\n      }\n\n      if(numbytes &gt; 0) {\n        Serial.println(\"--------------------- END FILE CONTENT ---------------------\");\n        Serial.println();\n      }\n      else {\n        Serial.println(\"File is EMPTY!\");\n        Serial.println();\n      }\n\n      fclose(fp);\n    }\n    else {\n      Serial.print(\"FAILED open file \");\n      Serial.println(file_test_name.c_str());\n    }\n\n    /*\n     * DELETE FILE IF THE File dimension is greater than 150 bytes\n     */\n\n    if(file_dimension &gt; DELETE_FILE_DIMENSION) {\n      Serial.println(\"Test file reached the delete dimension... deleting it!\");\n      if(remove(file_test_name.c_str()) == 0) {\n        Serial.println(\"TEST FILE HAS BEEN DELETED!\");\n      }\n    }\n\n    /*\n     * APPENDING SOMETHING TO FILE \n     */\n\n    fp = fopen(file_test_name.c_str(), \"a\");\n    if(fp != NULL) {\n      Serial.print(\"Opened file: \");\n      Serial.print(file_test_name.c_str());\n      Serial.println(\" for writing (append)\");\n      char text[] = \"This line has been appended to file!\\n\";\n      fwrite(text, sizeof(char), strlen(text), fp);\n      fclose(fp); \n    }\n    else {\n      Serial.print(\"FAILED open file for appending \");\n      Serial.println(file_test_name.c_str());\n    }\n\n    /*\n     * READING AGAIN FILE CONTENT\n     */\n\n    fp = fopen(file_test_name.c_str(), \"r\");\n    if(fp != NULL) {\n      Serial.print(\"Opened file: \");\n      Serial.print(file_test_name.c_str());\n      Serial.println(\" for reading\");\n\n      fseek(fp, 0L, SEEK_END);\n      int numbytes = ftell(fp);\n      fseek(fp, 0L, SEEK_SET);  \n\n      Serial.print(\"Bytes in the file: \");\n      Serial.println(numbytes);\n\n      if(numbytes &gt; 0) {\n        Serial.println();\n        Serial.println(\"-------------------- START FILE CONTENT --------------------\");\n      }\n\n      for(int i = 0; i &lt; numbytes; i++) {\n        char ch;\n        fread(&amp;ch, sizeof(char), 1, fp);\n        Serial.print(ch);\n      }\n\n      if(numbytes &gt; 0) {\n        Serial.println(\"--------------------- END FILE CONTENT ---------------------\");\n        Serial.println();\n      }\n      else {\n        Serial.println(\"File is EMPTY!\");\n        Serial.println();\n      }\n\n      fclose(fp);\n\n    }\n    else {\n      Serial.print(\"FAILED open file for appending \");\n      Serial.println(file_test_name.c_str());\n    }\n  }  \n\n}\n\nvoid loop() {\n  // Empty\n}\n</code></pre>"},{"location":"example-SPI/","title":"SPI","text":""},{"location":"example-SPI/#feedback-loop","title":"Feedback Loop","text":"<p>The simplest way to test the SPI interface is with just a jumper (wire) and looping a data transmission from the PICO GPIO pin; back into the POCI GPIO pin. For this example, users are free to utilize any method or hardware they have to connect the PICO and POCI GPIO pins together. However, we recommend some IC hooks for a temporary connection.</p> Optional Hardware <ul> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <li> <p> <p>IC Hook with Pigtail CAB-09741</p> <li> <p> <p>Jumper Wires Premium 6\" Mixed Pack of 100 PRT-09194</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Jumper - 2 Pin PRT-09044</p> <code>SPI_Loopback.ino</code> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;cstdint&gt;\n\nvoid setup()\n{\n    Serial.begin();\n    while(!Serial) {delay(100);};\n\n    Serial.println(\"SPI loopback test.\");\n\n    SPI.begin();\n    SPI.beginTransaction(SPISettings(4000000, MSBFIRST, SPI_MODE1));\n\n    testByteTransfer();\n\n    testWordTransfer();\n\n    testArrayTransfer();\n\n    SPI.endTransaction();\n    SPI.end();\n}\n\nvoid loop()\n{\n\n}\n\nvoid testByteTransfer(void)\n{\n    const uint8_t testByte = 0b10100011;\n\n    Serial.print(\"Sending: 0b\");\n    Serial.println(testByte, BIN);\n\n    uint8_t recvByte = SPI.transfer(testByte);\n\n    Serial.print(\"Received: 0b\");\n    Serial.println(recvByte, BIN);\n\n    if (recvByte == testByte)\n    {\n        Serial.println(\"Byte loopback successful.\");\n    }\n    else\n    {\n        Serial.println(\"Byte loopback unsuccessful. Please check logs.\");\n    }\n}\n\nvoid testWordTransfer(void)\n{\n    const uint8_t testWord = 0b1111000010100101;\n\n    Serial.print(\"Sending: 0b\");\n    Serial.println(testWord, BIN);\n\n    uint8_t recvWord = SPI.transfer(testWord);\n\n    Serial.print(\"Received: 0b\");\n    Serial.println(recvWord, BIN);\n\n    if (recvWord == testWord)\n    {\n        Serial.println(\"Word loopback successful.\");\n    }\n    else\n    {\n        Serial.println(\"Word loopback unsuccessful. Please check logs.\");\n    }\n}\n\nvoid testArrayTransfer(void)\n{\n    const uint8_t numel = 18;\n\n    uint8_t *data = (uint8_t*)malloc(numel);\n\n    uint8_t *data_ptr = data;\n\n    for(uint8_t i = 0; i &lt; numel; ++i)\n    {\n        *data_ptr++ = i;\n    }\n\n    SPI.transfer(data, numel);\n\n    data_ptr = data;\n\n    /* 0 is inital expected results, 255 is when pin is open\n     so initialse result variable to 111 to make it clear the value has changed. */\n    uint8_t result = 111;\n\n    Serial.println();\n    Serial.println(\"Multiple byte transfer test\");\n    Serial.println(\"element value result\");\n\n    for(uint8_t i = 0; i&lt; numel; ++i)\n    {\n        result = *data_ptr++;\n        Serial.print(i);\n        Serial.print(\"\\t\");\n        Serial.print(result);\n        Serial.print(\"\\t\");\n\n        if(result == i)\n        {\n            Serial.println(\"pass\");\n        }\n        else\n        {\n            Serial.println(\"fail\");\n        }\n    }\n}\n</code></pre>"},{"location":"example-SPI/#peripheral-device","title":"Peripheral Device","text":"<p>A more direct method for testing the SPI interface is with an actual SPI device.</p>"},{"location":"example-SPI/#bme688-environmental-sensor","title":"BME688 Environmental Sensor","text":"<p>Users are free to utilize any hardware they already have; however, we recommend the BME688 environmental sensor, below. Its SPI pins are broken out on the edge of the board and can be easily connected to the RA6M5 Thing Plus. In addition, a hookup guide and Arduino library for the sensor are available.</p> Optional Hardware <ul> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <li> <p> <p>Hook-Up Wire - Assortment (Stranded, 22 AWG) PRT-11375</p> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>PINECIL Soldering Iron Kit KIT-24063</p> <li> <p> <p>Hobby Knife TOL-09200</p> Install Arduino Library <p>Users will need to install the Bosch BME68x Arduino library for the sensor. In the Arduino IDE, users can install it by searching for <code>BME68x Sensor Library</code>, in the Library Manager:</p> <pre><code>BME68x Sensor Library\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; BME68x Sensor library &gt; forced_mode drop-down menu. For more details on utilizing the BME68x breakout board, please refer to our hookup guide for the sensor.</p> <code>forced_mode.ino</code> <pre><code>/**\n * Copyright (C) 2021 Bosch Sensortec GmbH\n *\n * SPDX-License-Identifier: BSD-3-Clause\n * \n */\n\n#include \"Arduino.h\"\n#include \"bme68xLibrary.h\"\n\n#ifndef PIN_CS\n#define PIN_CS SS\n#endif\n\nBme68x bme;\n\n/**\n * @brief Initializes the sensor and hardware settings\n */\nvoid setup(void)\n{\n    SPI.begin();\n    Serial.begin(115200);\n\n    while (!Serial)\n        delay(10);\n\n    /* initializes the sensor based on SPI library */\n    bme.begin(PIN_CS, SPI);\n\n    if(bme.checkStatus())\n    {\n        if (bme.checkStatus() == BME68X_ERROR)\n        {\n            Serial.println(\"Sensor error:\" + bme.statusString());\n            return;\n        }\n        else if (bme.checkStatus() == BME68X_WARNING)\n        {\n            Serial.println(\"Sensor Warning:\" + bme.statusString());\n        }\n    }\n\n    /* Set the default configuration for temperature, pressure and humidity */\n    bme.setTPH();\n\n    /* Set the heater configuration to 300 deg C for 100ms for Forced mode */\n    bme.setHeaterProf(300, 100);\n\n    Serial.println(\"TimeStamp(ms), Temperature(deg C), Pressure(Pa), Humidity(%), Gas resistance(ohm), Status\");\n}\n\nvoid loop(void)\n{\n    bme68xData data;\n\n    bme.setOpMode(BME68X_FORCED_MODE);\n    delayMicroseconds(bme.getMeasDur());\n\n    if (bme.fetchData())\n    {\n        bme.getData(data);\n        Serial.print(String(millis()) + \", \");\n        Serial.print(String(data.temperature) + \", \");\n        Serial.print(String(data.pressure) + \", \");\n        Serial.print(String(data.humidity) + \", \");\n        Serial.print(String(data.gas_resistance) + \", \");\n        Serial.println(data.status, HEX);\n    }\n}\n</code></pre>"},{"location":"example-analog/","title":"Analog I/O","text":""},{"location":"example-analog/#analog-input","title":"Analog Input","text":"<p>The RA6M5 Thing Plus includes several breakout pins with access to the 12-bit ADC channels of the RA6M5. These feature is primarily used to record analog data from potentiometers and various sensors. For this example, users are free to utilize any hardware they have to connect the ADC from the <code>A0</code> GPIO pins to an analog signal. We recommend selecting a device with a product manual that provides electrical diagrams and example code; below, are a few examples:</p> Optional Hardware <ul> <li> <p> <p>SparkFun Electret Microphone Breakout BOB-12758</p> <li> <p> <p>Mini Photocell SEN-09088</p> <li> <p> <p>Trimpot 10K Ohm with Knob COM-09806</p> <li> <p> <p>Jumper Wires Premium 6\" Mixed Pack of 100 PRT-09194</p> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <p>Below, are some basic example sketches for capturing analog data from generic devices such as a potentiometer or photocell.</p> <code>AnalogReadSerial.ino</code><code>ReadAnalogVoltage.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; 01.basics &gt; AnalogReadSerial drop-down menu.</p> <code>AnalogReadSerial.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 01.basics &gt; ReadAnalogVoltage drop-down menu.</p> <code>ReadAnalogVoltage.ino</code> <p></p>"},{"location":"example-analog/#analog-output","title":"Analog Output","text":""},{"location":"example-analog/#analogwave-library","title":"AnalogWave Library","text":"<p>To implement the <code>AnalogWave</code> library from the Renesas Arduino core, users will need to link the library at the beginning of their sketch.</p> <pre><code>#include \"analogWave.h\" // Include the library for analog waveform generation\n</code></pre> <p>Once linked, users will need to create an instance of the <code>analogWave</code> class and declare a DAC <code>pin</code> for the output.</p> <pre><code>analogWave wave(pin);   // Create an instance of the analogWave class, using a DAC pin\n</code></pre> <p>Tip</p> <p>In the Renesas-Arduino core, <code>DAC</code> and <code>DAC1</code> are predefined variables for their corresponding GPIO pins on the RA6M5 Thing Plus.</p> <p>Code</p> <pre><code>analogWave waveA0(DAC);    // Create an instance of the analogWave class, using the DAC pin (A0)\nanalogWave waveA1(DAC1);   // Create an instance of the analogWave class, using the DAC1 pin (A1)\n</code></pre> <p>Below, are a few of the key methods available for the <code>analogWave</code> class:</p> Methods in <code>analogWave.h</code> <pre><code>/* begin the output of the waweform the frequency is the one the complete\n   set on sample are output (all samples will be output in 1 period */\nbool begin(float freq_hz);\n/* updated the frequency used */\nbool freq(float freq_hz);\n/* make the current index in the buffer to \"jump\" of the specified quantity */\nvoid offset(uint32_t o);\n/* start the generation of sample */\nvoid start();\n/* stop the genration of sample */\nvoid stop();\n/* every sample is multiplied for this factor must be a value between 0 and 1 */\nvoid amplitude(float amplitude);\n\n\nvoid sine(float freq_hz);\nvoid square(float freq_hz);\nvoid saw(float freq_hz);\n</code></pre> <p>For more information, please refer to the <code>analogWave.cpp</code> file in the <code>AnalogWave</code> library.</p> <p>When generating an output signal from the DAC of the RA6M5 Thing Plus, users will need to define the waveform's type and frequency:</p> <pre><code>int freq = 20;       // waveform frequency in Hz\n</code></pre> <pre><code>wave.sine(freq);      // Generates a sine wave with a 20Hz frequency\n</code></pre>"},{"location":"example-analog/#oscilloscope","title":"Oscilloscope","text":"<p>Oscilloscopes are the perfect tool to capture the waveform of a signal output. While useful, not all users will have access to this type of test equipment. For this example, user will need connect the probe from an oscilloscope to the <code>DAC</code> (<code>A0</code>) and <code>GND</code> GPIO pins.</p> <p>Sine Wave</p> <pre><code>#include \"analogWave.h\" // Include the library for analog waveform generation\n\nanalogWave wave(DAC);   // Create an instance of the analogWave class, using the DAC pin\n\nint freq = 60;  // in hertz, change accordingly\n\nvoid setup() {\n  wave.sine(freq);       // Generate a sine wave with the initial frequency\n}\n\nvoid loop() {}\n</code></pre> <p></p> <p>A screen capture of a sine wave output from the <code>DAC</code> GPIO, which recorded on an oscilloscope.</p> Oscilloscope Adjustments <p>The DAC of the RA6M5, generates a waveform with a positive voltage. Therefore, user may need to adjust the vertical position of the probe's input channel.</p> <p>Users may also find it helpful, to set the trigger on a discretized voltage step.</p>"},{"location":"example-analog/#feedback-loop","title":"Feedback Loop","text":"<p>Another method to record the signal generated by the DAC, is with a jumper (wire) and looping a output signal from the <code>DAC1</code> GPIO pin back into the <code>A2</code> GPIO pin. While an oscilloscope is very useful, this is a more practical and cost-effective alternative for users. With this example, users are free to utilize any method or hardware they have to connect the <code>DAC1</code> and <code>A2</code> GPIO pins together. However, we recommend some IC hooks for a temporary connection.</p> Optional Hardware <ul> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <li> <p> <p>IC Hook with Pigtail CAB-09741</p> <li> <p> <p>Jumper Wires Premium 6\" Mixed Pack of 100 PRT-09194</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Jumper - 2 Pin PRT-09044</p> <p>After users have jumpered the GPIO pins and uploaded the example code, they will need to open the Serial Plotter in the Arduino IDE. Once opened, the tool will begin to plot the values that are received from the serial port. It should be noted that the Serial Plotter tool is unavailable in the legacy Arduino IDE v1.<code>x</code>.<code>x</code>; and some users may need to upgrade to the new Arduino IDE v2.<code>x</code>.<code>x</code> to access this tool. Additionally, the speed and buffer of the Serial Plotter tool are limiting factors in its performance. Therefore, careful consideration should be made when adjusting the waveform frequency and the delay intervals between readings.</p> <p>Sine Wave</p> <pre><code>#include \"analogWave.h\" // Include the library for analog waveform generation\n\nanalogWave wave(DAC1);   // Create an instance of the analogWave class, using the DAC pin\n\nint freq = 1;  // in hertz, change accordingly\n\nvoid setup() {\n  Serial.begin(115200);  // Initialize serial communication at a baud rate of 115200\n  wave.sine(freq);       // Generate a sine wave with the initial frequency\n}\n\nvoid loop() {\n  // Print the updated frequency to the serial monitor\n  Serial.println(String(analogRead(A2)));\n  delay(20);      // Delay for 20ms before repeating\n}\n</code></pre> <p>Serial Plot</p> <p> Serial Plot of a sine wave output from the <code>DAC</code> GPIO, which was read by the <code>A2</code> GPIO. </p> Other Waveforms <p>Users can modify this example to generate other types of waveforms, as shown in the examples below.</p> <p> Serial Plot of a square wave generated by the <code>DAC</code> GPIO, which was recorded by the <code>A2</code> GPIO. </p> <p>Square Wave</p> <p>Users can modify the type of waveform output by the DAC. The modification below will generate a square waveform:</p> <pre><code>wave.sine(freq);\nwave.square(freq);\n</code></pre> <p> Serial Plot of a sawtooth wave generated by the <code>DAC</code> GPIO, which was recorded by the <code>A2</code> GPIO. </p> <p>Sawtooth Wave</p> <p>Users can modify the type of waveform output by the DAC. The modification below will generate a sawtooth waveform:</p> <pre><code>wave.sine(freq);\nwave.saw(freq);\n</code></pre>"},{"location":"example-codeless/","title":"CodeLess","text":""},{"location":"example-codeless/#at-commands","title":"AT Commands","text":"<p>To help users get started with the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have provided an <code>SerialPassthrough</code> example in our unofficial Arduino library. Once programmed on the RA6M5 Thing Plus, the example allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. Thereby, enabling users to experiment with the CodeLess AT commands and develop their own BLE connectivity solution. Users can find this sketch in the File &gt; Examples &gt; SparkFun Renesas Codeless BLE &gt; SerialPassthrough drop-down menu.</p> <code>SerialPassthrough.ino</code> <pre><code>/*\n  SerialPassthrough sketch\n\n  Some boards have a USB serial port that operates independently from the\n  hardware serial port(s) attached their Digital pins. This means that the\n  \"serial passthrough\" which is possible with the Arduino UNO (commonly used\n  to interact with devices/shields that require configuration via serial AT\n  commands) will not operate in a similar manner.\n\n  This sketch allows users to emulate the serial passthrough behaviour. (i.e.\n  Any text typed in the IDE Serial monitor will be written to the serial port\n  oof the Digital pins, and vice-versa.)\n\n  created 23 May 2016\n  by Erik Nyquist\n\n  https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialPassthrough\n\n\n  This sketch has been modified for the SparkFun Ting Plus - RA6M5. \"Serial\"\n  refers to the USB Serial port attached to the Serial Monitor, and \"Serial2\"\n  refers to the hardware serial port attached to pins D31 and D32; for the\n  DA14531MOD Bluetooth module. This sketch will emulate Serial passthrough\n  for those two Serial ports on the bSparkFun Ting Plus - RA6M5. The default\n  communication settings for the DA14531MOD are:\n\n  BaudRate : 57600\n  DataBits : 8\n  StopBits : 1\n  Parity : None\n  Flow Control : None\n  Transmit Text: Append CR\n\n  Modified 18 March 2024\n  by SparkFun Electronics\n  author: Wes F\n\n*/\n\nvoid setup() {\n  Serial.begin(57600);\n  Serial2.begin(57600);\n}\n\nvoid loop() {\n  if (Serial.available()) {        // If anything comes in Serial (USB),\n    Serial2.write(Serial.read());  // read it and send it out Serial1 (pins 0 &amp; 1)\n  }\n\n  if (Serial2.available()) {       // If anything comes in Serial1 (pins 0 &amp; 1)\n    Serial.write(Serial2.read());  // read it and send it out Serial (USB)\n  }\n}\n</code></pre> <p>Serial Monitor</p> <p>Users should configure the serial port with a baud rate at 57600 bps and enable the carriage return on the transmissions.</p>"},{"location":"example-codeless/#demo-ble-solution","title":"Demo - BLE Solution","text":"<p>While an Arduino library isn't necessary to utilize the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have created an unofficial Arduino library to help users get started. Once the library is installed in the Arduino IDE, users will find several example sketches listed in the File &gt; Examples &gt; SparkFun Renesas Codeless BLE drop-down menu. We recommend users check out the following examples that demonstrate a basic BLE connectivity solution:</p> <ul> <li><code>codelessBLE_peripheral.ino</code></li> <li><code>codelessBLE_central.ino</code></li> </ul> <p>In order to operate the <code>codelessBLE_peripheral.ino</code> and <code>codelessBLE_central.ino</code> examples, users will need two RA6M5 Thing Plus boards, Qwiic OLED Display, Qwiic BME280 sensor, and some Qwiic cables.</p> Required Hardware <ul> <li> <p> <p>RA6M5 Thing Plus WRL-24243</p> <li> <p> <p>SparkFun Qwiic Cable Kit KIT-15081</p> <li> <p> <p>SparkFun Qwiic OLED Display (0.91 in., 128x32) LCD-24606</p> <li> <p> <p>SparkFun Atmospheric Sensor Breakout - BME280 (Qwiic) SEN-15440</p> <code>codelessBLE_peripheral.ino</code><code>codelessBLE_central.ino</code> <p>This sketch requires a Qwiic BME280 sensor, connected by a Qwiic cable, to be connected the RA6M5 Thing Plus. The sketch demonstrates a basic BLE solution, by transmitting data from the BME280 to another BLE device. Users can find this sketch in the File &gt; Examples &gt; SparkFun Renesas Codeless BLE &gt; codelessBLE_peripheral drop-down menu.</p> Install Arduino Library <p>For this example, the SparkFun BME280 Arduino Library will need to be installed. In the Arduino IDE, users can install it by searching for <code>SparkFun BME280 Arduino Library</code>, in the Library Manager:</p> <pre><code>SparkFun BME280 Arduino Library\n</code></pre> <code>codelessBLE_peripheral.ino</code> <pre><code>/**\n * @file codelessBLE_peripheral.ino\n * @brief This file contains the code for a BLE peripheral device that \n * communicates with a BME280 sensor.\n * \n * The code sets up a BLE peripheral device using the CodelessBLEPeripheral \n * class and establishes a connection with the onboard BLE coprocessor. It \n * also initializes a BME280 sensor and reads temperature, humidity, and \n * pressure values from it. The sensor data is then sent to the connected BLE \n * central device periodically.\n * \n * The code handles the connection and disconnection events from the BLE device\n * and prints the received data to the Serial monitor.\n * \n * This code is intended to be used with the SparkFun Thing Plus - RA6M5 \n * development board.\n */\n#include &lt;codelessBLEPeripheral.h&gt;\n#include &lt;Wire.h&gt;\n#include \"SparkFunBME280.h\"\n\nCodelessPeripheralDevice myBLEPeripheral;\nBME280 myBME280;\n\nbool bleConnected = false;\nbool reset_loop = false;\nuint32_t loop_start_time = 0;\nString printstring = \"\";\n\nvoid setup()\n{\n    pinMode(LED_BUILTIN, OUTPUT);\n    digitalWrite(LED_BUILTIN, HIGH);\n\n    Serial.begin(57600);\n    // while(!Serial){delay(100);}; // Uncomment during testing and needing a serial connection.\n    Serial.println(\"Begin BLE Peripheral Demo.\");\n\n    #if defined(CODELESS_DBG)\n    Serial.println(\"CODELESS_DBG defined.\");\n    #endif\n\n    Wire.begin();\n\n    if(!myBME280.beginI2C())\n    {\n        Serial.println(\"Sensor didn't respond. Check wiring!\");\n        while(1);\n    }\n\n    Serial.println(\"Connected to BME280.\");\n\n    myBLEPeripheral.begin();\n    while(!Serial2){delay(100);};\n    Serial.println(\"Connected to BLE coprocessor.\");\n\n    Serial.println(\"Running default setup routine.\");\n    myBLEPeripheral.setupDefault();\n\n    Serial.print(\"Peripheral Device Address: \");\n    Serial.print(myBLEPeripheral.sendCommand(\"AT+BDADDR\"));\n\n    Serial.println(\"Setup complete.\");\n    digitalWrite(LED_BUILTIN, LOW);\n\n    loop_start_time = millis();\n}\n\nvoid loop()\n{\n    if((loop_start_time - millis()) &gt; 100) // If it's been more than 100ms\n    {\n        reset_loop = true;\n        if(bleConnected)\n        {\n            digitalWrite(LED_BUILTIN, HIGH);\n            printstring = \"|\"+String(myBME280.readTempC())+\",\"+String(myBME280.readFloatHumidity())+\",\"+String(myBME280.readFloatPressure());\n            Serial.print(myBLEPeripheral.sendCommand(printstring));\n            digitalWrite(LED_BUILTIN, LOW);\n        }\n\n        if (myBLEPeripheral.available()) {       // If anything comes in Serial2 (BLE device)\n            String localstring = myBLEPeripheral.readOutput();\n            if(!bleConnected)\n            {\n                if(localstring.endsWith(\"+CONNECTED\\r\\n\"))\n                {\n                    #ifdef CODELESS_DBG\n                    Serial.println(\"[DBG] - outloop - Got connected output.\");\n                    #endif\n                    bleConnected = true;\n                }\n            }\n\n            if(bleConnected)\n            {\n                if(localstring.endsWith(\"+DISCONNECTED\\r\\n\"))\n                {\n                    #ifdef CODELESS_DBG\n                    Serial.println(\"[DBG] - outloop - Got disconnected output.\");\n                    #endif\n                    bleConnected = false;\n                }\n            }\n            Serial.print(localstring);\n        }\n        if(reset_loop &amp;&amp; bleConnected)\n        {\n            reset_loop = false;\n            #ifdef CODELESS_DBG\n            Serial.println();\n            Serial.println(\"Resetting loop\");\n            #endif\n            loop_start_time = millis();\n        }\n    }  \n}\n</code></pre> <p>BME688 Replacement</p> <p>Users can also modify this example to utilize the Qwiic BME688 sensor that is mentioned in some of the other examples. For more details on utilizing the BME68x breakout board, please refer to our hookup guide for the sensor.</p> <ul> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>Flexible Qwiic Cable - 50mm PRT-17260</p> Install Arduino Library <p>Users will need to install the Bosch BME68x Arduino library for the sensor. In the Arduino IDE, users can install it by searching for <code>BME68x Sensor Library</code>, in the Library Manager:</p> <pre><code>BME68x Sensor Library\n</code></pre> Modifications <ul> <li> <p>Link the BME68x Arduino library:</p> <pre><code>#include \"SparkFunBME280.h\"\n#include \"bme68xLibrary.h\"\n</code></pre> </li> <li> <p>Create an instance of the <code>Bme68x</code> class:</p> <pre><code>BME280 myBME280;\nBme68x bme;\n</code></pre> </li> <li> <p>Initialize and configure the sensor in the <code>setup()</code>:</p> <pre><code>if(!myBME280.beginI2C())\n{\n    Serial.println(\"Sensor didn't respond. Check wiring!\");\n    while(1);\n}\n\nSerial.println(\"Connected to BME280.\");\n\nbme.begin(BME68X_I2C_ADDR_LOW, Wire);\n\nif(bme.checkStatus())\n{\n    if (bme.checkStatus() == BME68X_ERROR)\n    {\n        Serial.println(\"Sensor error:\" + bme.statusString());\n        return;\n    }\n    else if (bme.checkStatus() == BME68X_WARNING)\n    {\n        Serial.println(\"Sensor Warning:\" + bme.statusString());\n    }\n}\n\n/* Set the default configuration for temperature, pressure and humidity */\nbme.setTPH();\n\n/* Configure the sensor to forced mode */\nbme.setOpMode(BME68X_FORCED_MODE);\n</code></pre> </li> <li> <p>Update the <code>loop()</code> to retrieve data from the BME688</p> <pre><code>if((loop_start_time - millis()) &gt; 100) // If it's been more than 100ms\n{\n    reset_loop = true;\n    if(bleConnected)\n    {\n        digitalWrite(LED_BUILTIN, HIGH);\n        printstring = \"|\"+String(myBME280.readTempC())+\",\"+String(myBME280.readFloatHumidity())+\",\"+String(myBME280.readFloatPressure());\n        Serial.println(myBLEPeripheral.sendCommand(printstring));\n        digitalWrite(LED_BUILTIN, LOW);\n    }\n\nbme68xData data;\n\nif((loop_start_time - millis()) &gt; 100)    // If it's been more than 100ms\n{\n    reset_loop = true;\n    if(bleConnected)\n    {\n        digitalWrite(LED_BUILTIN, HIGH);\n\n        delayMicroseconds(bme.getMeasDur());  // Wait for measurement data\n\n        /* Retrieve data from BME688 sensor*/\n        if (bme.fetchData())\n        {\n            bme.getData(data);\n            printstring = \"|\"+String(data.temperature)+\",\"+String(data.humidity)+\",\"+String(data.pressure);\n        }\n\n        Serial.print(myBLEPeripheral.sendCommand(printstring));\n        digitalWrite(LED_BUILTIN, LOW);\n    }\n</code></pre> </li> </ul> <p>This sketch requires a Qwiic OLED Display to be connected the RA6M5 Thing Plus, by a Qwiic cable. The sketch receives data transmitted from a RA6M5 Thing Plus, programmed with the <code>codelessBLE_peripheral.ino</code> sketch, and displays that data on the OLED display. Users can find this sketch in the File &gt; Examples &gt; SparkFun Renesas Codeless BLE &gt; codelessBLE_central drop-down menu.</p> <code>codelessBLE_central.ino</code> <pre><code>/**\n * @file codelessBLE_central.ino\n * @brief This file contains the code for a BLE central device that connects to\n * a peripheral device and displays sensor data on an OLED display.\n * \n * The code sets up a BLE central device using the CodelessBLECentral class. It \n * establishes a connection with a specific peripheral device, then receives \n * and displays the data on an OLED display using the SparkFun_Qwiic_OLED \n * library.\n * \n * The RA6M5 processor communicates to the BLE coprocessor over a serial \n * connection. It sends commands to the peripheral device and receives \n * responses, which are then displayed on the serial monitor. The sensor data \n * received from the peripheral device is parsed and displayed on the OLED \n * display.\n * \n * This code is intended to be used with the SparkFun Thing Plus - RA6M5 \n * development board.\n */\n\n#include &lt;codelessBLECentral.h&gt;\n#include &lt;Wire.h&gt;\n#include &lt;SparkFun_Qwiic_OLED.h&gt; // https://librarymanager/All#SparkFun_Qwiic_OLED\n#include &lt;res/qw_fnt_5x7.h&gt;\n\nCodelessCentralDevice myBLECentral;\nQwiicNarrowOLED myOLED;\n\nString peripheralAddress = \"48:23:35:34:74:D3\"; // Hardware specific, change to your peripheral's address.\nString localstring = \"\";\nString printstring_temp = \"\";\nString printstring_hum = \"\";\nString printstring_press = \"\";\n\nvoid setup()\n{\n    pinMode(LED_BUILTIN, OUTPUT);\n    digitalWrite(LED_BUILTIN, HIGH);\n    Serial.begin(DEFAULT_CODELESS_BAUD_RATE);\n    // while(!Serial){delay(100);}; // Uncomment during testing and needing a serial connection.\n    Serial.println(\"Begin BLE Central Demo.\");\n\n    #if defined(CODELESS_DBG)\n    Serial.println(\"CODELESS_DBG defined.\");\n    #endif\n\n    Wire.begin();\n    if(myOLED.begin() == false)\n    {\n        Serial.println(\"Unable to communicate with display. Freezing...\");\n        while(1);\n    }\n\n    Serial.println(\"Connected to display.\");\n    myOLED.setFont(QW_FONT_5X7);\n\n    myOLED.erase();\n\n    String hello = \"Codeless BLE Demo\";\n\n    int x0 = (myOLED.getWidth() - myOLED.getStringWidth(hello)) / 2;\n    int y0 = (myOLED.getHeight() - myOLED.getStringHeight(\"a\")) / 2;\n    myOLED.text(x0, y0, hello);\n    myOLED.display();\n\n    myBLECentral.begin();\n    while(!Serial2){delay(100);};\n    Serial.println(\"Connected to BLE coprocessor.\");\n\n    Serial.println(\"Running default setup routine.\");\n    myBLECentral.setupDefault();\n\n    Serial.print(\"Central device address: \");\n    Serial.print(myBLECentral.sendCommand(\"AT+BDADDR\"));\n\n    myBLECentral.connectToPeripheral(peripheralAddress);\n\n    Serial.println(\"Setup complete.\");\n    digitalWrite(LED_BUILTIN, LOW);\n\n    hello = \"Wait for conn...\";\n    x0 = (myOLED.getWidth() - myOLED.getStringWidth(hello)) / 2;\n    y0 = (myOLED.getHeight() - myOLED.getStringHeight(\"a\")) / 2;\n    myOLED.erase();\n    myOLED.text(x0, y0, hello);\n    myOLED.display();\n}\n\nvoid loop()\n{\n    if (Serial.available()) {        // If anything comes in Serial (USB),\n        Serial.print(myBLECentral.sendCommand(Serial.readString()));  // read, then command BLE, write response back to Serial.\n    }\n\n    if (myBLECentral.available()) {       // If anything comes in Serial2 (BLE device)\n        localstring = myBLECentral.readOutput();\n        localstring.trim(); // remove leading and trailing \\r \\n whitespace.\n        int16_t index = localstring.indexOf(\"|\");\n\n        if(index &gt; -1)\n        {\n            #ifdef CODELESS_DBG\n            Serial.print(\"[DBG] - loop - readOutput - String contains | at index \");\n            Serial.print(index);\n            Serial.println(\".\");\n            #endif\n            localstring+=\"\\r\";\n            localstring.remove(index,1);\n            String temp = localstring.substring(0,localstring.indexOf(\",\"));\n            String hum = localstring.substring(localstring.indexOf(\",\")+1, localstring.indexOf(\",\", localstring.indexOf(\",\")+1));\n            String press = localstring.substring(localstring.lastIndexOf(\",\")+1);\n            Serial.print(\"T: \");\n            Serial.print(temp);\n            Serial.print(\" H: \");\n            Serial.print(hum);\n            Serial.print(\" P: \");\n            Serial.println(press);\n\n            printstring_temp = \"T: \"+temp+\" dC\";\n            int ytemp = (myOLED.getHeight()/3) - myOLED.getStringHeight(printstring_temp);\n            printstring_hum = \"H: \"+hum+\" %RH\";\n            int yhum = (myOLED.getHeight() / 3 * 2) - myOLED.getStringHeight(printstring_hum);\n            printstring_press = \"P: \"+press+\" Pa\";\n            int ypress = myOLED.getHeight() - myOLED.getStringHeight(printstring_press);\n\n            myOLED.erase();\n            myOLED.text(3, ytemp, printstring_temp);\n            myOLED.display();\n            myOLED.text(3, yhum, printstring_hum);\n            myOLED.display();\n            myOLED.text(3, ypress, printstring_press);\n            myOLED.display();\n        }\n        else\n        {\n            Serial.println(localstring);\n        }\n    }\n}\n</code></pre>"},{"location":"example-digital/","title":"Digital I/O","text":""},{"location":"example-digital/#digital-output","title":"Digital Output","text":"<p>LEDs are a perfect visual indicator for the operation of a digital output.</p>"},{"location":"example-digital/#led-blink","title":"LED - Blink","text":"<p>Below, is one of the simplest built-in examples of the Arduino IDE. Users can find this sketch in the File &gt; Examples &gt; 01.Basics &gt; Blink drop-down menu. The example toggles the digital output of the GPIO pin connected to the blue, <code>STAT</code> (status) LED.</p> <p>Tip</p> <p>Users do not have to worry about modifying the sketch for the GPIO pin that is connected to the <code>STAT</code> LED. The pin is already defined in the Arduino core with the <code>LED_BUILTIN</code> variable. Therefore, no adjustments are necessary to utilize this example code.</p> <code>Blink.ino</code> <p></p>"},{"location":"example-digital/#led-pwm","title":"LED - PWM","text":"<p>LEDs are also great visual indicators for PWM outputs.</p> <p>On the RA6M5 Thing Plus, the GPIO pin connected to the <code>STAT</code> LED is also capable of generating a PWM output. There are two built-in examples in the Arduino IDE for operating a PWM output on an LED. The sketches operate by oscillating the duty cycle of the PWM signal from the GPIO pin so that the LED appears to be dimming or fading.</p> <p>Tip</p> <p>Users will need to modify the sketches below, for the GPIO pin that is connected to the <code>STAT</code> LED. As mentioned in the example above, they can use the predefined <code>LED_BUILTIN</code> variable. Users will need to replace the highlighted line with the modification using the <code>LED_BUILTIN</code> variable to define the GPIO pin connected to the <code>STAT</code> LED.</p> <p><code>Fade.ino</code></p> <pre><code>    int led = 9;         // the PWM pin the LED is attached to\n    int led = LED_BUILTIN; // the PWM pin the LED is attached to\n</code></pre> <p><code>Fading.ino</code></p> <pre><code>    int ledPin = 9;  // LED connected to digital pin 9\n    int ledPin = LED_BUILTIN;  // LED connected to digital pin 14\n</code></pre> <code>Fade.ino</code><code>Fading.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; 01.Basics &gt; Fade drop-down menu.</p> <code>Fade.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 03.Analog &gt; Fading drop-down menu.</p> <p>PWM \u2260 Analog</p> <p>Although this example is listed under the 03.Analog menu, users should keep in mind that a PWM output is not a true analog signal. PWM signals can only emulate an analog output, based on the average voltage output of their square waveform.</p> <code>Fading.ino</code> <p></p>"},{"location":"example-digital/#led-ws2812","title":"LED - WS2812","text":"<p>Warning</p> <p>Support for the new Renesas Arduino boards has not been officially released for the FastLED Arduino library. Users should follow the installation steps documented in the Software Overview.</p> <p>The WS2812 is an addressable RGB LED that operates with a digital signal that stacks frames of 24-bit data, per LED in a chain. We recommend that the FastLED Arduino library be utilized in the Arduino IDE, to control the RGB LED on the RA6M5 Thing Plus. Once the library is installed in the Arduino IDE, users will find several example sketches listed in the File &gt; Examples &gt; FastLED &gt; drop-down menu. We recommend the following examples for users to get started:</p> <ul> <li><code>Blink.ino</code></li> <li><code>ColorTemperature.ino</code></li> <li><code>ColorPalette.ino</code></li> </ul> <p>Tip</p> <p>Below, are a few tips for users to start working with the FastLED Arduino library. However, for more details, users should refer to the documentation for the FastLED Arduino library.</p> Define Parameters <p>When utilizing the examples in the FastLED Arduino library, users may need to define and/or modify a few parameters:</p> <pre><code>// GPIO pins connected to the LED\n#define LED_PIN      LED_RGB // (1)!\n// #define CLOCK_PIN      13 (2)\n\n// Information about the LED (strip)\n#define NUM_LEDS    1        // (3)!\n#define CHIPSET     WS2812   // (4)!\n#define COLOR_ORDER GRB      // (5)!\n\n// Define the array of leds\nCRGB leds[NUM_LEDS];\n\n// \n#define BRIGHTNESS  40       // (6)!\n</code></pre> <ol> <li>For the RA6M5 Thing Plus, users can either refer to the predefined variable <code>LED_RGB</code> or define the pin as <code>13</code> (<code>D13</code>) for the RGB LED</li> <li>A clock pin is not required for the WS2812 LED on the RA6M5 Thing Plus; comment out any mentions of it</li> <li>On the RA6M5 Thing Plus, there is only one RGB LED included on the board</li> <li>The RGB LED on the RA6M5 Thing Plus is a WS2812 LED</li> <li>The format of the color order in the WS2812's data frames is Green, Red, Blue (GRB)</li> <li> <p>Some of the examples may define an LED brightness; this should be an 8-bit value (<code>0</code>-<code>255</code>). Below, is a table of reference values for users to get started with:</p> Environment Description Value Dark Room Start to see primary colors <code>5</code> - <code>12</code> Direct Sunlight Start to see primary colors &gt; <code>60</code> Direct Sunlight Start to see color blending <code>100</code> - <code>180</code> Direct Sunlight Decent color blending &gt; <code>230</code> </li> </ol> Instantiate LED Controller <p>Most of the examples in the FastLED library predefine parameters for the LED (strip), as shown above. Later in the sketches, an instance of the LED controller is created; therefore, if users have already modified all the parameters above, no other modifications should be necessary:</p> <pre><code>FastLED.addLeds&lt;CHIPSET, LED_PIN, COLOR_ORDER&gt;(leds, NUM_LEDS);\n</code></pre> <p>Otherwise, users will need to locate where the instance of the LED controller is created and provide the required values. Users will also need to configure the LED brightness later in the sketch, if that predefined variable isn't provided either:</p> <pre><code>FastLED.addLeds&lt;WS2812, 13, GRB&gt;(leds, 1);\nFastLED.setBrightness(&lt;value&gt;);\n</code></pre> <p>The example code should still enumerate the order of the RGB color channels, required for the data frames of the LED chipset. However, users may need to modify the enumerator to <code>GRB</code>:</p> <pre><code>#define COLOR_ORDER GRB\n</code></pre> <code>Blink.ino</code><code>ColorTemperature.ino</code><code>ColorPalette.ino</code>Sunlight Test <p>Users can find this sketch in the File &gt; Examples &gt; FastLED &gt; Blink drop-down menu.</p> <code>Blink.ino</code> <pre><code>/// @file    Blink.ino\n/// @brief   Blink the first LED of an LED strip\n/// @example Blink.ino\n\n#include &lt;FastLED.h&gt;\n\n// How many leds in your strip?\n#define NUM_LEDS 1\n\n// For led chips like WS2812, which have a data line, ground, and power, you just\n// need to define DATA_PIN.  For led chipsets that are SPI based (four wires - data, clock,\n// ground, and power), like the LPD8806 define both DATA_PIN and CLOCK_PIN\n// Clock pin only needed for SPI based chipsets when not using hardware SPI\n#define DATA_PIN 3\n#define CLOCK_PIN 13\n\n// Define the array of leds\nCRGB leds[NUM_LEDS];\n\nvoid setup() { \n    // Uncomment/edit one of the following lines for your leds arrangement.\n    // ## Clockless types ##\n    FastLED.addLeds&lt;NEOPIXEL, DATA_PIN&gt;(leds, NUM_LEDS);  // GRB ordering is assumed\n    // FastLED.addLeds&lt;SM16703, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1829, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1812, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1809, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1804, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1803, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;UCS1903, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;UCS1903B, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;UCS1904, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;UCS2903, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2812, DATA_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;WS2852, DATA_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;WS2812B, DATA_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;GS1903, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;SK6812, DATA_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;SK6822, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;APA106, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;PL9823, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;SK6822, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2811, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2813, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;APA104, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2811_400, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;GE8822, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;GW6205, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;GW6205_400, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;LPD1886, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;LPD1886_8BIT, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // ## Clocked (SPI) types ##\n    // FastLED.addLeds&lt;LPD6803, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;LPD8806, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;WS2801, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2803, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;SM16716, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;P9813, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // BGR ordering is typical\n    // FastLED.addLeds&lt;DOTSTAR, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // BGR ordering is typical\n    // FastLED.addLeds&lt;APA102, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // BGR ordering is typical\n    // FastLED.addLeds&lt;SK9822, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // BGR ordering is typical\n}\n\nvoid loop() { \n  // Turn the LED on, then pause\n  leds[0] = CRGB::Red;\n  FastLED.show();\n  delay(500);\n  // Now turn the LED off, then pause\n  leds[0] = CRGB::Black;\n  FastLED.show();\n  delay(500);\n}\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; FastLED &gt; ColorTemperature drop-down menu.</p> <code>ColorTemperature.ino</code> <pre><code>/// @file    ColorTemperature.ino\n/// @brief   Demonstrates how to use @ref ColorTemperature based color correction\n/// @example ColorTemperature.ino\n\n#include &lt;FastLED.h&gt;\n\n#define LED_PIN     3\n\n// Information about the LED strip itself\n#define NUM_LEDS    60\n#define CHIPSET     WS2811\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];\n\n#define BRIGHTNESS  128\n\n\n// FastLED provides two color-management controls:\n//   (1) color correction settings for each LED strip, and\n//   (2) master control of the overall output 'color temperature' \n//\n// THIS EXAMPLE demonstrates the second, \"color temperature\" control.\n// It shows a simple rainbow animation first with one temperature profile,\n// and a few seconds later, with a different temperature profile.\n//\n// The first pixel of the strip will show the color temperature.\n//\n// HELPFUL HINTS for \"seeing\" the effect in this demo:\n// * Don't look directly at the LED pixels.  Shine the LEDs aganst\n//   a white wall, table, or piece of paper, and look at the reflected light.\n//\n// * If you watch it for a bit, and then walk away, and then come back \n//   to it, you'll probably be able to \"see\" whether it's currently using\n//   the 'redder' or the 'bluer' temperature profile, even not counting\n//   the lowest 'indicator' pixel.\n//\n//\n// FastLED provides these pre-conigured incandescent color profiles:\n//     Candle, Tungsten40W, Tungsten100W, Halogen, CarbonArc,\n//     HighNoonSun, DirectSunlight, OvercastSky, ClearBlueSky,\n// FastLED provides these pre-configured gaseous-light color profiles:\n//     WarmFluorescent, StandardFluorescent, CoolWhiteFluorescent,\n//     FullSpectrumFluorescent, GrowLightFluorescent, BlackLightFluorescent,\n//     MercuryVapor, SodiumVapor, MetalHalide, HighPressureSodium,\n// FastLED also provides an \"Uncorrected temperature\" profile\n//    UncorrectedTemperature;\n\n#define TEMPERATURE_1 Tungsten100W\n#define TEMPERATURE_2 OvercastSky\n\n// How many seconds to show each temperature before switching\n#define DISPLAYTIME 20\n// How many seconds to show black between switches\n#define BLACKTIME   3\n\nvoid loop()\n{\n  // draw a generic, no-name rainbow\n  static uint8_t starthue = 0;\n  fill_rainbow( leds + 5, NUM_LEDS - 5, --starthue, 20);\n\n  // Choose which 'color temperature' profile to enable.\n  uint8_t secs = (millis() / 1000) % (DISPLAYTIME * 2);\n  if( secs &lt; DISPLAYTIME) {\n    FastLED.setTemperature( TEMPERATURE_1 ); // first temperature\n    leds[0] = TEMPERATURE_1; // show indicator pixel\n  } else {\n    FastLED.setTemperature( TEMPERATURE_2 ); // second temperature\n    leds[0] = TEMPERATURE_2; // show indicator pixel\n  }\n\n  // Black out the LEDs for a few secnds between color changes\n  // to let the eyes and brains adjust\n  if( (secs % DISPLAYTIME) &lt; BLACKTIME) {\n    memset8( leds, 0, NUM_LEDS * sizeof(CRGB));\n  }\n\n  FastLED.show();\n  FastLED.delay(8);\n}\n\nvoid setup() {\n  delay( 3000 ); // power-up safety delay\n  // It's important to set the color correction for your LED strip here,\n  // so that colors can be more accurately rendered through the 'temperature' profiles\n  FastLED.addLeds&lt;CHIPSET, LED_PIN, COLOR_ORDER&gt;(leds, NUM_LEDS).setCorrection( TypicalSMD5050 );\n  FastLED.setBrightness( BRIGHTNESS );\n}\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; FastLED &gt; ColorPalette drop-down menu.</p> <code>ColorPalette.ino</code> <pre><code>/// @file    ColorPalette.ino\n/// @brief   Demonstrates how to use @ref ColorPalettes\n/// @example ColorPalette.ino\n\n#include &lt;FastLED.h&gt;\n\n#define LED_PIN     5\n#define NUM_LEDS    50\n#define BRIGHTNESS  64\n#define LED_TYPE    WS2811\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];\n\n#define UPDATES_PER_SECOND 100\n\n// This example shows several ways to set up and use 'palettes' of colors\n// with FastLED.\n//\n// These compact palettes provide an easy way to re-colorize your\n// animation on the fly, quickly, easily, and with low overhead.\n//\n// USING palettes is MUCH simpler in practice than in theory, so first just\n// run this sketch, and watch the pretty lights as you then read through\n// the code.  Although this sketch has eight (or more) different color schemes,\n// the entire sketch compiles down to about 6.5K on AVR.\n//\n// FastLED provides a few pre-configured color palettes, and makes it\n// extremely easy to make up your own color schemes with palettes.\n//\n// Some notes on the more abstract 'theory and practice' of\n// FastLED compact palettes are at the bottom of this file.\n\n\n\nCRGBPalette16 currentPalette;\nTBlendType    currentBlending;\n\nextern CRGBPalette16 myRedWhiteBluePalette;\nextern const TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM;\n\n\nvoid setup() {\n    delay( 3000 ); // power-up safety delay\n    FastLED.addLeds&lt;LED_TYPE, LED_PIN, COLOR_ORDER&gt;(leds, NUM_LEDS).setCorrection( TypicalLEDStrip );\n    FastLED.setBrightness(  BRIGHTNESS );\n\n    currentPalette = RainbowColors_p;\n    currentBlending = LINEARBLEND;\n}\n\n\nvoid loop()\n{\n    ChangePalettePeriodically();\n\n    static uint8_t startIndex = 0;\n    startIndex = startIndex + 1; /* motion speed */\n\n    FillLEDsFromPaletteColors( startIndex);\n\n    FastLED.show();\n    FastLED.delay(1000 / UPDATES_PER_SECOND);\n}\n\nvoid FillLEDsFromPaletteColors( uint8_t colorIndex)\n{\n    uint8_t brightness = 255;\n\n    for( int i = 0; i &lt; NUM_LEDS; ++i) {\n        leds[i] = ColorFromPalette( currentPalette, colorIndex, brightness, currentBlending);\n        colorIndex += 3;\n    }\n}\n\n\n// There are several different palettes of colors demonstrated here.\n//\n// FastLED provides several 'preset' palettes: RainbowColors_p, RainbowStripeColors_p,\n// OceanColors_p, CloudColors_p, LavaColors_p, ForestColors_p, and PartyColors_p.\n//\n// Additionally, you can manually define your own color palettes, or you can write\n// code that creates color palettes on the fly.  All are shown here.\n\nvoid ChangePalettePeriodically()\n{\n    uint8_t secondHand = (millis() / 1000) % 60;\n    static uint8_t lastSecond = 99;\n\n    if( lastSecond != secondHand) {\n        lastSecond = secondHand;\n        if( secondHand ==  0)  { currentPalette = RainbowColors_p;         currentBlending = LINEARBLEND; }\n        if( secondHand == 10)  { currentPalette = RainbowStripeColors_p;   currentBlending = NOBLEND;  }\n        if( secondHand == 15)  { currentPalette = RainbowStripeColors_p;   currentBlending = LINEARBLEND; }\n        if( secondHand == 20)  { SetupPurpleAndGreenPalette();             currentBlending = LINEARBLEND; }\n        if( secondHand == 25)  { SetupTotallyRandomPalette();              currentBlending = LINEARBLEND; }\n        if( secondHand == 30)  { SetupBlackAndWhiteStripedPalette();       currentBlending = NOBLEND; }\n        if( secondHand == 35)  { SetupBlackAndWhiteStripedPalette();       currentBlending = LINEARBLEND; }\n        if( secondHand == 40)  { currentPalette = CloudColors_p;           currentBlending = LINEARBLEND; }\n        if( secondHand == 45)  { currentPalette = PartyColors_p;           currentBlending = LINEARBLEND; }\n        if( secondHand == 50)  { currentPalette = myRedWhiteBluePalette_p; currentBlending = NOBLEND;  }\n        if( secondHand == 55)  { currentPalette = myRedWhiteBluePalette_p; currentBlending = LINEARBLEND; }\n    }\n}\n\n// This function fills the palette with totally random colors.\nvoid SetupTotallyRandomPalette()\n{\n    for( int i = 0; i &lt; 16; ++i) {\n        currentPalette[i] = CHSV( random8(), 255, random8());\n    }\n}\n\n// This function sets up a palette of black and white stripes,\n// using code.  Since the palette is effectively an array of\n// sixteen CRGB colors, the various fill_* functions can be used\n// to set them up.\nvoid SetupBlackAndWhiteStripedPalette()\n{\n    // 'black out' all 16 palette entries...\n    fill_solid( currentPalette, 16, CRGB::Black);\n    // and set every fourth one to white.\n    currentPalette[0] = CRGB::White;\n    currentPalette[4] = CRGB::White;\n    currentPalette[8] = CRGB::White;\n    currentPalette[12] = CRGB::White;\n\n}\n\n// This function sets up a palette of purple and green stripes.\nvoid SetupPurpleAndGreenPalette()\n{\n    CRGB purple = CHSV( HUE_PURPLE, 255, 255);\n    CRGB green  = CHSV( HUE_GREEN, 255, 255);\n    CRGB black  = CRGB::Black;\n\n    currentPalette = CRGBPalette16(\n                                   green,  green,  black,  black,\n                                   purple, purple, black,  black,\n                                   green,  green,  black,  black,\n                                   purple, purple, black,  black );\n}\n\n\n// This example shows how to set up a static color palette\n// which is stored in PROGMEM (flash), which is almost always more\n// plentiful than RAM.  A static PROGMEM palette like this\n// takes up 64 bytes of flash.\nconst TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM =\n{\n    CRGB::Red,\n    CRGB::Gray, // 'white' is too bright compared to red and blue\n    CRGB::Blue,\n    CRGB::Black,\n\n    CRGB::Red,\n    CRGB::Gray,\n    CRGB::Blue,\n    CRGB::Black,\n\n    CRGB::Red,\n    CRGB::Red,\n    CRGB::Gray,\n    CRGB::Gray,\n    CRGB::Blue,\n    CRGB::Blue,\n    CRGB::Black,\n    CRGB::Black\n};\n\n\n\n// Additional notes on FastLED compact palettes:\n//\n// Normally, in computer graphics, the palette (or \"color lookup table\")\n// has 256 entries, each containing a specific 24-bit RGB color.  You can then\n// index into the color palette using a simple 8-bit (one byte) value.\n// A 256-entry color palette takes up 768 bytes of RAM, which on Arduino\n// is quite possibly \"too many\" bytes.\n//\n// FastLED does offer traditional 256-element palettes, for setups that\n// can afford the 768-byte cost in RAM.\n//\n// However, FastLED also offers a compact alternative.  FastLED offers\n// palettes that store 16 distinct entries, but can be accessed AS IF\n// they actually have 256 entries; this is accomplished by interpolating\n// between the 16 explicit entries to create fifteen intermediate palette\n// entries between each pair.\n//\n// So for example, if you set the first two explicit entries of a compact \n// palette to Green (0,255,0) and Blue (0,0,255), and then retrieved \n// the first sixteen entries from the virtual palette (of 256), you'd get\n// Green, followed by a smooth gradient from green-to-blue, and then Blue.\n</code></pre> <p>This sketch allows users to test the brightness of the WS2812 RGB LED on the RA6M5 Thing Plus in direct sunlight. The sketch implements an interrupt on the USRBTN button to increase the brightness of the LED in increments. The brightness value is then displayed on the Qwiic OLED Display, which is connected by a Qwiic cable.</p> Optional Hardware <ul> <li> <p> <p>Flexible Qwiic Cable - 50mm PRT-17260</p> <li> <p> <p>SparkFun Qwiic OLED Display (0.91 in., 128x32) LCD-24606</p> <p>The example code can be found in the GitHub repository. However, users can simply click the button to download the code or expand the box (below) to copy the code.</p> <code>RGB_sunlight.ino</code> <pre><code>/*\n  RGB_sunlight.ino\n\n  ColorPalette.ino (Original)\n\n  This example shows several ways to set up and use 'palettes' of colors\n  with FastLED.\n\n  These compact palettes provide an easy way to re-colorize your\n  animation on the fly, quickly, easily, and with low overhead.\n\n  USING palettes is MUCH simpler in practice than in theory, so first just\n  run this sketch, and watch the pretty lights as you then read through\n  the code.  Although this sketch has eight (or more) different color schemes,\n  the entire sketch compiles down to about 6.5K on AVR.\n\n  FastLED provides a few pre-configured color palettes, and makes it\n  extremely easy to make up your own color schemes with palettes.\n\n  Some notes on the more abstract 'theory and practice' of\n  FastLED compact palettes are at the bottom of this file.\n\n  Created: June 19, 2014 (Based on GitHub commit)\n  Author: kriegsman\n\n  ===========================================================================\n\n  Used to test the WS2812 RGB LED on the RA6M5 Thing Plus in direct sunlight.\n  The sketch implements an interrupt on the user button to increment the\n  brightness of the LED. The brightness value is displayed on a Qwiic OLED\n  Display (https://www.sparkfun.com/products/24606) connected by a Qwiic\n  cable.\n\n  Modified: April 11, 2024\n  By SparkFun Electronics\n  Author: Wes F\n*/\n\n\n#include &lt;FastLED.h&gt;              // http://librarymanager/All#FastLED\n#include &lt;SparkFun_Qwiic_OLED.h&gt;  // http://librarymanager/All#SparkFun_Qwiic_OLED\n\nQwiicNarrowOLED myOLED;           //\n\n#define LED_PIN 13\n#define NUM_LEDS 1\n// #define BRIGHTNESS 60\n#define LED_TYPE WS2812\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];\n\n#define UPDATES_PER_SECOND 100\n\nCRGBPalette16 currentPalette;\nTBlendType currentBlending;\n\nextern CRGBPalette16 myRedWhiteBluePalette;\nextern const TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM;\n\nint BRIGHTNESS = 75;\n\nvoid setup() {\n  delay(500);  // power-up safety delay\n  FastLED.addLeds&lt;LED_TYPE, LED_PIN, COLOR_ORDER&gt;(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);\n  FastLED.setBrightness(BRIGHTNESS);\n  pinMode(31, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt(31), ChangeBrightness, HIGH);\n\n  currentPalette = RainbowColors_p;\n  currentBlending = LINEARBLEND;\n  Wire.begin();\n\n  // Initalize the OLED device and related graphics system\n  if (myOLED.begin() == false) {\n    while (true)\n      ;\n  }\n}\n\n\nvoid loop() {\n  FastLED.setBrightness(BRIGHTNESS);\n\n  ChangePalettePeriodically();\n\n  static uint8_t startIndex = 0;\n  startIndex = startIndex + 1; /* motion speed */\n\n  FillLEDsFromPaletteColors(startIndex);\n\n  FastLED.show();\n  FastLED.delay(1000 / UPDATES_PER_SECOND);\n\n  myOLED.erase();\n  myOLED.text(0, 0, \"Brightness: \" + String(BRIGHTNESS), 1);\n  myOLED.display();\n}\n\nvoid ChangeBrightness() {\n  BRIGHTNESS = BRIGHTNESS + 20;\n\n  if (BRIGHTNESS &gt; 255) {\n    BRIGHTNESS = 75;\n  }\n}\n\n\nvoid FillLEDsFromPaletteColors(uint8_t colorIndex) {\n  uint8_t brightness = 255;\n\n  for (int i = 0; i &lt; NUM_LEDS; ++i) {\n    leds[i] = ColorFromPalette(currentPalette, colorIndex, brightness, currentBlending);\n    colorIndex += 3;\n  }\n}\n\n\n// There are several different palettes of colors demonstrated here.\n//\n// FastLED provides several 'preset' palettes: RainbowColors_p, RainbowStripeColors_p,\n// OceanColors_p, CloudColors_p, LavaColors_p, ForestColors_p, and PartyColors_p.\n//\n// Additionally, you can manually define your own color palettes, or you can write\n// code that creates color palettes on the fly.  All are shown here.\n\nvoid ChangePalettePeriodically() {\n  uint8_t secondHand = (millis() / 1000) % 60;\n  static uint8_t lastSecond = 99;\n\n  if (lastSecond != secondHand) {\n    lastSecond = secondHand;\n    if (secondHand == 0) {\n      currentPalette = RainbowColors_p;\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 10) {\n      currentPalette = RainbowStripeColors_p;\n      currentBlending = NOBLEND;\n    }\n    if (secondHand == 15) {\n      currentPalette = RainbowStripeColors_p;\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 20) {\n      SetupPurpleAndGreenPalette();\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 25) {\n      SetupTotallyRandomPalette();\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 30) {\n      SetupBlackAndWhiteStripedPalette();\n      currentBlending = NOBLEND;\n    }\n    if (secondHand == 35) {\n      SetupBlackAndWhiteStripedPalette();\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 40) {\n      currentPalette = CloudColors_p;\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 45) {\n      currentPalette = PartyColors_p;\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 50) {\n      currentPalette = myRedWhiteBluePalette_p;\n      currentBlending = NOBLEND;\n    }\n    if (secondHand == 55) {\n      currentPalette = myRedWhiteBluePalette_p;\n      currentBlending = LINEARBLEND;\n    }\n  }\n}\n\n// This function fills the palette with totally random colors.\nvoid SetupTotallyRandomPalette() {\n  for (int i = 0; i &lt; 16; ++i) {\n    currentPalette[i] = CHSV(random8(), 255, random8());\n  }\n}\n\n// This function sets up a palette of black and white stripes,\n// using code.  Since the palette is effectively an array of\n// sixteen CRGB colors, the various fill_* functions can be used\n// to set them up.\nvoid SetupBlackAndWhiteStripedPalette() {\n  // 'black out' all 16 palette entries...\n  fill_solid(currentPalette, 16, CRGB::Black);\n  // and set every fourth one to white.\n  currentPalette[0] = CRGB::White;\n  currentPalette[4] = CRGB::White;\n  currentPalette[8] = CRGB::White;\n  currentPalette[12] = CRGB::White;\n}\n\n// This function sets up a palette of purple and green stripes.\nvoid SetupPurpleAndGreenPalette() {\n  CRGB purple = CHSV(HUE_PURPLE, 255, 255);\n  CRGB green = CHSV(HUE_GREEN, 255, 255);\n  CRGB black = CRGB::Black;\n\n  currentPalette = CRGBPalette16(\n    green, green, black, black,\n    purple, purple, black, black,\n    green, green, black, black,\n    purple, purple, black, black);\n}\n\n\n// This example shows how to set up a static color palette\n// which is stored in PROGMEM (flash), which is almost always more\n// plentiful than RAM.  A static PROGMEM palette like this\n// takes up 64 bytes of flash.\nconst TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM = {\n  CRGB::Red,\n  CRGB::Gray,  // 'white' is too bright compared to red and blue\n  CRGB::Blue,\n  CRGB::Black,\n\n  CRGB::Red,\n  CRGB::Gray,\n  CRGB::Blue,\n  CRGB::Black,\n\n  CRGB::Red,\n  CRGB::Red,\n  CRGB::Gray,\n  CRGB::Gray,\n  CRGB::Blue,\n  CRGB::Blue,\n  CRGB::Black,\n  CRGB::Black\n};\n\n\n\n// Additional notes on FastLED compact palettes:\n//\n// Normally, in computer graphics, the palette (or \"color lookup table\")\n// has 256 entries, each containing a specific 24-bit RGB color.  You can then\n// index into the color palette using a simple 8-bit (one byte) value.\n// A 256-entry color palette takes up 768 bytes of RAM, which on Arduino\n// is quite possibly \"too many\" bytes.\n//\n// FastLED does offer traditional 256-element palettes, for setups that\n// can afford the 768-byte cost in RAM.\n//\n// However, FastLED also offers a compact alternative.  FastLED offers\n// palettes that store 16 distinct entries, but can be accessed AS IF\n// they actually have 256 entries; this is accomplished by interpolating\n// between the 16 explicit entries to create fifteen intermediate palette\n// entries between each pair.\n//\n// So for example, if you set the first two explicit entries of a compact\n// palette to Green (0,255,0) and Blue (0,0,255), and then retrieved\n// the first sixteen entries from the virtual palette (of 256), you'd get\n// Green, followed by a smooth gradient from green-to-blue, and then Blue.\n</code></pre> <p>  Download the Example Sketch </p> <p>For more information, please refer to the WS2812 datasheet and FastLED Arduino library.</p>"},{"location":"example-digital/#digital-input","title":"Digital Input","text":"<p>Buttons are great for learning about digital inputs; and are often paired with LEDs, as a visual indicator for their operation.</p>"},{"location":"example-digital/#button-usrbtn","title":"Button - USRBTN","text":"<p>On the RA6M5 Thing Plus, the USRBTN button is the perfect component for operating a digital input. There are several built-in examples in the Arduino IDE for the basic use of a button as an input device. These examples utilize a digital intput to toggle an LED and/or generate an output text on the USB serial port. Users can find these sketches in the File &gt; Examples &gt; 01.Basics &gt; DigitalReadSerial  and File &gt; Examples &gt; 02.Digital drop-down menus.</p> <ul> <li><code>DigitalReadSerial.ino</code></li> <li><code>Button.ino</code></li> <li><code>Debounce.ino</code></li> <li><code>InputPullupSerial.ino</code></li> </ul> <p>Tip</p> <p>Users will need to modify the sketches below, for the GPIO pin that is connected to the <code>STAT</code> LED and USRBTN. As previously, they can use the predefined <code>LED_BUILTIN</code> variable for the GPIO pin that is connected to the <code>STAT</code> LED. For the GPIO pin that is connected to the USRBTN, users till need to modify the pin to <code>D31</code>.</p> <p>For more details, expand the boxes below to see the modifications that required to replace the highlighted values, in order to define the GPIO pins connected to the <code>STAT</code> LEDand USRBTN</p> USRBTN <p><code>DigitalReadSerial.ino</code></p> <pre><code>int pushButton = 2;\nint pushButton = 31;\n</code></pre> <p><code>Button.ino</code> and <code>Debounce.ino</code></p> <pre><code>const int buttonPin = 2;  // the number of the pushbutton pin\nconst int buttonPin = 31;  // the number of the pushbutton pin\n</code></pre> <p><code>InputPullupSerial.ino</code></p> <pre><code>pinMode(2, INPUT_PULLUP);\npinMode(31, INPUT_PULLUP);\n\nint sensorVal = digitalRead(2);\nint sensorVal = digitalRead(31);\n</code></pre> <code>STAT</code> LED <p><code>Button.ino</code> and <code>Debounce.ino</code></p> <pre><code>const int ledPin = 13;    // the number of the LED pin\nconst int ledPin = LED_BUILTIN;    // the number of the LED pin\n</code></pre> <p><code>InputPullupSerial.ino</code></p> <pre><code>pinMode(13, OUTPUT);\ndigitalWrite(13, value);\n\npinMode(LED_BUILTIN, OUTPUT);\ndigitalWrite(LED_BUILTIN, value);\n</code></pre> <code>DigitalReadSerial.ino</code><code>Button.ino</code><code>Debounce.ino</code><code>InputPullupSerial.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; 01.Basics &gt; DigitalReadSerial drop-down menu.</p> <code>DigitalReadSerial.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 02.Digital &gt; Button drop-down menu.</p> <code>Button.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 02.Digital &gt; Debounce drop-down menu.</p> <code>Debounce.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 02.Digital &gt; InputPullupSerial drop-down menu.</p> <code>InputPullupSerial.ino</code> <p></p>"},{"location":"example-digital/#interrupts","title":"Interrupts","text":"<p>The RA6M5 provides IRQ support on several of its digital input pins. This feature is great for creating an instantaneous response to a digital input, without having to wait for the MCU to complete its current task.</p> <p>Code</p> <pre><code>const byte ledPin = LED_BUILTIN;\nconst byte interruptPin = 31;\nvolatile byte state = LOW;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n  pinMode(interruptPin, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt(interruptPin), blink, CHANGE);\n}\n\nvoid loop() {\n  digitalWrite(ledPin, state);\n}\n\nvoid blink() {\n  state = !state;\n}\n</code></pre> <p>Arduino</p> <p>In the Arduino IDE, interrupt requests are configured using the <code>attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)</code> function, where:</p> <ul> <li><code>pin</code> - The GPIO pin</li> <li><code>ISR</code> -   The interrupt service routine to call/execute when the interrupt occurs</li> <li><code>mode</code> - Defines how the interrupt should be triggered:<ul> <li><code>LOW</code> - When the pin is LOW</li> <li><code>CHANGE</code> - Whenever the pin changes value</li> <li><code>RISING</code> - When the pin changes from LOW to HIGH</li> <li><code>FALLING</code>- When the pin changes from HIGH to LOW</li> </ul> </li> </ul> <p>Warning</p> <p>When utilizing an interrupt on a digital GPIO, the attached interrupt service routine should be able to execute within the shortest, possible time frame. Otherwise, the suspended task could trigger various faults or errors.</p>"},{"location":"example-serial/","title":"Serial","text":""},{"location":"example-serial/#feedback-loop","title":"Feedback Loop","text":"<p>The simplest way to test the UART interface is with just a jumper (wire) and looping transmission data from the TX GPIO pin; back into the RX GPIO pin. For this example, users are free to utilize any method or hardware they have to connect the RX and TX GPIO pins together. However, we recommend some IC hooks for a temporary connection.</p> Optional Hardware <ul> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <li> <p> <p>IC Hook with Pigtail CAB-09741</p> <li> <p> <p>Jumper Wires Premium 6\" Mixed Pack of 100 PRT-09194</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Jumper - 2 Pin PRT-09044</p> <p>After users have jumpered the GPIO pins and uploaded the example code, they will need to open the Serial Monitor in the Arduino IDE. Any entries that are sent through the message textbox, should be re-transmitted back into the Serial Monitor by the jumpered GPIO pins.</p> <code>MultiSerial.ino</code><code>SerialPassthrough.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; 04.Communication &gt; MultiSerial drop-down menu.</p> <code>MultiSerial.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 04.Communication &gt; SerialPassthrough drop-down menu.</p> <code>SerialPassthrough.ino</code> <p></p>"},{"location":"example-serial/#peripheral-device","title":"Peripheral Device","text":""},{"location":"example-serial/#gnssgps-module","title":"GNSS/GPS Module","text":"<p>For GNSS receivers, we recommend that the TinyGPSPlus Arduino library be utilized to parse the NMEA sentences from the module. Once the library is installed in the Arduino IDE, users will find several example sketches listed in the File &gt; Examples &gt; TinyGPSPlus &gt; drop-down menu. We recommend the following examples for getting started with a GNSS receiver:</p> <ul> <li><code>DeviceExample.ino</code></li> <li><code>FullExample.ino</code></li> </ul> <p>Tip</p> <p>Below, are a few tips for users to start working with the TinyGPSPlus Arduino library. However, for more details, users should refer to the documentation for the TinyGPSPlus Arduino library.</p> Define Parameters <p>When utilizing the examples in the TinyGPSPlus Arduino library, users may need to define and/or modify a few parameters. The baud rate for the GNSS receiver should be configured based upon the information presented in the datasheet.</p> <p>For the RA6M5 Thing Plus, users have two options for configuring the serial port on the <code>RX</code> and <code>TX</code> GPIO pins:</p> <ul> <li>In the examples, they can continue to implement the SoftwareSerial library and update the values of <code>RX</code> and <code>TX</code> GPIO pins in the code</li> <li>Otherwise, users can remove the SoftwareSerial library implementation; and replace it with <code>Serial1</code> UART port</li> </ul> <ul> <li> <p>Baud Rate</p> <p>Check the datasheet or product manual for the default baud rate of the GPS receiver; if necessary, replace the value in the example:</p> <pre><code>static const uint32_t GPSBaud = 4800;\nstatic const uint32_t GPSBaud = 115200;\n</code></pre> <p>In some cases, the datasheet may be inaccurate or the module's configuration was previously changed. In which case, the most common rates to try are:</p> <ul> <li><code>4800</code> bps</li> <li><code>9600</code> bps</li> <li><code>115200</code> bps</li> </ul> </li> <li> <p>Update GPIO Pins</p> <p>Replace the values for the <code>RX</code> (<code>D20</code>) and <code>TX</code> (<code>D21</code>) GPIO pins for those on the RA6M5 Thing Plus:</p> <pre><code>static const int RXPin = 4, TXPin = 3;\nstatic const int RXPin = 20, TXPin = 21;\n</code></pre> </li> <li> <p>Utilize <code>Serial1</code> Port</p> <p>Remove the implementation of the SoftwareSerial library implementation</p> <pre><code>#include &lt;SoftwareSerial.h&gt;\n\nstatic const int RXPin = 4, TXPin = 3;\nSoftwareSerial ss(RXPin, TXPin);\n</code></pre> <p>Then, replace the SoftwareSerial objects with <code>Serial1</code> class</p> <pre><code>void setup()\n{\n    Serial.begin(115200);\n    ssSerial1.begin(GPSBaud);\n\nvoid loop()\n{\n    while (ssSerial1.available() &gt; 0)\n        if (gps.encode(ssSerial1.read()))\n            displayInfo();\n</code></pre> </li> </ul> Hardware Assembly <p>Connecting a GNSS receiver to a microcontroller is relatively straight forward. Users must provide power to the module through the <code>PWR</code>/<code>VCC</code> and <code>GND</code> pins on the board. Additionally, the <code>TX</code> pin from the GNSS receiver, should be connected to the <code>RX</code> pin of the microcontroller. This will allow the module to transmit the NMEA sentences to the microcontroller.</p> <p> Thing Plus GPS Module <code>3V3</code> <code>VCC</code> or <code>PWR</code> <code>GND</code> <code>GND</code> <code>RX</code> (<code>D21</code>) <code>TX</code> <code>TX</code> (<code>D20</code>) --- <p></p> Satellite Fix <p>As with all GNSS receivers, the module's antenna must have a clear view of the sky (it can't operate inside a building) to receive signal from the GNSS constellation. In addition, the GNSS receiver must acquire a fix on its position, before it starts transmitting complete NMEA sentences (with all the data).</p> Optional Hardware <ul> <li> <p> <p>SparkFun GPS Breakout - XA1110 (Qwiic) GPS-14414</p> <li> <p> <p>GPS Module - GP1818MK (56 Channel) GPS-19166</p> <li> <p> <p>IC Hook with Pigtail CAB-09741</p> <li> <p> <p>Hook-Up Wire - Assortment (Stranded, 22 AWG) PRT-11375</p> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>PINECIL Soldering Iron Kit KIT-24063</p> <p>After users have connected their GNSSS module and uploaded the example code, they will need to open the Serial Monitor in the Arduino IDE to view the data. Users should begin to see the data parsed by the TinyGPSPlus Arduino library, from the NMEA sentences transmitted from the GNSS receiver.</p> <code>DeviceExample.ino</code><code>FullExample.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; TinyGPSPlus &gt; DeviceExample drop-down menu.</p> <code>DeviceExample.ino</code> <pre><code>#include &lt;TinyGPSPlus.h&gt;\n#include &lt;SoftwareSerial.h&gt;\n/*\n   This sample sketch demonstrates the normal use of a TinyGPSPlus (TinyGPSPlus) object.\n   It requires the use of SoftwareSerial, and assumes that you have a\n   4800-baud serial GPS device hooked up on pins 4(rx) and 3(tx).\n*/\nstatic const int RXPin = 4, TXPin = 3;\nstatic const uint32_t GPSBaud = 4800;\n\n// The TinyGPSPlus object\nTinyGPSPlus gps;\n\n// The serial connection to the GPS device\nSoftwareSerial ss(RXPin, TXPin);\n\nvoid setup()\n{\n  Serial.begin(115200);\n  ss.begin(GPSBaud);\n\n  Serial.println(F(\"DeviceExample.ino\"));\n  Serial.println(F(\"A simple demonstration of TinyGPSPlus with an attached GPS module\"));\n  Serial.print(F(\"Testing TinyGPSPlus library v. \")); Serial.println(TinyGPSPlus::libraryVersion());\n  Serial.println(F(\"by Mikal Hart\"));\n  Serial.println();\n}\n\nvoid loop()\n{\n  // This sketch displays information every time a new sentence is correctly encoded.\n  while (ss.available() &gt; 0)\n    if (gps.encode(ss.read()))\n      displayInfo();\n\n  if (millis() &gt; 5000 &amp;&amp; gps.charsProcessed() &lt; 10)\n  {\n    Serial.println(F(\"No GPS detected: check wiring.\"));\n    while(true);\n  }\n}\n\nvoid displayInfo()\n{\n  Serial.print(F(\"Location: \")); \n  if (gps.location.isValid())\n  {\n    Serial.print(gps.location.lat(), 6);\n    Serial.print(F(\",\"));\n    Serial.print(gps.location.lng(), 6);\n  }\n  else\n  {\n    Serial.print(F(\"INVALID\"));\n  }\n\n  Serial.print(F(\"  Date/Time: \"));\n  if (gps.date.isValid())\n  {\n    Serial.print(gps.date.month());\n    Serial.print(F(\"/\"));\n    Serial.print(gps.date.day());\n    Serial.print(F(\"/\"));\n    Serial.print(gps.date.year());\n  }\n  else\n  {\n    Serial.print(F(\"INVALID\"));\n  }\n\n  Serial.print(F(\" \"));\n  if (gps.time.isValid())\n  {\n    if (gps.time.hour() &lt; 10) Serial.print(F(\"0\"));\n    Serial.print(gps.time.hour());\n    Serial.print(F(\":\"));\n    if (gps.time.minute() &lt; 10) Serial.print(F(\"0\"));\n    Serial.print(gps.time.minute());\n    Serial.print(F(\":\"));\n    if (gps.time.second() &lt; 10) Serial.print(F(\"0\"));\n    Serial.print(gps.time.second());\n    Serial.print(F(\".\"));\n    if (gps.time.centisecond() &lt; 10) Serial.print(F(\"0\"));\n    Serial.print(gps.time.centisecond());\n  }\n  else\n  {\n    Serial.print(F(\"INVALID\"));\n  }\n\n  Serial.println();\n}\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; TinyGPSPlus* &gt; FullExample drop-down menu.</p> <code>FullExample.ino</code> <pre><code>#include &lt;TinyGPSPlus.h&gt;\n#include &lt;SoftwareSerial.h&gt;\n/*\n   This sample code demonstrates the normal use of a TinyGPSPlus (TinyGPSPlus) object.\n   It requires the use of SoftwareSerial, and assumes that you have a\n   4800-baud serial GPS device hooked up on pins 4(rx) and 3(tx).\n*/\nstatic const int RXPin = 4, TXPin = 3;\nstatic const uint32_t GPSBaud = 4800;\n\n// The TinyGPSPlus object\nTinyGPSPlus gps;\n\n// The serial connection to the GPS device\nSoftwareSerial ss(RXPin, TXPin);\n\nvoid setup()\n{\n  Serial.begin(115200);\n  ss.begin(GPSBaud);\n\n  Serial.println(F(\"FullExample.ino\"));\n  Serial.println(F(\"An extensive example of many interesting TinyGPSPlus features\"));\n  Serial.print(F(\"Testing TinyGPSPlus library v. \")); Serial.println(TinyGPSPlus::libraryVersion());\n  Serial.println(F(\"by Mikal Hart\"));\n  Serial.println();\n  Serial.println(F(\"Sats HDOP  Latitude   Longitude   Fix  Date       Time     Date Alt    Course Speed Card  Distance Course Card  Chars Sentences Checksum\"));\n  Serial.println(F(\"           (deg)      (deg)       Age                      Age  (m)    --- from GPS ----  ---- to London  ----  RX    RX        Fail\"));\n  Serial.println(F(\"----------------------------------------------------------------------------------------------------------------------------------------\"));\n}\n\nvoid loop()\n{\n  static const double LONDON_LAT = 51.508131, LONDON_LON = -0.128002;\n\n  printInt(gps.satellites.value(), gps.satellites.isValid(), 5);\n  printFloat(gps.hdop.hdop(), gps.hdop.isValid(), 6, 1);\n  printFloat(gps.location.lat(), gps.location.isValid(), 11, 6);\n  printFloat(gps.location.lng(), gps.location.isValid(), 12, 6);\n  printInt(gps.location.age(), gps.location.isValid(), 5);\n  printDateTime(gps.date, gps.time);\n  printFloat(gps.altitude.meters(), gps.altitude.isValid(), 7, 2);\n  printFloat(gps.course.deg(), gps.course.isValid(), 7, 2);\n  printFloat(gps.speed.kmph(), gps.speed.isValid(), 6, 2);\n  printStr(gps.course.isValid() ? TinyGPSPlus::cardinal(gps.course.deg()) : \"*** \", 6);\n\n  unsigned long distanceKmToLondon =\n    (unsigned long)TinyGPSPlus::distanceBetween(\n      gps.location.lat(),\n      gps.location.lng(),\n      LONDON_LAT, \n      LONDON_LON) / 1000;\n  printInt(distanceKmToLondon, gps.location.isValid(), 9);\n\n  double courseToLondon =\n    TinyGPSPlus::courseTo(\n      gps.location.lat(),\n      gps.location.lng(),\n      LONDON_LAT, \n      LONDON_LON);\n\n  printFloat(courseToLondon, gps.location.isValid(), 7, 2);\n\n  const char *cardinalToLondon = TinyGPSPlus::cardinal(courseToLondon);\n\n  printStr(gps.location.isValid() ? cardinalToLondon : \"*** \", 6);\n\n  printInt(gps.charsProcessed(), true, 6);\n  printInt(gps.sentencesWithFix(), true, 10);\n  printInt(gps.failedChecksum(), true, 9);\n  Serial.println();\n\n  smartDelay(1000);\n\n  if (millis() &gt; 5000 &amp;&amp; gps.charsProcessed() &lt; 10)\n    Serial.println(F(\"No GPS data received: check wiring\"));\n}\n\n// This custom version of delay() ensures that the gps object\n// is being \"fed\".\nstatic void smartDelay(unsigned long ms)\n{\n  unsigned long start = millis();\n  do \n  {\n    while (ss.available())\n      gps.encode(ss.read());\n  } while (millis() - start &lt; ms);\n}\n\nstatic void printFloat(float val, bool valid, int len, int prec)\n{\n  if (!valid)\n  {\n    while (len-- &gt; 1)\n      Serial.print('*');\n    Serial.print(' ');\n  }\n  else\n  {\n    Serial.print(val, prec);\n    int vi = abs((int)val);\n    int flen = prec + (val &lt; 0.0 ? 2 : 1); // . and -\n    flen += vi &gt;= 1000 ? 4 : vi &gt;= 100 ? 3 : vi &gt;= 10 ? 2 : 1;\n    for (int i=flen; i&lt;len; ++i)\n      Serial.print(' ');\n  }\n  smartDelay(0);\n}\n\nstatic void printInt(unsigned long val, bool valid, int len)\n{\n  char sz[32] = \"*****************\";\n  if (valid)\n    sprintf(sz, \"%ld\", val);\n  sz[len] = 0;\n  for (int i=strlen(sz); i&lt;len; ++i)\n    sz[i] = ' ';\n  if (len &gt; 0) \n    sz[len-1] = ' ';\n  Serial.print(sz);\n  smartDelay(0);\n}\n\nstatic void printDateTime(TinyGPSDate &amp;d, TinyGPSTime &amp;t)\n{\n  if (!d.isValid())\n  {\n    Serial.print(F(\"********** \"));\n  }\n  else\n  {\n    char sz[32];\n    sprintf(sz, \"%02d/%02d/%02d \", d.month(), d.day(), d.year());\n    Serial.print(sz);\n  }\n\n  if (!t.isValid())\n  {\n    Serial.print(F(\"******** \"));\n  }\n  else\n  {\n    char sz[32];\n    sprintf(sz, \"%02d:%02d:%02d \", t.hour(), t.minute(), t.second());\n    Serial.print(sz);\n  }\n\n  printInt(d.age(), d.isValid(), 5);\n  smartDelay(0);\n}\n\nstatic void printStr(const char *str, int len)\n{\n  int slen = strlen(str);\n  for (int i=0; i&lt;len; ++i)\n    Serial.print(i&lt;slen ? str[i] : ' ');\n  smartDelay(0);\n}\n</code></pre>"},{"location":"example-serial/#da14531mod","title":"DA14531MOD","text":"<p>For the DA14531MOD, users can interface with the module through the <code>Serial2</code> UART port of the RA6M5 Thing Plus. The firmware on the module implements the CodeLess AT command platform. This means, users can easily configure the BLE connectivity of the board with a few AT commands. For more details, please refer to the section with the DA14531MOD examples.</p>"},{"location":"hardware_assembly/","title":"Hardware Assembly","text":""},{"location":"hardware_assembly/#usb-connector","title":"USB Connector","text":"<p>The USB connection is utilized for programming and serial communication. Users only need to plug their RA6M5 Thing Plus into a computer using a USB-C cable.</p> <p></p> <p>The RA6M5 Thing Plus with USB-C cable attached.</p>"},{"location":"hardware_assembly/#lipo-battery","title":"LiPo Battery","text":"<p>For remote IoT applications, a LiPo battery can be connected. Additionally, users may be interested in utilizing a solar panel and USB-C cable to recharge their battery.</p> <p></p> <p>The RA6M5 Thing Plus with a battery connected.</p> <ul> <li> <p> <p>Solar Panel Charger - 10W TOL-16835</p> <li> <p> <p>USB 3.1 Cable A to C - 3 Foot TOL-14743</p> <p>Warning</p> <p>Users should avoid pulling on the wires of a battery to disconnect it from the board. Instead, it is recommended that a pair of dikes (i.e. diagonal wire cutters), pliers, or tweezers be used to pull on the JST connector housing, to avoid damaging the battery wiring.</p> <p> Using a pair of dikes to disconnect a battery. </p>"},{"location":"hardware_assembly/#breakout-pins","title":"Breakout Pins","text":"<p>The PTH pins on the RA6M5 Thing Plus are broken out into 0.1\"-spaced pins on the edges of the board.</p> New to soldering? <p>If you have never soldered before or need a quick refresher, check out our How to Solder: Through-Hole Soldering guide.</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p>"},{"location":"hardware_assembly/#headers","title":"Headers","text":"<p>Headers are versatile in their compatibility with shields, breadboards, or jumper wires.</p> <p></p> <p>Soldering headers to the RA6M5 Thing Plus.</p> Stackable Headers <p>Our Feather Stackable Header Kit is a great option for stacking on shields (w/ Feather footprint) or on a breadboard; while leaving its pins still accessible.</p> <p> Stackable headers on the RA6M5 Thing Plus. </p>"},{"location":"hardware_assembly/#hookup-wires","title":"Hookup Wires","text":"<p>For a more permanent connection, users can solder wires directly to the board.</p> <p></p> <p>Soldering wires to the RA6M5 Thing Plus.</p>"},{"location":"hardware_assembly/#sd-card-slot","title":"SD Card Slot","text":"<p>The RA6M5 Thing Plus includes a \u00b5SD card slot on the back of the board. The cardholder functions through a push/pull operation. (The card slot doesn't include a spring retention mechanism; cards are held in place through friction.)</p> <p></p> <p>Users can slide-in or pull-out a \u00b5SD card from the cardholder.</p> <p>SD Card Compatibility</p> <p>The R6M5 Thing Plus supports \u00b5SD cards with a FAT32 file system (i.e. only cards up to 32GB in size).</p>"},{"location":"hardware_assembly/#qwiic-devices","title":"Qwiic Devices","text":"<p>The Qwiic system allows users to effortlessly prototype with a Qwiic compatible I<sup>2</sup>C device without soldering. Users can attach any Qwiic compatible sensor or board, with just a Qwiic cable. (*The example below, is for demonstration purposes and is not pertinent to the board functionality or this tutorial.)</p> <p></p> <p>The BME688 environmental and VL53L1X distance Qwiic sensor boards connected to the RA6M5 Thing Plus.</p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":""},{"location":"hardware_overview/#dimensions","title":"Dimensions","text":"<p>The circuit board dimensions are illustrated in the drawing below; the measurements are in inches.</p> <p></p> <p>Dimensions (PDF) of the RA6M5 Thing Plus, in inches.</p> Need more measurements? <p>For more information about the board's dimensions, users can download the Eagle files for the board. These files can be opened in Eagle and additional measurements can be made with the dimensions tool.</p>  Eagle - Free Download! <p>Eagle is a CAD program for electronics that is free to use for hobbyists and students. However, it does require an account registration to utilize the software.</p> <p> Download fromAutodesk primary logo </p>  Dimensions Tool <p>This video from Autodesk demonstrates how to utilize the dimensions tool in Eagle, to include additional measurements:</p> <p> <p> <p> </p> <p></p>"},{"location":"hardware_overview/#usb-connector","title":"USB Connector","text":"<p>The USB-C connector is used to provide power and program the board. For most users, it will also be the primary programming interface for the RA6M5 Thing Plus.</p> <p></p> <p>USB-C connector on the RA6M5 Thing Plus.</p>"},{"location":"hardware_overview/#power","title":"Power","text":"<p>The RA6M5 Thing Plus only requires 3.3V to power the board. However, the simplest method to power the board is through the USB-C connector. Alternatively, the <code>3V3</code>, <code>VBAT</code>, and <code>VUSB</code> pins can also be used to supply power to the board.</p> <p></p> <p>Power connections on the RA6M5 Thing Plus PCB.</p> <p> <pre><code>\nflowchart LR\n    A[USB-C] === B((\"`**VUSB**`\")) ===&gt; |VUSB &gt; VBAT| Switch;\n\n    subgraph Battery Charger\n        direction LR\n        C[MCP73831] -.-&gt; D[LiPo Battery];\n    end\n\n    subgraph Switch\n        F[LM66200];\n    end\n\n    B ==&gt; C;\n    D === E((\"`**VBAT**`\")) == VBAT &gt; VUSB ==&gt; Switch;\n\n    F ===   H[RT9080] ==&gt; I((\"`**3V3**`\"));\n    F === G[RT9080] ==&gt; J((\"`**VREF**`\"));\n\n    click B \"#vusb\"\n    click C \"#charging-circuit\"\n    click E \"#vbat\"\n    click F \"#power-control\"\n    click J \"#vref\"\n    click I \"#3v3\"</code></pre> <p></p> <p>Below, is a summary of the power circuitry for this board:</p> <code>3V3</code> <code>VUSB</code> <code>VBAT</code> <code>VREF</code> <code>GND</code> Qwiic Connector <ul> <li>Primary power for the RA6M5 Thing Plus<ul> <li>Powers the RA6M5 module, DA14531MOD, QSPI flash, \u00b5SD card slot, Qwiic connector, WS2812 RGB LED, and power LED</li> </ul> </li> <li>A regulated 3.3V is provided by an RT9080 LDO from <code>VUSB</code> or <code>VBAT</code><ul> <li>The output voltage from the RT9080 is controlled by the <code>EN</code> pin on the board</li> <li>The RT9080 can source up to 600mA of current, which is only limited by the power source from the LM66200 switch<ul> <li>The power source from the LM66200 is automatically switched between <code>VUSB</code> or <code>VBAT</code>, based on which has the greater voltage</li> </ul> </li> </ul> </li> <li>As an input, it requires a regulated 3.3V to avoid contention with the LDO regulator</li> </ul> <p>The input voltage range for the RT9080 is 1.2-5.5V</p> <ul> <li>Usually powered through the USB-C connector (5V)</li> <li>Input voltage range: 3.75 - 5V<ul> <li>The maximum voltage is limited by the ideal diode switch at 5.5V (1.6-5.5V)</li> <li>The minimum voltage is limited by the charge controller at 3.75V (3.75-6V)</li> </ul> </li> <li>Primary power source for the RT9080 LDOs when <code>VUSB</code> &gt; <code>VBAT</code>; via the LM66200 ideal diode switch</li> <li>Powers the MCP73831 linear charge management controller<ul> <li>Provides a 213mA (max) rate of charge to a connected battery</li> </ul> </li> </ul> <ul> <li>The voltage from the JST battery connector; is meant for single-cell LiPo batteries<ul> <li>A connected battery will be charged by the MCP73831 charge controller, when sufficient power is provided from <code>VUSB</code></li> </ul> </li> <li>Primary power source for the  RT9080 LDOs when <code>VBAT</code> &gt; <code>VUSB</code>; via the LM66200 ideal diode switch</li> <li>A battery's charge can be monitored through the MAX17048 fuel gauge</li> </ul> <ul> <li>The analog reference voltage for the RA6M5 module's ADC and DAC channels<ul> <li>Provided by a RT9080 LDO regulator, separate from one providing the <code>3V3</code> power supply</li> </ul> </li> </ul> <p>The input voltage range for the RT9080 is 1.2-5.5V</p> <ul> <li>The common ground or the 0V reference for the voltage supplies</li> </ul> <ul> <li>The 4-pin JST connector provides a regulated 3.3V voltage to peripheral Qwiic devices from <code>3V3</code></li> </ul> Detailed Diagram <p> <pre><code>\nflowchart LR\n    D === E((\"`**VBAT**`\")) == VBAT &gt; VUSB ==&gt; Switch;\n    A[USB-C] === B((\"`**VUSB**`\")) == VUSB &gt; VBAT ==&gt; Switch;\n    C --- T[CHG LED];\n\nsubgraph Battery Charger\n        C[MCP73831] -.-&gt; D[LiPo&lt;br&gt;3.5-4.2V]\n    end\n\n    subgraph Switch\n        S[LM66200];\n        S === I[RT9080] &amp; H[RT9080];\n    end\n\n    subgraph Powered_Components\n        L[PWR LED];\n        M[RA6M5] --- N[DA14531MOD];\n        M --- O[QSPI Flash];\n        M --- P[SD Card];\n        M --- Q[WS2812 LED];\n        M --- I2C;\n        subgraph I2C\n            R[Qwiic Connector];\n            F[MAX17048];\n        end\n    end\n\n    B ==&gt; C;\n    B ====&gt; T;\n    I --- U((\"`**EN**`\"));\n    I ==&gt; K((\"`**3V3**`\")) === Powered_Components;\n    H ==&gt; J((\"`**VREF**`\")) --&gt; M;\n    H --- W((\"`**D37**`\")) --- M;\n    D ------ F;\n    Switch --- V((\"`**D38**`\")) --- M;</code></pre> <p></p> <p>For more details, users can reference the schematic and the datasheets of the individual components in the power circuitry.</p>"},{"location":"hardware_overview/#power-status-led","title":"Power Status\u00a0 LED","text":"<p>The red, <code>PWR</code> LED will light up once 3.3V is supplied to the board; however, for most users, it will light up when 5V is supplied through the USB connection or when a LiPo battery is connected to the JST connector.</p> <p></p> <p>The <code>PWR</code> status LED indicator on the RA6M5 Thing Plus.</p>"},{"location":"hardware_overview/#charging-circuit","title":"Charging Circuit","text":"<p>The charging circuit utilizes the MCP73831 linear charge management controller from Microchip Technologies, which is powered by the USB-C connector or <code>VUSB</code>. The controller provides a 213mA charge rate for a LiPo battery connected to the JST connector. Active charging is indicated by the yellow, <code>CHG</code> LED. If the charge controller is shut down or charging is complete, the <code>CHG</code> LED will turn off. The board also includes a MAX17048 fuel gauge from Analog Devices to monitor the charge left on the battery.</p> <p> <pre><code>\nflowchart LR\n    A[USB-C] === B((\"`**VUSB**`\")) ==&gt; C &amp; G;\n    D ===&gt; E((\"`**VBAT**`\"));\n    D --- F[MAX17048] === H((\"`**3V3**`\"));\n    G[CHG LED] --- C[MCP73831];\n\n    subgraph Battery Charger\n        C -.-&gt; |213mA| D[LiPo&lt;br&gt;3.5-4.2V];\n    end</code></pre> <p></p> <p></p> <p>The <code>CHG</code> status LED and JST connector for the battery on the RA6M5 Thing Plus.</p> <p>For more details, please refer to the MCP73831 and MAX17048 datasheets, schematic, and the Status LEDs and Battery Fuel Gauge sections below.</p>"},{"location":"hardware_overview/#power-control","title":"Power Control","text":"<p>The primary power source for the RT9080 LDO regulators is automatically switched between <code>VUSB</code> and <code>VBAT</code> by the LM66200 ideal diode switch; based on their voltage levels. This will be indicated by the <code>ST</code> pin of the LM66200, which is connected to the <code>P001</code> GPIO (<code>D38</code>) of the RA6M5. A <code>LOW</code> state will indicate that power is being supplied from <code>VUSB</code> (or the USB-C connector); while a <code>HIGH</code> state will indicate power is being drawn from <code>VBAT</code> (or the battery JST connector).</p> <p> <pre><code>\nflowchart LR\n    A[USB-C] === B((\"`**VUSB**`\")) == VUSB &gt; VBAT ==&gt; Switch;\n    U((\"`**D38**`\")) --- Switch;\n    D[LiPo] === E((\"`**VBAT**`\")) == VBAT &gt; VUSB ==&gt; Switch;\n\n    subgraph Switch\n        S[LM66200];\n    end\n\n    S === H[RT9080] ===&gt; J((\"`**3V3**`\"));\n    H --- T((\"`**EN**`\"));\n    I --- V((\"`**D37**`\"));\n    S === I[RT9080] ===&gt; K((\"`**VREF**`\"));</code></pre> <p></p> <p>The 3.3V regulated output from the primary RT9080 is enabled by default and controlled by the <code>EN</code> pin on the board. Meanwhile, the voltage output from the RT9080 for the analog reference voltage (<code>VREF</code>) of the RA6M5 is controlled by its <code>P500</code> GPIO (<code>D37</code>). Users can disable the 3.3V power output of either of the RT9080 LDO regulators, by setting the associated control pin LOW.</p> <p></p> <p>The power inputs/outputs and <code>EN</code> pin on the RA6M5 Thing Plus.</p> <p>For more details, please refer to the LM66200 datasheet, RT9080 datasheet, and schematic.</p>"},{"location":"hardware_overview/#ra6m5-microcontroller","title":"RA6M5 Microcontroller","text":"<p>The brains of the board is the RA6M5 microcontroller from Renesas, a low-power Arm<sup>\u00ae</sup> Cortex<sup>\u00ae</sup>-M33 processor with a clock speed up to 200Mhz, 512kB of SRAM, and 2MB of flash memory. This high-performance microcontroller features an extensive list of peripheral capabilities and is perfect for real-time applications.</p> <p></p> <p>The RA6M5 microcontroller on the RA6M5 Thing Plus.</p> <ul> <li>Arm<sup>\u00ae</sup> Cortex<sup>\u00ae</sup>-M33 Core<ul> <li>Clock Frequency: 200MHz</li> <li>Flash Memory: 2MB (code); 8kB (data)</li> <li>SRAM: 512kB w/ ECC Support</li> <li>Arm Memory Protection Unit (Arm MPU)</li> <li>Secure Crypto Engine</li> <li>Two Watchdog Timers (WDT)</li> </ul> </li> <li>Operating Voltage: 3.0V to 3.6V<ul> <li>Current Consumption:<ul> <li>Maximum: 143mA</li> <li>Normal: 32mA</li> <li>Sleep: 11mA</li> <li>Deep Sleep: 0.9-131\u00b5A</li> </ul> </li> </ul> </li> <li>Operating modes:<ul> <li>Single-chip or SCI/USB boot</li> </ul> </li> <li>Operating Temperature: -40 to 85 \u00b0C</li> <li>75 GPIO Pins</li> <li>RTC with Calendar</li> <li>CRC Calculator</li> <li>Internal Temperature Sensor</li> </ul> <p>Peripherals</p> <ul> <li>12-bit ADC (x6)</li> <li>12-bit DAC (x2)</li> <li>32-bit PWM Channels (x4)</li> <li>16-bit PWM Channels (x6)</li> <li>UART (x10)</li> <li>I<sup>2</sup>C Bus (x3)</li> <li>SPI Bus (x2)</li> <li>QSPI (x1)</li> <li>SD/MMC Host Interface</li> </ul> <ul> <li>OSPI (x1)</li> <li>CAN Interface</li> <li>USB 2.0 (Full/High Speed)</li> <li>Ethernet MAC/DMA Controller</li> <li>Serial Sound Interface Enhanced</li> <li>Consumer Electronics Control</li> <li>Capacitive Touch Sensing</li> </ul> <p>Note</p> <p>Users should be aware that not all of the features, listed above, will be available in the Arduino IDE.</p> DFU Mode <p>If users are having issues uploading code to the board, the RA6M5 can be manually forced into DFU mode. This issue, often occurs when the USB connection is busy and a reset can't be triggered on the RA6M5, to initialize the upload process. To force the RA6M5 Thing Plus into DFU mode:</p> <ol> <li>Double-tap the RST button<ul> <li>The <code>STAT</code> LED should be fading in/out very slowly</li> </ul> </li> <li>Users should now, be able to upload a new program<ul> <li>It shouldn't be necessary to select a COM port in the Arduino IDE; only the board needs to be selected</li> </ul> </li> <li>Once programming is complete, the MCU should reboot on its own. Otherwise:<ul> <li>Press the RST button</li> <li>Power cycle the board</li> </ul> </li> </ol> <p>For more technical specifications for the RA6M5 microcontroller, please refer to the RA6M5 datasheet and RA6M5 user manual.</p>"},{"location":"hardware_overview/#debugging-pins","title":"Debugging Pins","text":"<p>Debug pins are available for the RA6M5, as 0.1\" test points on the board. However, the debugging feature is only available through the Renesas FSP (not covered in this tutorial).</p> SWDJTAG <p> GND SWCLK 3.3V | RST SWO SWDIO </p> <p> GND TCK 3.3V | RST TDO TMS </p> <p>Pin Connections</p> <p>In case users are interested, these are the pin connections of the debugging test points for the RA6M5. For more details, please reference the schematic and Eagle files.</p> <ul> <li><code>TMS</code>/<code>SWDIO</code>: <code>P108</code></li> <li><code>TCK</code>/<code>SWCLK</code>: <code>P300</code></li> <li><code>TDO</code>/<code>SWO</code>: <code>P109</code></li> <li><code>TDI</code>: <code>P110</code> (POCI/<code>D17</code>) (Not a JTAG test point)</li> </ul> <p>Note</p> <p>In order to debug the RA6M5, users will need a debug probe. We recommend the J-Link debug probes from Segger. However, users should verify the supported devices before purchasing these products; for example, we had a few issues with the J-Link EDU Mini.</p> <p></p> <p>The debug pins for the RA6M5 microcontroller.</p> <p>For more details, please refer to the schematic and RA6M5 datasheet.</p>"},{"location":"hardware_overview/#pin-functions","title":"Pin Functions","text":"<p>While there are 75 GPIO pins that are available on the RA6M5, only 44 GPIO pins are utilized with the RA6M5 Thing Plus. Additionally, of those 44 GPIO, only 21 GPIO pins are broken out into the PTH breakout pins. The breakout pins are in a Feather form-factor layout with a 0.1\" pitch spacing to make them compatible with standard headers and Feather shields/wings.</p> <p>Some of the RA6M5's peripheral capabilities may be inaccessible to users with the available 44 GPIO. However, any of the available GPIO pins can operate as digital I/O; with several of these pins featuring additional peripheral support. The pins utilized by the RA6M5 Thing Plus, along with their capabilities, are summarized in our graphical datasheet and detailed in the sections below.</p> <p> \u00a0\u00a0Download the Graphical Datasheet </p> <p></p> <p></p> <p>Board Limitations</p> <p>Users should be aware that some of the features of the RA6M5 may not be available in the Arduino IDE. This is due to either the lack of support in the Renesas-Arduino core and/or pins that are unavailable on the RA6M5 Thing Plus. For the full capabilities of the RA6M5, the Renesas FSP should be utilized.</p> <ul> <li>Only one I<sup>2</sup>C bus is defined.</li> <li>Only three UART interfaces are defined.<ul> <li><code>Serial</code> - UART (USB)</li> <li><code>Serial1</code> - <code>RX</code>/<code>TX</code> GPIO Pins</li> <li><code>Serial2</code> - DA14531MOD UART</li> </ul> </li> <li>Only one SPI bus is defined.</li> </ul> <p>Note</p> <ul> <li>All the GPIO on the RA6M5 Thing Plus are  3.3V pins</li> <li>While the datasheet specifies there are fourteen 5V-tolerant I/O pins; most of the exposed pins are not 5V-tolerant! To interface with higher voltage components, a logic-level adapter should be utilized.</li> </ul>  Digital I/O PWM Outputs Analog Inputs Analog OutputsSerial PinsSPI PinsI<sup>2</sup>C PinsInterrupts <p>Any GPIO pin on the RA6M5 Thing Plus can operate as a digital I/O (input or output). To access this functionality in the Arduino IDE, users must first declare the pin operation in their <code>setup()</code> loop, using the <code>pinMode(pin, mode)</code> function.</p> Input <p>If a pin is configured as an <code>INPUT</code>, the microcontroller can monitor if the pin's state is HIGH or LOW. As Input pins are High Impedance, it takes very little current to move the input pin from one state to another.</p> <p>Arduino</p> <p>In the Arduino IDE, this is accessed through the <code>digitalRead(pin)</code> function, which returns a <code>HIGH</code> or <code>LOW</code> value.</p> Output <p>If a pin is configured as an <code>OUTPUT</code>, the microcontroller can provide a HIGH or LOW voltage output from the pin. As Output pins are Low Impedance, they can provide a certain amount of current for other circuits.</p> <p>Arduino</p> <p>In the Arduino IDE, this is accessed through the <code>digitalWrite(pin, value)</code> function and providing a <code>HIGH</code> or <code>LOW</code> value.</p> <p>Warning</p> <p>There are electrical limitations to the amount of current that I/O pins can sink or source. For more details, check out the RA6M5 datasheet.</p> <p>Tip - Creating a PWM Output</p> <p>A digital output pin can only either be fully on HIGH or fully off LOW. By turning a digital pin's output, on and off very quickly with precise timings, the average voltage can be controlled and emulate an analog output. This method is called PWM.</p> <p>Please refer to the PWM Outputs tab for more instructions or check out this great tutorial to learn more about pulse width modulation.</p> <p>The RA6M5 supports up to four 32-bit and six 16-bit PWM (Pulse Width Modulation) channels on most of its GPIO pins. A PWM output will produce a square waveform with a variable duty cycle, a ratio of time a signal is HIGH for a given wave period. In the Arduino IDE, this feature is accessed using the <code>analogWrite(pin, value)</code> function, where the desired duty cycle is specified as an 8-bit <code>value</code>.</p> \\[ \\operatorname{Duty-Cycle}=\\frac{value_{\\operatorname{(8-bit)}}}{255_{(\\operatorname{8-bit})}} = \\frac{time_{HIGH}}{time_{Total}}=\\frac{t_{HIGH}}{t_{LOW} + t_{HIGH}} \\] <p> The GPIO pins that support PWM outputs on the RA6M5 Thing Plus. </p> Mean Value \u2260 Analog <p>PWM signals are often mistaken for analog signals; however, a PWM output is not a true analog signal. These signals can emulate an analog output, based on the average voltage output of their square waveform for a specific duration of time.</p> <p>Arduino</p> <p>By default, in the Arduino IDE, <code>analogWrite()</code> accepts an 8-bit value. To change the resolution of the PWM signal for the <code>analogWrite()</code> function, use the <code>analogWriteResolution(bits)</code> function.</p> <p>A PWM output is not a true analog signal. For a true analog output, please refer to the Analog Outputs tab.</p> <p>Tip</p> <p>To learn more about pulse width modulation (PWM), check out this great tutorial.</p> <ul> <li> <p> <p>Pulse Width Modulation</p> <p>The RA6M5 has six 12-bit ADC channels on its GPIO pins to read analog signals. This functionality is accessed in the Arduino IDE using the <code>analogRead(pin)</code> function. The available ADC pins are highlighted in the image below.</p> <p> Analog input pins on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>In the Arduino IDE, <code>analogRead()</code> returns a 10-bit value by default. To change the resolution of the value returned by the <code>analogRead()</code> function, use the <code>analogReadResolution(bits)</code> function.</p> <p>Tip</p> <p>To learn more about analog vs. digital signals, check out this great tutorial.</p> <ul> <li> <p> <p>Analog to Digital Conversion</p> <p>The RA6M5 has two 12-bit DAC channels on its GPIO pins to output analog signals. This feature is accessed in the Arduino IDE using the <code>AnalogWave</code> library from the Renesas Arduino core. The available DAC pins are highlighted in the image below.</p> <p> GPIO Pin DAC Channel <code>A0</code> <code>DAC</code> <code>A1</code> <code>DAC1</code> <p></p> <p> Analog (DAC) output pins on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>When implementing the <code>AnalogWave</code> library, users will need to link the library and create an instance of the <code>analogWave</code> class with a DAC <code>pin</code> declared for the output.</p> <pre><code>#include \"analogWave.h\" // Include the library for analog waveform generation\n\nanalogWave wave(pin);   // Create an instance of the analogWave class, using a DAC pin\n</code></pre> <p>For more information, please refer to the Analog I/O example in this guide.</p> <p>Tip</p> <p>To learn more about analog vs. digital signals, check out this great tutorial.</p> <ul> <li> <p> <p>Analog vs. Digital</p> <p>The RA6M5 supports up to ten UART ports. However, only the three UART ports are predefined in the Renesas Arduino core. In the Arduino IDE, the serial communication class is used for the USB connection (<code>Serial</code>), the labeled UART I/O pins on the board (<code>Serial1</code>), and UART connection to the DA14531MOD (<code>Serial2</code>).</p> <p> UART connections on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>By default, in the Arduino IDE, the RA6M5 Thing Plus board definition supports:</p> <p> Arduino Object GPIO Pins Connection <code>Serial</code> USB <code>Serial1</code> RX - <code>P408</code> (<code>D21</code>)TX - <code>P409</code> (<code>D20</code>) PTH Pins <code>Serial2</code> RX - <code>P601</code> (<code>D32</code>)TX - <code>P602</code> (<code>D31</code>)RTS - <code>P301</code> (<code>D33</code>)CTS - <code>P303</code> (<code>D34</code>) DA14531MODBluetooth Module <p></p> <p>To utilize serial communication on other pins, users will need to create a custom serial port object and declare which pins to access.</p> Shared UART Port <p>Users should be aware that the UART port for pins <code>D17</code>/<code>D18</code>, UART9, is also utilized for communication with the DA14531MOD Bluetooth module. Therefore, if UART9 is already being utilized for the DA14531MOD; the UART port will be unavailable on pins <code>D17</code>/<code>D18</code>.</p> <p> UART Port Arduino Object GPIO Pins Connection USB <code>Serial</code> USB UART3 <code>Serial1</code> RX - <code>P408</code> (<code>D21</code>)TX - <code>P409</code> (<code>D20</code>) PTH Pins UART9 <code>Serial2</code> RX - <code>P601</code> (<code>D32</code>)TX - <code>P602</code> (<code>D31</code>)RTS - <code>P301</code> (<code>D33</code>)CTS - <code>P303</code> (<code>D34</code>) DA14531MODBluetooth Module UART9 RX - <code>P110</code> (<code>D17</code>)TX - <code>P109</code> (<code>D18</code>) PTH Pins UART7 RX - <code>P402</code> (<code>D05</code>)TX - <code>P401</code> (<code>D15</code>)RTS - <code>P403</code> (<code>D04</code>)CTS - <code>P404</code> (<code>D03</code>) PTH Pins <p></p> <p>Tip</p> <p>To learn more about serial communication, check out this great tutorial.</p> <ul> <li> <p> <p>Serial Communication</p> <p>The RA6M5 supports up to two SPI buses. However, only a single SPI port is defined in the Renesas Arduino core. In the Arduino IDE, the SPI communication class is configured to utilize pins SCK - <code>P111</code>/<code>D19</code>, POCI - <code>P110</code>/<code>D17</code>, PICO - <code>P109</code>/<code>D18</code>, and <code>P112</code>/<code>D0</code> for its chip select.</p> New Nomenclature <p>To comply with the latest OSHW design practices, we have adopted the new SPI signal nomenclature (<code>SDO</code>/<code>SDI</code> and <code>PICO</code>/<code>POCI</code>). The terms Master and Slave are now referred to as Controller and Peripheral. The <code>MOSI</code> signal on a controller has been replaced with <code>SDO</code> or <code>PICO</code>. Please refer to this announcement on the decision to deprecate the <code>MOSI</code>/<code>MISO</code> terminology and transition to the <code>SDO</code>/<code>SDI</code> naming convention.</p> <p> SPI pins on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>By default, in the Arduino IDE, the RA6M5 Thing Plus board definition supports:</p> <p> SPI Pin GPIO POCI <code>P110</code> (<code>D17</code>) PICO <code>P109</code> (<code>D18</code>) SCK <code>P111</code> (<code>D19</code>) CS <code>P112</code> (<code>D0</code>) <p></p> <p>To utilize SPI communication on other pins, users will need to create a custom SPI object and declare which pins to access.</p> <p>Tip</p> <p>To learn more about the serial peripheral interface (SPI) protocol, check out this great tutorial.</p> <ul> <li> <p> <p>Serial Peripheral Interface (SPI)</p> <p>The RA6M5 supports up to three I<sup>2</sup>C buses. However, only a single I<sup>2</sup>C bus is defined in the Renesas Arduino core. In the Arduino IDE, the Wire class is configured to utilize the SDA - <code>P401</code>/<code>D15</code> and SCL -<code>P400</code>/<code>D16</code> pins. These pins also share the same I<sup>2</sup>C bus as the Qwiic connector and MAX17048 fuel gauge.</p> <p> I<sup>2</sup>C connections on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>By default, in the Arduino IDE, the RA6M5 Thing Plus board definition supports:</p> <p> I<sup>2</sup>C Pin GPIO SCL <code>P400</code> (<code>D16</code>) SDA <code>P401</code> (<code>D15</code>) <p></p> <p>To utilize the I<sup>2</sup>C ports on other pins, users will need to create a custom Wire object and declare which pins to access.</p> <p>Tip</p> <p>To learn more about the inter-integrated circuit (I<sup>2</sup>C) protocol, check out this great tutorial.</p> <ul> <li> <p> <p>I2C</p> What is Qwiic? <p> </p> <p>The Qwiic connect system is a solderless, polarized connection system that allows users to seamlessly daisy chain     I<sup>2</sup>C boards together. Play the video, to learn more about the Qwiic connect system or click on the banner above to learn more about Qwiic     products.</p> <p> <p> </p> <p>Features of the Qwiic System</p> No SolderingPolarized ConnectorDaisy Chain-able <p> </p> <p>Qwiic cables (4-pin JST) plug easily from development boards to sensors, shields, accessory boards and more, making easy work of setting up a new prototype.</p> <p> </p> <p>There's no need to worry about accidentally swapping the <code>SDA</code> and <code>SCL</code> wires on your breadboard. The Qwiic connector is polarized so you know you\u2019ll have it wired correctly every time.</p> <p>The part numbers for the PCB connector is <code>SM04B-SRSS</code> (Datasheet) and the mating connector on the cables is <code>SHR04V-S-B</code>; or an equivalent 1mm pitch, 4-pin JST connection.</p> <p> </p> <p>It\u2019s time to leverage the power of the I<sup>2</sup>C bus! Most Qwiic boards will have two or more connectors on them, allowing multiple devices to be connected.</p> <p>The RA6M5 provides IRQ support on several of its pins. In the Arduino IDE, interrupt requests are configured using the <code>attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)</code> function. The available IRQ pins are highlighted in the image below.</p> <p> Interrupt request pins on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>In the Arduino IDE, interrupt requests are configured using the <code>attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)</code> function, where:</p> <ul> <li><code>pin</code> - The GPIO pin</li> <li><code>ISR</code> -   The interrupt service routine to call/execute when the interrupt occurs</li> <li><code>mode</code> - Defines how the interrupt should be triggered:<ul> <li><code>LOW</code> - When the pin is LOW</li> <li><code>CHANGE</code> - Whenever the pin changes value</li> <li><code>RISING</code> - When the pin changes from LOW to HIGH</li> <li><code>FALLING</code>- When the pin changes from HIGH to LOW</li> </ul> </li> </ul> <p>Tip</p> <p>To learn more about interrupts, check out this great tutorial.</p> <ul> <li> <p> <p>Processor Interrupts with Arduino</p> <p>For more technical specifications on the I/O pins, please refer to the schematic, RA6M5 datasheet, and RA6M5 user manual.</p>"},{"location":"hardware_overview/#da14531mod-ble-module","title":"DA14531MOD BLE Module","text":"<p>The DA14531MOD, from Renesas, provides the RA6M5 Thing Plus with Bluetooth connectivity. When actively transmitting, the DA14531MOD sips a mere 4mA; low enough to operate on a small coin-cell battery. The module is programmed with a precompiled binary of the CodeLess SDK, featuring Renesas' SmartBond\u2122 - CodeLess\u2122 AT command set. With the implementation of an AT command platform to configure the DA1431MOD's Bluetooth connectivity, source code is no longer required to be written for the module, to operate as a peripheral device.</p> <p></p> <p>The DA14531MOD BLE module on the RA6M5 Thing Plus.</p> <ul> <li>Bluetooth 5.1 system-on-chip (SoC)<ul> <li>Supports up to three connections</li> <li>32-bit Arm\u00ae Cortex\u00ae M0+<ul> <li>Clock frequency: 16 MHz</li> <li>Memory:<ul> <li>Flash: 128 Kb</li> <li>RAM: 48 Kb</li> <li>ROM: 144 Kb</li> <li>OTP: 32 Kb</li> </ul> </li> </ul> </li> </ul> </li> <li>Operating range (1.8 V - 3.6 V)<ul> <li>Receive: 2mA</li> <li>Transmit: 4mA</li> <li>Sleep: 1.8 \u00b5A</li> </ul> </li> <li>Radio<ul> <li>Transmit Power: -19 to +2.2 dBm</li> <li>Receiver Sensitivity: -93 dBm</li> </ul> </li> </ul> Debug Pins <p>The SWD pins for the DA14531MOD are available as 0.1\" test points on the board. However, users are unlikely to utilize these pins unless they wish to modify the pre-existing firmware on the DA14531MOD.</p> <p> GND SWCLK 3.3V | RST SWDIO </p> <p>Info</p> <p>In case users are interested, these are the pin connections of the SWD test points to the DA14531MOD. For more details, please reference the schematic.</p> <ul> <li><code>SWDIO</code>: <code>P0_10</code></li> <li><code>SWCLK</code>: <code>P0_2</code></li> </ul> <p>Note</p> <p>In order to debug the DA14531MOD, users will need a debug probe. We recommend the J-Link debug probes from Segger. However, users should verify the supported devices before purchasing these products; for example, we had a few issues with the J-Link EDU Mini.</p> <p> The SWD pins for the DA14531MOD on the RA6M5 Thing Plus. </p> CodeLess Firmware <p>The CodeLess\u2122 AT command allows users to easily configure the RA6M5 Thing Plus as a central or peripheral Bluetooth device. In addition, users can also potentially implement OTA updates with the CodeLess\u2122 AT commands.</p> <p>The precompiled binary from the CodeLess SDK utilized as the firmware image, on the DA14531MOD of the RA6M5 Thing Plus, is the <code>codeless_531_datapump.hex</code> (CodeLess for DA1453x datapump).</p> <p>Serial Port Setting</p> <p>The default settings of the serial port on the DA14531MOD, for AT commands:</p> <ul> <li>BaudRate : 57600</li> <li>DataBits : 8</li> <li>StopBits : 1</li> <li>Parity : None</li> <li>Flow Control : None</li> <li>Transmit Text: Append CR</li> </ul> <p>For more details, please refer to the DA14531 datasheet, and CodeLess user manual.</p>"},{"location":"hardware_overview/#external-memory","title":"External Memory","text":""},{"location":"hardware_overview/#qspi-flash","title":"QSPI Flash","text":"<p>The RA6M5 Thing Plus features 16MB of QSPI Flash memory, with the MX25L12833F from Macronix. The MX25L12833F QSPI Flash memory provides users with high-speed non-volatile memory to develop and execute data-driven applications. This feature is perfect for data logging, data processing, or executing memory-intensive algorithms. The QSPI Flash memory can also be used to store a firmware backup or enable software updates.</p> <p>The Flash memory is connected to the following GPIO:</p> <ul> <li>CLK: GPIO <code>P100</code> (<code>D40</code>)</li> <li>D0: GPIO <code>P102</code> (<code>D42</code>)</li> <li>D1: GPIO <code>P101</code> (<code>D43</code>)</li> <li>D2: GPIO <code>P104</code> (<code>D44</code>)</li> <li>D3: GPIO <code>P103</code> (<code>D45</code>)</li> <li>SS: GPIO <code>P501</code> (<code>D41</code>)</li> </ul> <p></p> <p>The MX25L12833F QSPI Flash memory IC on the back of the RA6M5 Thing Plus.</p> <p>For more details, please refer to the MX25L12833F datasheet, the schematic, RA6M5 datasheet, and RA6M5 user manual.</p>"},{"location":"hardware_overview/#sd-card-socket","title":"\u00b5SD Card Socket","text":"<p>The \u00b5SD card socket is connected to the SD host interface for fast data logging. This feature is useful for data collection over extended periods and for simplifying data retrieval.</p> <p>The \u00b5SD card slot is connected to the following GPIO:</p> <ul> <li>CLK: GPIO <code>P214</code> (<code>D22</code>)</li> <li>D0: GPIO <code>P208</code> (<code>D24</code>)</li> <li>D1: GPIO <code>P410</code> (<code>D25</code>)</li> <li>D2: GPIO <code>P206</code> (<code>D26</code>)</li> <li>D3: GPIO <code>P205</code> (<code>D27</code>)</li> </ul> <p></p> <p>\u00b5SD card slot on the back of the RA6M5 Thing Plus.</p> <p>Data Corruption</p> <p>To avoid corrupting an SD card, users should disable all activity with the SD card before removing it from the RA6M5 Thing Plus.</p> <p>The FATFileSystem library built into the Renesas-Arduino core, supports \u00b5SD cards with a FAT32 file system (i.e. SD cards up to 32GB in size).</p> <ul> <li>While users may be able to use cards with a higher storage capacity, we highly advise against it. As users may experience data loss due to a corrupt file system (i.e. SD cards with a storage capacity greater than 32GB are not meant to be formatted with a FAT32 file system).</li> </ul> <p>Note</p> <p>The RA6M5 Thing Plus, offers users additional control of the SD card slot with the following pin connections:</p> <p> Pin Name Connection to RA6M5 Operation Function SDEN GPIO <code>P708</code> (<code>D35</code>) Active LOW Controls power to the SD card slot.- A LOW signal will disable power to the SD card slot CD GPIO <code>P210</code> (<code>D28</code>) Active LOW Read the pin latch, to determine if an SD card is inserted- A LOW signal will indicate an SD card is present WP GPIO <code>P414</code> (<code>D29</code>) Active LOW Read if the write protection is engaged on the SD card- A LOW signal will indicate write protection is enabled on the SD card <p></p> <p>For more details, please refer to the schematic, RA6M5 datasheet, and RA6M5 user manual.</p>"},{"location":"hardware_overview/#i2c-bus","title":"I<sup>2</sup>C Bus","text":""},{"location":"hardware_overview/#qwiic-connector","title":"Qwiic Connector","text":"<p>A Qwiic connector is provided for users to seamlessly integrate with SparkFun's Qwiic Ecosystem. Otherwise, users can also access the I<sup>2</sup>C bus through the PTH pins broken out on the board.</p> <p></p> <p>Qwiic connector and I<sup>2</sup>C pins on the RA6M5 Thing Plus.</p> What is Qwiic? <p> </p> <p>The Qwiic connect system is a solderless, polarized connection system that allows users to seamlessly daisy chain I<sup>2</sup>C boards together. Play the video, to learn more about the Qwiic connect system or click on the banner above to learn more about Qwiic products.</p> <p> <p> </p> <p>Features of the Qwiic System</p> No SolderingPolarized ConnectorDaisy Chain-able <p> </p> <p>Qwiic cables (4-pin JST) plug easily from development boards to sensors, shields, accessory boards and more, making easy work of setting up a new prototype.</p> <p> </p> <p>There's no need to worry about accidentally swapping the <code>SDA</code> and <code>SCL</code> wires on your breadboard. The Qwiic connector is polarized so you know you\u2019ll have it wired correctly every time.</p> <p>The part numbers for the PCB connector is <code>SM04B-SRSS</code> (Datasheet) and the mating connector on the cables is <code>SHR04V-S-B</code>; or an equivalent 1mm pitch, 4-pin JST connection.</p> <p> </p> <p>It\u2019s time to leverage the power of the I<sup>2</sup>C bus! Most Qwiic boards will have two or more connectors on them, allowing multiple devices to be connected.</p>"},{"location":"hardware_overview/#battery-fuel-gauge","title":"Battery Fuel Gauge","text":"<p>The MAX17048 fuel gauge, from Analog Devices, measures the approximate charge/discharge rate, state of charge (SOC) (based on ModelGauge algorithm), and voltage of a connected battery. The sensor is also powered directly from a connected LiPo battery (<code>VBAT</code>).</p> <p> I<sup>2</sup>C Address 0x36 (7-bit)0x6C (write)/0x6D (read) Voltage Measurement Range: 2.5 - 5 VPrecision: \u00b17.5 mV/CellResolution 1.25 mV/Cell Current Consumption Sleep: .5 - 2 \u00b5AHibernate: 3 - 5 \u00b5AActive: 23 - 40 \u00b5A <p></p> <p>Alert Pin</p> <p>The fuel gauge features an <code>Alert</code> pin, which can be configured to trigger an interrupt (active LOW) on GPIO <code>P000</code> (<code>D39</code>) of the RA6M5 for:</p> <ul> <li>Low Charge</li> <li>1% Charge (Remaining)</li> <li>IC Reset</li> <li>Overvoltage</li> <li>Undervoltage</li> </ul> <p></p> <p>The MAX17048 fuel gauge on the RA6M5 Thing Plus.</p> <p>For more information, please refer to the MAX17048 datasheet and the schematic.</p>"},{"location":"hardware_overview/#status-leds","title":"Status LEDs","text":"<p>There are four status LEDs on the RA6M5 Thing Plus:</p> <ul> <li><code>PWR</code> - Power (Red)<ul> <li>Illuminates once power is applied to <code>3V3</code></li> </ul> </li> <li><code>RGB</code> - WS2812 (RGB)<ul> <li>An addressable WS2812 LED</li> <li>Connected to GPIO <code>P105</code> (<code>D13</code> or <code>RGB_LED</code>) of the RA6M5</li> </ul> </li> <li><code>STAT</code> - Status (Blue)<ul> <li>Connected to the RA6M5 <code>P106</code> (<code>D14</code>/<code>LED_BUILTIN</code>) GPIO</li> </ul> </li> <li><code>CHG</code> - Battery Charge (Yellow)<ul> <li>ON - Actively charging a battery</li> <li>OFF - The charge controller is shut down or battery charging is complete</li> </ul> </li> </ul> <p></p> <p>The status indicator LEDs on the RA6M5 Thing Plus.</p>"},{"location":"hardware_overview/#buttons","title":"Buttons","text":"<p>There are two buttons on the RA6M5 Thing Plus: RST and USRBTN</p> <p></p> <p>Buttons on the RA6M5 Thing Plus.</p> <ul> <li>USRBTN - The user button is provided as an available input for the RA6M5; it is connected to GPIO <code>P415</code> (<code>D31</code>)</li> <li>RST - The reset button allows users to reset the firmware running on the RA6M5 without interrupting the power     </li> </ul> DFU Mode <p>If users are having issues uploading code to the board, the RA6M5 can be manually forced into DFU mode. This issue, often occurs when the USB connection is busy and a reset can't be triggered on the RA6M5, to initialize the upload process. To force the RA6M5 Thing Plus into DFU mode:</p> <ol> <li>Double-tap the RST button<ul> <li>The <code>STAT</code> LED should be fading in/out very slowly</li> </ul> </li> <li>Users should now, be able to upload a new program<ul> <li>It shouldn't be necessary to select a COM port in the Arduino IDE; only the board needs to be selected</li> </ul> </li> <li>Once programming is complete, the MCU should reboot on its own. Otherwise:<ul> <li>Press the RST button</li> <li>Power cycle the board</li> </ul> </li> </ol> <p>For more details, please refer to the schematic.</p>"},{"location":"hardware_overview/#jumpers","title":"Jumpers","text":"Never modified a jumper before? <p>Check out our Jumper Pads and PCB Traces tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <p>The five jumpers on the back of the board can be used to easily modify the hardware connections on the board.</p> <p></p> <p>The jumpers on the back of the RA6M5 Thing Plus PCB.</p> <ul> <li><code>PWR</code> - Cut this jumper to disable the red, <code>PWR</code> LED</li> <li><code>RST</code> - Cut this jumper to disconnect the reset pin of the DA14531MOD from the RA6M5 <code>P115</code>/<code>D37</code> GPIO</li> <li><code>SHLD</code> - Cut this jumper to isolate the USB-C connector shield from GND</li> <li><code>I2C</code> - Open this dual-jumper to disconnect the pull-up resistors from the <code>SDA</code> and <code>SCL</code></li> <li><code>CHG</code> - Cut this jumper to disable the yellow, <code>CHG</code> LED</li> </ul> <p>For more details, please refer to the schematic.</p>"},{"location":"introduction/","title":"Introduction","text":"<ul> <li> <p> RA6M5 Thing Plus SKU: WRL-24243 <p> </p> <p> <p> </p> <p> \u00a0\u00a0Purchase from SparkFun  </p> <li> <p>Clocking in at 200MHz, the RA6M5 is a high-performance microcontroller from Renesas that is perfect for real-time applications. The SparkFun Thing Plus - RA6M5, is our latest Thing Plus board featuring the standard Qwiic connector, JST LiPo battery connector, 21 GPIO pins broken out in a Feather footprint, and status indicator LEDs. At the core is the RA6M5 microcontroller, a low-power Arm<sup>\u00ae</sup> Cortex<sup>\u00ae</sup>-M33 processor with an available 512kB of SRAM and 2MB of Flash and an extensive list of peripheral capabilities. Additionally, we have included 16MB of QSPI Flash and an SD card slot on the board, so users won't have to worry about running out of memory space or data storage options.</p> <p>The SparkFun RA6M5 Thing Plus also features Bluetooth\u00ae Low Energy connectivity, thanks to the provided DA14531MOD module (also from Renesas). When actively transmitting, the DA14531MOD sips a mere 4mA and is capable of operating from a small coin-cell battery. The firmware provided on the module features Renesas' SmartBond\u2122 - CodeLess\u2122 AT command set. Therefore, users only need to send AT commands to configure a Bluetooth connection; without the need to reprogram the module.</p> <p>Note</p> <p>While the Thing Plus - RA6M5 does include some 5V tolerant pins, it is primarily a 3.3V logic-level board.</p> <p>While the full capabilities of the RA6M5 support a broad range of features, only a limited set may be implemented, by default, in the Renesas-Arduino core. However, the capabilities of the Thing Plus - RA6M5 should be comparable to the Arduino Portenta C33; with the exclusion of WiFi connectivity.</p> </li>"},{"location":"introduction/#required-materials","title":"Required Materials","text":"<p>To get started, users will need a few items. Some users may already have a few of these items, feel free to adjust accordingly.</p> <ul> <li>Computer with an operating system (OS) that is compatible with all the software installation requirements</li> <li>USB 3.1 Cable A to C - 3 Foot - Used to interface with the RA6M5 Thing Plus (1)</li> <li>SparkFun RA6M5 Thing Plus</li> </ul> <ol> <li>If your computer doesn't have a USB-A slot, then choose an appropriate cable or adapter.</li> </ol> <ul> <li> <p> <p>USB 3.1 Cable A to C - 3 Foot CAB-14743</p> <li> <p> <p>RA6M5 Thing Plus WRL-24243</p> Data Logging <p>This board is capable of logging data to an \u00b5SD card. Please check out the memory cards and accessories in our product catalog.</p> <ul> <li> <p> <p>microSD Card - 1GB (Class 4) COM-15107</p> <li> <p> <p>microSD USB Reader COM-13004</p> Headers and Wiring <p>To add headers or hookup wires, users will need soldering equipment and headers/wires.</p> <p>New to soldering?</p> <p>Check out our How to Solder: Through-Hole Soldering tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <ul> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>PINECIL Soldering Iron Kit KIT-24063</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p> <li> <p> <p>Feather Stackable Header Kit PRT-15187</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Hook-Up Wire - Assortment (Stranded, 22 AWG) PRT-11375</p> Li-Po Battery <p>For mobile applications, users will want to pick up a single-cell LiPo battery from our catalog.</p> <ul> <li> <p> <p>Lithium Ion Battery - 2Ah PRT-13855</p> <li> <p> <p>Lithium Ion Battery - 400mAh PRT-13851</p> <li> <p> <p>Lithium Ion Battery - 1Ah PRT-13813</p> <li> <p> <p>Lithium Ion Battery - 110mAh PRT-13853</p> Qwiic Devices and Cables <p>Our Qwiic connect system is a simple solution for daisy chaining I<sup>2</sup>C devices without the hassle of soldering or checking wire connections. Check out other Qwiic devices from our catalog.</p> <ul> <li> <p> <p>SparkFun Qwiic Cable Kit KIT-15081</p> <li> <p> <p>Qwiic Cable - Grove Adapter (100mm) PRT-15109</p> <li> <p> <p>SparkFun Qwiic OLED - (1.3in., 128x64) LCD-23453</p> <li> <p> <p>SparkFun GPS Breakout - XA1110 (Qwiic) GPS-14414</p> <li> <p> <p>SparkFun Qwiic Joystick COM-15168</p> <li> <p> <p>SparkFun Qwiic Mux Breakout - 8 Channel (TCA9548A) BOB-16784</p> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>SparkFun Qwiic Mini ToF Imager - VL53L5CX SEN-19013</p> <p>What is Qwiic?</p> <p> </p> <p>The Qwiic connect system is a solderless, polarized connection system that allows users to seamlessly daisy chain I<sup>2</sup>C boards together. Play the video, to learn more about the Qwiic connect system or click on the banner above to learn more about Qwiic products.</p> <p> <p> </p> <p>Features of the Qwiic System</p> No SolderingPolarized ConnectorDaisy Chain-able <p> </p> <p>Qwiic cables (4-pin JST) plug easily from development boards to sensors, shields, accessory boards and more, making easy work of setting up a new prototype.</p> <p> </p> <p>There's no need to worry about accidentally swapping the <code>SDA</code> and <code>SCL</code> wires on your breadboard. The Qwiic connector is polarized so you know you\u2019ll have it wired correctly every time.</p> <p>The part numbers for the PCB connector is <code>SM04B-SRSS</code> (Datasheet) and the mating connector on the cables is <code>SHR04V-S-B</code>; or an equivalent 1mm pitch, 4-pin JST connection.</p> <p> </p> <p>It\u2019s time to leverage the power of the I<sup>2</sup>C bus! Most Qwiic boards will have two or more connectors on them, allowing multiple devices to be connected.</p> Jumper Modification <p>To modify the jumpers, users will need soldering equipment and/or a hobby knife.</p> <p>New to jumper pads?</p> <p>Check out our Jumper Pads and PCB Traces Tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <ul> <li> <p> <p>SparkFun Beginner Tool Kit TOL-22265</p> <li> <p> <p>Hobby Knife TOL-09200</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p>"},{"location":"introduction/#suggested-reading","title":"Suggested Reading","text":"<p>As a more sophisticated product, we will skip over the more fundamental tutorials (i.e. Ohm's Law and What is Electricity?). However, below are a few tutorials that may help users familiarize themselves with various aspects of the board.</p> <ul> <li> <p> <p>Installing the Arduino IDE</p> <li> <p> <p>Installing an Arduino Library</p> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p> <li> <p> <p>Logic Levels</p> <li> <p> <p>Analog vs. Digital</p> <li> <p> <p>Analog to Digital Conversion</p> <li> <p> <p>Pulse Width Modulation</p> <li> <p> <p>Serial Communication</p> <li> <p> <p>Serial Terminal Basics</p> <li> <p> <p>Data Types in Arduino</p> <li> <p> <p>I2C</p> <li> <p> <p>SPI</p> <li> <p> <p>Processor Interrupts with Arduino</p> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <li> <p> <p>Integrated Circuits</p>"},{"location":"print_view/","title":"Introduction","text":"<ul> <li> <p> RA6M5 Thing Plus SKU: WRL-24243 <p> </p> <p> <p> </p> <p> \u00a0\u00a0Purchase from SparkFun  </p> <li> <p>Clocking in at 200MHz, the RA6M5 is a high-performance microcontroller from Renesas that is perfect for real-time applications. The SparkFun Thing Plus - RA6M5, is our latest Thing Plus board featuring the standard Qwiic connector, JST LiPo battery connector, 21 GPIO pins broken out in a Feather footprint, and status indicator LEDs. At the core is the RA6M5 microcontroller, a low-power Arm<sup>\u00ae</sup> Cortex<sup>\u00ae</sup>-M33 processor with an available 512kB of SRAM and 2MB of Flash and an extensive list of peripheral capabilities. Additionally, we have included 16MB of QSPI Flash and an SD card slot on the board, so users won't have to worry about running out of memory space or data storage options.</p> <p>The SparkFun RA6M5 Thing Plus also features Bluetooth\u00ae Low Energy connectivity, thanks to the provided DA14531MOD module (also from Renesas). When actively transmitting, the DA14531MOD sips a mere 4mA and is capable of operating from a small coin-cell battery. The firmware provided on the module features Renesas' SmartBond\u2122 - CodeLess\u2122 AT command set. Therefore, users only need to send AT commands to configure a Bluetooth connection; without the need to reprogram the module.</p> <p>Note</p> <p>While the Thing Plus - RA6M5 does include some 5V tolerant pins, it is primarily a 3.3V logic-level board.</p> <p>While the full capabilities of the RA6M5 support a broad range of features, only a limited set may be implemented, by default, in the Renesas-Arduino core. However, the capabilities of the Thing Plus - RA6M5 should be comparable to the Arduino Portenta C33; with the exclusion of WiFi connectivity.</p> </li>"},{"location":"print_view/#required-materials","title":"Required Materials","text":"<p>To get started, users will need a few items. Some users may already have a few of these items, feel free to adjust accordingly.</p> <ul> <li>Computer with an operating system (OS) that is compatible with all the software installation requirements</li> <li>USB 3.1 Cable A to C - 3 Foot - Used to interface with the RA6M5 Thing Plus (1)</li> <li>SparkFun RA6M5 Thing Plus</li> </ul> <ol> <li>If your computer doesn't have a USB-A slot, then choose an appropriate cable or adapter.</li> </ol> <ul> <li> <p> <p>USB 3.1 Cable A to C - 3 Foot CAB-14743</p> <li> <p> <p>RA6M5 Thing Plus WRL-24243</p> Data Logging <p>This board is capable of logging data to an \u00b5SD card. Please check out the memory cards and accessories in our product catalog.</p> <ul> <li> <p> <p>microSD Card - 1GB (Class 4) COM-15107</p> <li> <p> <p>microSD USB Reader COM-13004</p> Headers and Wiring <p>To add headers or hookup wires, users will need soldering equipment and headers/wires.</p> <p>New to soldering?</p> <p>Check out our How to Solder: Through-Hole Soldering tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <ul> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>PINECIL Soldering Iron Kit KIT-24063</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p> <li> <p> <p>Feather Stackable Header Kit PRT-15187</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Hook-Up Wire - Assortment (Stranded, 22 AWG) PRT-11375</p> Li-Po Battery <p>For mobile applications, users will want to pick up a single-cell LiPo battery from our catalog.</p> <ul> <li> <p> <p>Lithium Ion Battery - 2Ah PRT-13855</p> <li> <p> <p>Lithium Ion Battery - 400mAh PRT-13851</p> <li> <p> <p>Lithium Ion Battery - 1Ah PRT-13813</p> <li> <p> <p>Lithium Ion Battery - 110mAh PRT-13853</p> Qwiic Devices and Cables <p>Our Qwiic connect system is a simple solution for daisy chaining I<sup>2</sup>C devices without the hassle of soldering or checking wire connections. Check out other Qwiic devices from our catalog.</p> <ul> <li> <p> <p>SparkFun Qwiic Cable Kit KIT-15081</p> <li> <p> <p>Qwiic Cable - Grove Adapter (100mm) PRT-15109</p> <li> <p> <p>SparkFun Qwiic OLED - (1.3in., 128x64) LCD-23453</p> <li> <p> <p>SparkFun GPS Breakout - XA1110 (Qwiic) GPS-14414</p> <li> <p> <p>SparkFun Qwiic Joystick COM-15168</p> <li> <p> <p>SparkFun Qwiic Mux Breakout - 8 Channel (TCA9548A) BOB-16784</p> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>SparkFun Qwiic Mini ToF Imager - VL53L5CX SEN-19013</p> <p>What is Qwiic?</p> <p> </p> <p>The Qwiic connect system is a solderless, polarized connection system that allows users to seamlessly daisy chain I<sup>2</sup>C boards together. Play the video, to learn more about the Qwiic connect system or click on the banner above to learn more about Qwiic products.</p> <p> <p> </p> <p>Features of the Qwiic System</p> No SolderingPolarized ConnectorDaisy Chain-able <p> </p> <p>Qwiic cables (4-pin JST) plug easily from development boards to sensors, shields, accessory boards and more, making easy work of setting up a new prototype.</p> <p> </p> <p>There's no need to worry about accidentally swapping the <code>SDA</code> and <code>SCL</code> wires on your breadboard. The Qwiic connector is polarized so you know you\u2019ll have it wired correctly every time.</p> <p>The part numbers for the PCB connector is <code>SM04B-SRSS</code> (Datasheet) and the mating connector on the cables is <code>SHR04V-S-B</code>; or an equivalent 1mm pitch, 4-pin JST connection.</p> <p> </p> <p>It\u2019s time to leverage the power of the I<sup>2</sup>C bus! Most Qwiic boards will have two or more connectors on them, allowing multiple devices to be connected.</p> Jumper Modification <p>To modify the jumpers, users will need soldering equipment and/or a hobby knife.</p> <p>New to jumper pads?</p> <p>Check out our Jumper Pads and PCB Traces Tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <ul> <li> <p> <p>SparkFun Beginner Tool Kit TOL-22265</p> <li> <p> <p>Hobby Knife TOL-09200</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p>"},{"location":"print_view/#suggested-reading","title":"Suggested Reading","text":"<p>As a more sophisticated product, we will skip over the more fundamental tutorials (i.e. Ohm's Law and What is Electricity?). However, below are a few tutorials that may help users familiarize themselves with various aspects of the board.</p> <ul> <li> <p> <p>Installing the Arduino IDE</p> <li> <p> <p>Installing an Arduino Library</p> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p> <li> <p> <p>Logic Levels</p> <li> <p> <p>Analog vs. Digital</p> <li> <p> <p>Analog to Digital Conversion</p> <li> <p> <p>Pulse Width Modulation</p> <li> <p> <p>Serial Communication</p> <li> <p> <p>Serial Terminal Basics</p> <li> <p> <p>Data Types in Arduino</p> <li> <p> <p>I2C</p> <li> <p> <p>SPI</p> <li> <p> <p>Processor Interrupts with Arduino</p> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <li> <p> <p>Integrated Circuits</p>"},{"location":"print_view/#hardware-overview","title":"Hardware Overview","text":""},{"location":"print_view/#dimensions","title":"Dimensions","text":"<p>The circuit board dimensions are illustrated in the drawing below; the measurements are in inches.</p> <p></p> <p>Dimensions (PDF) of the RA6M5 Thing Plus, in inches.</p> Need more measurements? <p>For more information about the board's dimensions, users can download the Eagle files for the board. These files can be opened in Eagle and additional measurements can be made with the dimensions tool.</p>  Eagle - Free Download! <p>Eagle is a CAD program for electronics that is free to use for hobbyists and students. However, it does require an account registration to utilize the software.</p> <p> Download fromAutodesk primary logo </p>  Dimensions Tool <p>This video from Autodesk demonstrates how to utilize the dimensions tool in Eagle, to include additional measurements:</p> <p> <p> <p> </p> <p></p>"},{"location":"print_view/#usb-connector","title":"USB Connector","text":"<p>The USB-C connector is used to provide power and program the board. For most users, it will also be the primary programming interface for the RA6M5 Thing Plus.</p> <p></p> <p>USB-C connector on the RA6M5 Thing Plus.</p>"},{"location":"print_view/#power","title":"Power","text":"<p>The RA6M5 Thing Plus only requires 3.3V to power the board. However, the simplest method to power the board is through the USB-C connector. Alternatively, the <code>3V3</code>, <code>VBAT</code>, and <code>VUSB</code> pins can also be used to supply power to the board.</p> <p></p> <p>Power connections on the RA6M5 Thing Plus PCB.</p> <p> <pre><code>\nflowchart LR\n    A[USB-C] === B((\"`**VUSB**`\")) ===&gt; |VUSB &gt; VBAT| Switch;\n\n    subgraph Battery Charger\n        direction LR\n        C[MCP73831] -.-&gt; D[LiPo Battery];\n    end\n\n    subgraph Switch\n        F[LM66200];\n    end\n\n    B ==&gt; C;\n    D === E((\"`**VBAT**`\")) == VBAT &gt; VUSB ==&gt; Switch;\n\n    F ===   H[RT9080] ==&gt; I((\"`**3V3**`\"));\n    F === G[RT9080] ==&gt; J((\"`**VREF**`\"));\n\n    click B \"#vusb\"\n    click C \"#charging-circuit\"\n    click E \"#vbat\"\n    click F \"#power-control\"\n    click J \"#vref\"\n    click I \"#3v3\"</code></pre> <p></p> <p>Below, is a summary of the power circuitry for this board:</p> <code>3V3</code> <code>VUSB</code> <code>VBAT</code> <code>VREF</code> <code>GND</code> Qwiic Connector <ul> <li>Primary power for the RA6M5 Thing Plus<ul> <li>Powers the RA6M5 module, DA14531MOD, QSPI flash, \u00b5SD card slot, Qwiic connector, WS2812 RGB LED, and power LED</li> </ul> </li> <li>A regulated 3.3V is provided by an RT9080 LDO from <code>VUSB</code> or <code>VBAT</code><ul> <li>The output voltage from the RT9080 is controlled by the <code>EN</code> pin on the board</li> <li>The RT9080 can source up to 600mA of current, which is only limited by the power source from the LM66200 switch<ul> <li>The power source from the LM66200 is automatically switched between <code>VUSB</code> or <code>VBAT</code>, based on which has the greater voltage</li> </ul> </li> </ul> </li> <li>As an input, it requires a regulated 3.3V to avoid contention with the LDO regulator</li> </ul> <p>The input voltage range for the RT9080 is 1.2-5.5V</p> <ul> <li>Usually powered through the USB-C connector (5V)</li> <li>Input voltage range: 3.75 - 5V<ul> <li>The maximum voltage is limited by the ideal diode switch at 5.5V (1.6-5.5V)</li> <li>The minimum voltage is limited by the charge controller at 3.75V (3.75-6V)</li> </ul> </li> <li>Primary power source for the RT9080 LDOs when <code>VUSB</code> &gt; <code>VBAT</code>; via the LM66200 ideal diode switch</li> <li>Powers the MCP73831 linear charge management controller<ul> <li>Provides a 213mA (max) rate of charge to a connected battery</li> </ul> </li> </ul> <ul> <li>The voltage from the JST battery connector; is meant for single-cell LiPo batteries<ul> <li>A connected battery will be charged by the MCP73831 charge controller, when sufficient power is provided from <code>VUSB</code></li> </ul> </li> <li>Primary power source for the  RT9080 LDOs when <code>VBAT</code> &gt; <code>VUSB</code>; via the LM66200 ideal diode switch</li> <li>A battery's charge can be monitored through the MAX17048 fuel gauge</li> </ul> <ul> <li>The analog reference voltage for the RA6M5 module's ADC and DAC channels<ul> <li>Provided by a RT9080 LDO regulator, separate from one providing the <code>3V3</code> power supply</li> </ul> </li> </ul> <p>The input voltage range for the RT9080 is 1.2-5.5V</p> <ul> <li>The common ground or the 0V reference for the voltage supplies</li> </ul> <ul> <li>The 4-pin JST connector provides a regulated 3.3V voltage to peripheral Qwiic devices from <code>3V3</code></li> </ul> Detailed Diagram <p> <pre><code>\nflowchart LR\n    D === E((\"`**VBAT**`\")) == VBAT &gt; VUSB ==&gt; Switch;\n    A[USB-C] === B((\"`**VUSB**`\")) == VUSB &gt; VBAT ==&gt; Switch;\n    C --- T[CHG LED];\n\nsubgraph Battery Charger\n        C[MCP73831] -.-&gt; D[LiPo&lt;br&gt;3.5-4.2V]\n    end\n\n    subgraph Switch\n        S[LM66200];\n        S === I[RT9080] &amp; H[RT9080];\n    end\n\n    subgraph Powered_Components\n        L[PWR LED];\n        M[RA6M5] --- N[DA14531MOD];\n        M --- O[QSPI Flash];\n        M --- P[SD Card];\n        M --- Q[WS2812 LED];\n        M --- I2C;\n        subgraph I2C\n            R[Qwiic Connector];\n            F[MAX17048];\n        end\n    end\n\n    B ==&gt; C;\n    B ====&gt; T;\n    I --- U((\"`**EN**`\"));\n    I ==&gt; K((\"`**3V3**`\")) === Powered_Components;\n    H ==&gt; J((\"`**VREF**`\")) --&gt; M;\n    H --- W((\"`**D37**`\")) --- M;\n    D ------ F;\n    Switch --- V((\"`**D38**`\")) --- M;</code></pre> <p></p> <p>For more details, users can reference the schematic and the datasheets of the individual components in the power circuitry.</p>"},{"location":"print_view/#power-status-led","title":"Power Status\u00a0 LED","text":"<p>The red, <code>PWR</code> LED will light up once 3.3V is supplied to the board; however, for most users, it will light up when 5V is supplied through the USB connection or when a LiPo battery is connected to the JST connector.</p> <p></p> <p>The <code>PWR</code> status LED indicator on the RA6M5 Thing Plus.</p>"},{"location":"print_view/#charging-circuit","title":"Charging Circuit","text":"<p>The charging circuit utilizes the MCP73831 linear charge management controller from Microchip Technologies, which is powered by the USB-C connector or <code>VUSB</code>. The controller provides a 213mA charge rate for a LiPo battery connected to the JST connector. Active charging is indicated by the yellow, <code>CHG</code> LED. If the charge controller is shut down or charging is complete, the <code>CHG</code> LED will turn off. The board also includes a MAX17048 fuel gauge from Analog Devices to monitor the charge left on the battery.</p> <p> <pre><code>\nflowchart LR\n    A[USB-C] === B((\"`**VUSB**`\")) ==&gt; C &amp; G;\n    D ===&gt; E((\"`**VBAT**`\"));\n    D --- F[MAX17048] === H((\"`**3V3**`\"));\n    G[CHG LED] --- C[MCP73831];\n\n    subgraph Battery Charger\n        C -.-&gt; |213mA| D[LiPo&lt;br&gt;3.5-4.2V];\n    end</code></pre> <p></p> <p></p> <p>The <code>CHG</code> status LED and JST connector for the battery on the RA6M5 Thing Plus.</p> <p>For more details, please refer to the MCP73831 and MAX17048 datasheets, schematic, and the Status LEDs and Battery Fuel Gauge sections below.</p>"},{"location":"print_view/#power-control","title":"Power Control","text":"<p>The primary power source for the RT9080 LDO regulators is automatically switched between <code>VUSB</code> and <code>VBAT</code> by the LM66200 ideal diode switch; based on their voltage levels. This will be indicated by the <code>ST</code> pin of the LM66200, which is connected to the <code>P001</code> GPIO (<code>D38</code>) of the RA6M5. A <code>LOW</code> state will indicate that power is being supplied from <code>VUSB</code> (or the USB-C connector); while a <code>HIGH</code> state will indicate power is being drawn from <code>VBAT</code> (or the battery JST connector).</p> <p> <pre><code>\nflowchart LR\n    A[USB-C] === B((\"`**VUSB**`\")) == VUSB &gt; VBAT ==&gt; Switch;\n    U((\"`**D38**`\")) --- Switch;\n    D[LiPo] === E((\"`**VBAT**`\")) == VBAT &gt; VUSB ==&gt; Switch;\n\n    subgraph Switch\n        S[LM66200];\n    end\n\n    S === H[RT9080] ===&gt; J((\"`**3V3**`\"));\n    H --- T((\"`**EN**`\"));\n    I --- V((\"`**D37**`\"));\n    S === I[RT9080] ===&gt; K((\"`**VREF**`\"));</code></pre> <p></p> <p>The 3.3V regulated output from the primary RT9080 is enabled by default and controlled by the <code>EN</code> pin on the board. Meanwhile, the voltage output from the RT9080 for the analog reference voltage (<code>VREF</code>) of the RA6M5 is controlled by its <code>P500</code> GPIO (<code>D37</code>). Users can disable the 3.3V power output of either of the RT9080 LDO regulators, by setting the associated control pin LOW.</p> <p></p> <p>The power inputs/outputs and <code>EN</code> pin on the RA6M5 Thing Plus.</p> <p>For more details, please refer to the LM66200 datasheet, RT9080 datasheet, and schematic.</p>"},{"location":"print_view/#ra6m5-microcontroller","title":"RA6M5 Microcontroller","text":"<p>The brains of the board is the RA6M5 microcontroller from Renesas, a low-power Arm<sup>\u00ae</sup> Cortex<sup>\u00ae</sup>-M33 processor with a clock speed up to 200Mhz, 512kB of SRAM, and 2MB of flash memory. This high-performance microcontroller features an extensive list of peripheral capabilities and is perfect for real-time applications.</p> <p></p> <p>The RA6M5 microcontroller on the RA6M5 Thing Plus.</p> <ul> <li>Arm<sup>\u00ae</sup> Cortex<sup>\u00ae</sup>-M33 Core<ul> <li>Clock Frequency: 200MHz</li> <li>Flash Memory: 2MB (code); 8kB (data)</li> <li>SRAM: 512kB w/ ECC Support</li> <li>Arm Memory Protection Unit (Arm MPU)</li> <li>Secure Crypto Engine</li> <li>Two Watchdog Timers (WDT)</li> </ul> </li> <li>Operating Voltage: 3.0V to 3.6V<ul> <li>Current Consumption:<ul> <li>Maximum: 143mA</li> <li>Normal: 32mA</li> <li>Sleep: 11mA</li> <li>Deep Sleep: 0.9-131\u00b5A</li> </ul> </li> </ul> </li> <li>Operating modes:<ul> <li>Single-chip or SCI/USB boot</li> </ul> </li> <li>Operating Temperature: -40 to 85 \u00b0C</li> <li>75 GPIO Pins</li> <li>RTC with Calendar</li> <li>CRC Calculator</li> <li>Internal Temperature Sensor</li> </ul> <p>Peripherals</p> <ul> <li>12-bit ADC (x6)</li> <li>12-bit DAC (x2)</li> <li>32-bit PWM Channels (x4)</li> <li>16-bit PWM Channels (x6)</li> <li>UART (x10)</li> <li>I<sup>2</sup>C Bus (x3)</li> <li>SPI Bus (x2)</li> <li>QSPI (x1)</li> <li>SD/MMC Host Interface</li> </ul> <ul> <li>OSPI (x1)</li> <li>CAN Interface</li> <li>USB 2.0 (Full/High Speed)</li> <li>Ethernet MAC/DMA Controller</li> <li>Serial Sound Interface Enhanced</li> <li>Consumer Electronics Control</li> <li>Capacitive Touch Sensing</li> </ul> <p>Note</p> <p>Users should be aware that not all of the features, listed above, will be available in the Arduino IDE.</p> DFU Mode <p>If users are having issues uploading code to the board, the RA6M5 can be manually forced into DFU mode. This issue, often occurs when the USB connection is busy and a reset can't be triggered on the RA6M5, to initialize the upload process. To force the RA6M5 Thing Plus into DFU mode:</p> <ol> <li>Double-tap the RST button<ul> <li>The <code>STAT</code> LED should be fading in/out very slowly</li> </ul> </li> <li>Users should now, be able to upload a new program<ul> <li>It shouldn't be necessary to select a COM port in the Arduino IDE; only the board needs to be selected</li> </ul> </li> <li>Once programming is complete, the MCU should reboot on its own. Otherwise:<ul> <li>Press the RST button</li> <li>Power cycle the board</li> </ul> </li> </ol> <p>For more technical specifications for the RA6M5 microcontroller, please refer to the RA6M5 datasheet and RA6M5 user manual.</p>"},{"location":"print_view/#debugging-pins","title":"Debugging Pins","text":"<p>Debug pins are available for the RA6M5, as 0.1\" test points on the board. However, the debugging feature is only available through the Renesas FSP (not covered in this tutorial).</p> SWDJTAG <p> GND SWCLK 3.3V | RST SWO SWDIO </p> <p> GND TCK 3.3V | RST TDO TMS </p> <p>Pin Connections</p> <p>In case users are interested, these are the pin connections of the debugging test points for the RA6M5. For more details, please reference the schematic and Eagle files.</p> <ul> <li><code>TMS</code>/<code>SWDIO</code>: <code>P108</code></li> <li><code>TCK</code>/<code>SWCLK</code>: <code>P300</code></li> <li><code>TDO</code>/<code>SWO</code>: <code>P109</code></li> <li><code>TDI</code>: <code>P110</code> (POCI/<code>D17</code>) (Not a JTAG test point)</li> </ul> <p>Note</p> <p>In order to debug the RA6M5, users will need a debug probe. We recommend the J-Link debug probes from Segger. However, users should verify the supported devices before purchasing these products; for example, we had a few issues with the J-Link EDU Mini.</p> <p></p> <p>The debug pins for the RA6M5 microcontroller.</p> <p>For more details, please refer to the schematic and RA6M5 datasheet.</p>"},{"location":"print_view/#pin-functions","title":"Pin Functions","text":"<p>While there are 75 GPIO pins that are available on the RA6M5, only 44 GPIO pins are utilized with the RA6M5 Thing Plus. Additionally, of those 44 GPIO, only 21 GPIO pins are broken out into the PTH breakout pins. The breakout pins are in a Feather form-factor layout with a 0.1\" pitch spacing to make them compatible with standard headers and Feather shields/wings.</p> <p>Some of the RA6M5's peripheral capabilities may be inaccessible to users with the available 44 GPIO. However, any of the available GPIO pins can operate as digital I/O; with several of these pins featuring additional peripheral support. The pins utilized by the RA6M5 Thing Plus, along with their capabilities, are summarized in our graphical datasheet and detailed in the sections below.</p> <p> \u00a0\u00a0Download the Graphical Datasheet </p> <p></p> <p></p> <p>Board Limitations</p> <p>Users should be aware that some of the features of the RA6M5 may not be available in the Arduino IDE. This is due to either the lack of support in the Renesas-Arduino core and/or pins that are unavailable on the RA6M5 Thing Plus. For the full capabilities of the RA6M5, the Renesas FSP should be utilized.</p> <ul> <li>Only one I<sup>2</sup>C bus is defined.</li> <li>Only three UART interfaces are defined.<ul> <li><code>Serial</code> - UART (USB)</li> <li><code>Serial1</code> - <code>RX</code>/<code>TX</code> GPIO Pins</li> <li><code>Serial2</code> - DA14531MOD UART</li> </ul> </li> <li>Only one SPI bus is defined.</li> </ul> <p>Note</p> <ul> <li>All the GPIO on the RA6M5 Thing Plus are  3.3V pins</li> <li>While the datasheet specifies there are fourteen 5V-tolerant I/O pins; most of the exposed pins are not 5V-tolerant! To interface with higher voltage components, a logic-level adapter should be utilized.</li> </ul>  Digital I/O PWM Outputs Analog Inputs Analog OutputsSerial PinsSPI PinsI<sup>2</sup>C PinsInterrupts <p>Any GPIO pin on the RA6M5 Thing Plus can operate as a digital I/O (input or output). To access this functionality in the Arduino IDE, users must first declare the pin operation in their <code>setup()</code> loop, using the <code>pinMode(pin, mode)</code> function.</p> Input <p>If a pin is configured as an <code>INPUT</code>, the microcontroller can monitor if the pin's state is HIGH or LOW. As Input pins are High Impedance, it takes very little current to move the input pin from one state to another.</p> <p>Arduino</p> <p>In the Arduino IDE, this is accessed through the <code>digitalRead(pin)</code> function, which returns a <code>HIGH</code> or <code>LOW</code> value.</p> Output <p>If a pin is configured as an <code>OUTPUT</code>, the microcontroller can provide a HIGH or LOW voltage output from the pin. As Output pins are Low Impedance, they can provide a certain amount of current for other circuits.</p> <p>Arduino</p> <p>In the Arduino IDE, this is accessed through the <code>digitalWrite(pin, value)</code> function and providing a <code>HIGH</code> or <code>LOW</code> value.</p> <p>Warning</p> <p>There are electrical limitations to the amount of current that I/O pins can sink or source. For more details, check out the RA6M5 datasheet.</p> <p>Tip - Creating a PWM Output</p> <p>A digital output pin can only either be fully on HIGH or fully off LOW. By turning a digital pin's output, on and off very quickly with precise timings, the average voltage can be controlled and emulate an analog output. This method is called PWM.</p> <p>Please refer to the PWM Outputs tab for more instructions or check out this great tutorial to learn more about pulse width modulation.</p> <p>The RA6M5 supports up to four 32-bit and six 16-bit PWM (Pulse Width Modulation) channels on most of its GPIO pins. A PWM output will produce a square waveform with a variable duty cycle, a ratio of time a signal is HIGH for a given wave period. In the Arduino IDE, this feature is accessed using the <code>analogWrite(pin, value)</code> function, where the desired duty cycle is specified as an 8-bit <code>value</code>.</p> \\[ \\operatorname{Duty-Cycle}=\\frac{value_{\\operatorname{(8-bit)}}}{255_{(\\operatorname{8-bit})}} = \\frac{time_{HIGH}}{time_{Total}}=\\frac{t_{HIGH}}{t_{LOW} + t_{HIGH}} \\] <p> The GPIO pins that support PWM outputs on the RA6M5 Thing Plus. </p> Mean Value \u2260 Analog <p>PWM signals are often mistaken for analog signals; however, a PWM output is not a true analog signal. These signals can emulate an analog output, based on the average voltage output of their square waveform for a specific duration of time.</p> <p>Arduino</p> <p>By default, in the Arduino IDE, <code>analogWrite()</code> accepts an 8-bit value. To change the resolution of the PWM signal for the <code>analogWrite()</code> function, use the <code>analogWriteResolution(bits)</code> function.</p> <p>A PWM output is not a true analog signal. For a true analog output, please refer to the Analog Outputs tab.</p> <p>Tip</p> <p>To learn more about pulse width modulation (PWM), check out this great tutorial.</p> <ul> <li> <p> <p>Pulse Width Modulation</p> <p>The RA6M5 has six 12-bit ADC channels on its GPIO pins to read analog signals. This functionality is accessed in the Arduino IDE using the <code>analogRead(pin)</code> function. The available ADC pins are highlighted in the image below.</p> <p> Analog input pins on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>In the Arduino IDE, <code>analogRead()</code> returns a 10-bit value by default. To change the resolution of the value returned by the <code>analogRead()</code> function, use the <code>analogReadResolution(bits)</code> function.</p> <p>Tip</p> <p>To learn more about analog vs. digital signals, check out this great tutorial.</p> <ul> <li> <p> <p>Analog to Digital Conversion</p> <p>The RA6M5 has two 12-bit DAC channels on its GPIO pins to output analog signals. This feature is accessed in the Arduino IDE using the <code>AnalogWave</code> library from the Renesas Arduino core. The available DAC pins are highlighted in the image below.</p> <p> GPIO Pin DAC Channel <code>A0</code> <code>DAC</code> <code>A1</code> <code>DAC1</code> <p></p> <p> Analog (DAC) output pins on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>When implementing the <code>AnalogWave</code> library, users will need to link the library and create an instance of the <code>analogWave</code> class with a DAC <code>pin</code> declared for the output.</p> <pre><code>#include \"analogWave.h\" // Include the library for analog waveform generation\n\nanalogWave wave(pin);   // Create an instance of the analogWave class, using a DAC pin\n</code></pre> <p>For more information, please refer to the Analog I/O example in this guide.</p> <p>Tip</p> <p>To learn more about analog vs. digital signals, check out this great tutorial.</p> <ul> <li> <p> <p>Analog vs. Digital</p> <p>The RA6M5 supports up to ten UART ports. However, only the three UART ports are predefined in the Renesas Arduino core. In the Arduino IDE, the serial communication class is used for the USB connection (<code>Serial</code>), the labeled UART I/O pins on the board (<code>Serial1</code>), and UART connection to the DA14531MOD (<code>Serial2</code>).</p> <p> UART connections on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>By default, in the Arduino IDE, the RA6M5 Thing Plus board definition supports:</p> <p> Arduino Object GPIO Pins Connection <code>Serial</code> USB <code>Serial1</code> RX - <code>P408</code> (<code>D21</code>)TX - <code>P409</code> (<code>D20</code>) PTH Pins <code>Serial2</code> RX - <code>P601</code> (<code>D32</code>)TX - <code>P602</code> (<code>D31</code>)RTS - <code>P301</code> (<code>D33</code>)CTS - <code>P303</code> (<code>D34</code>) DA14531MODBluetooth Module <p></p> <p>To utilize serial communication on other pins, users will need to create a custom serial port object and declare which pins to access.</p> Shared UART Port <p>Users should be aware that the UART port for pins <code>D17</code>/<code>D18</code>, UART9, is also utilized for communication with the DA14531MOD Bluetooth module. Therefore, if UART9 is already being utilized for the DA14531MOD; the UART port will be unavailable on pins <code>D17</code>/<code>D18</code>.</p> <p> UART Port Arduino Object GPIO Pins Connection USB <code>Serial</code> USB UART3 <code>Serial1</code> RX - <code>P408</code> (<code>D21</code>)TX - <code>P409</code> (<code>D20</code>) PTH Pins UART9 <code>Serial2</code> RX - <code>P601</code> (<code>D32</code>)TX - <code>P602</code> (<code>D31</code>)RTS - <code>P301</code> (<code>D33</code>)CTS - <code>P303</code> (<code>D34</code>) DA14531MODBluetooth Module UART9 RX - <code>P110</code> (<code>D17</code>)TX - <code>P109</code> (<code>D18</code>) PTH Pins UART7 RX - <code>P402</code> (<code>D05</code>)TX - <code>P401</code> (<code>D15</code>)RTS - <code>P403</code> (<code>D04</code>)CTS - <code>P404</code> (<code>D03</code>) PTH Pins <p></p> <p>Tip</p> <p>To learn more about serial communication, check out this great tutorial.</p> <ul> <li> <p> <p>Serial Communication</p> <p>The RA6M5 supports up to two SPI buses. However, only a single SPI port is defined in the Renesas Arduino core. In the Arduino IDE, the SPI communication class is configured to utilize pins SCK - <code>P111</code>/<code>D19</code>, POCI - <code>P110</code>/<code>D17</code>, PICO - <code>P109</code>/<code>D18</code>, and <code>P112</code>/<code>D0</code> for its chip select.</p> New Nomenclature <p>To comply with the latest OSHW design practices, we have adopted the new SPI signal nomenclature (<code>SDO</code>/<code>SDI</code> and <code>PICO</code>/<code>POCI</code>). The terms Master and Slave are now referred to as Controller and Peripheral. The <code>MOSI</code> signal on a controller has been replaced with <code>SDO</code> or <code>PICO</code>. Please refer to this announcement on the decision to deprecate the <code>MOSI</code>/<code>MISO</code> terminology and transition to the <code>SDO</code>/<code>SDI</code> naming convention.</p> <p> SPI pins on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>By default, in the Arduino IDE, the RA6M5 Thing Plus board definition supports:</p> <p> SPI Pin GPIO POCI <code>P110</code> (<code>D17</code>) PICO <code>P109</code> (<code>D18</code>) SCK <code>P111</code> (<code>D19</code>) CS <code>P112</code> (<code>D0</code>) <p></p> <p>To utilize SPI communication on other pins, users will need to create a custom SPI object and declare which pins to access.</p> <p>Tip</p> <p>To learn more about the serial peripheral interface (SPI) protocol, check out this great tutorial.</p> <ul> <li> <p> <p>Serial Peripheral Interface (SPI)</p> <p>The RA6M5 supports up to three I<sup>2</sup>C buses. However, only a single I<sup>2</sup>C bus is defined in the Renesas Arduino core. In the Arduino IDE, the Wire class is configured to utilize the SDA - <code>P401</code>/<code>D15</code> and SCL -<code>P400</code>/<code>D16</code> pins. These pins also share the same I<sup>2</sup>C bus as the Qwiic connector and MAX17048 fuel gauge.</p> <p> I<sup>2</sup>C connections on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>By default, in the Arduino IDE, the RA6M5 Thing Plus board definition supports:</p> <p> I<sup>2</sup>C Pin GPIO SCL <code>P400</code> (<code>D16</code>) SDA <code>P401</code> (<code>D15</code>) <p></p> <p>To utilize the I<sup>2</sup>C ports on other pins, users will need to create a custom Wire object and declare which pins to access.</p> <p>Tip</p> <p>To learn more about the inter-integrated circuit (I<sup>2</sup>C) protocol, check out this great tutorial.</p> <ul> <li> <p> <p>I2C</p> What is Qwiic? <p> </p> <p>The Qwiic connect system is a solderless, polarized connection system that allows users to seamlessly daisy chain     I<sup>2</sup>C boards together. Play the video, to learn more about the Qwiic connect system or click on the banner above to learn more about Qwiic     products.</p> <p> <p> </p> <p>Features of the Qwiic System</p> No SolderingPolarized ConnectorDaisy Chain-able <p> </p> <p>Qwiic cables (4-pin JST) plug easily from development boards to sensors, shields, accessory boards and more, making easy work of setting up a new prototype.</p> <p> </p> <p>There's no need to worry about accidentally swapping the <code>SDA</code> and <code>SCL</code> wires on your breadboard. The Qwiic connector is polarized so you know you\u2019ll have it wired correctly every time.</p> <p>The part numbers for the PCB connector is <code>SM04B-SRSS</code> (Datasheet) and the mating connector on the cables is <code>SHR04V-S-B</code>; or an equivalent 1mm pitch, 4-pin JST connection.</p> <p> </p> <p>It\u2019s time to leverage the power of the I<sup>2</sup>C bus! Most Qwiic boards will have two or more connectors on them, allowing multiple devices to be connected.</p> <p>The RA6M5 provides IRQ support on several of its pins. In the Arduino IDE, interrupt requests are configured using the <code>attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)</code> function. The available IRQ pins are highlighted in the image below.</p> <p> Interrupt request pins on the RA6M5 Thing Plus. </p> <p>Arduino</p> <p>In the Arduino IDE, interrupt requests are configured using the <code>attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)</code> function, where:</p> <ul> <li><code>pin</code> - The GPIO pin</li> <li><code>ISR</code> -   The interrupt service routine to call/execute when the interrupt occurs</li> <li><code>mode</code> - Defines how the interrupt should be triggered:<ul> <li><code>LOW</code> - When the pin is LOW</li> <li><code>CHANGE</code> - Whenever the pin changes value</li> <li><code>RISING</code> - When the pin changes from LOW to HIGH</li> <li><code>FALLING</code>- When the pin changes from HIGH to LOW</li> </ul> </li> </ul> <p>Tip</p> <p>To learn more about interrupts, check out this great tutorial.</p> <ul> <li> <p> <p>Processor Interrupts with Arduino</p> <p>For more technical specifications on the I/O pins, please refer to the schematic, RA6M5 datasheet, and RA6M5 user manual.</p>"},{"location":"print_view/#da14531mod-ble-module","title":"DA14531MOD BLE Module","text":"<p>The DA14531MOD, from Renesas, provides the RA6M5 Thing Plus with Bluetooth connectivity. When actively transmitting, the DA14531MOD sips a mere 4mA; low enough to operate on a small coin-cell battery. The module is programmed with a precompiled binary of the CodeLess SDK, featuring Renesas' SmartBond\u2122 - CodeLess\u2122 AT command set. With the implementation of an AT command platform to configure the DA1431MOD's Bluetooth connectivity, source code is no longer required to be written for the module, to operate as a peripheral device.</p> <p></p> <p>The DA14531MOD BLE module on the RA6M5 Thing Plus.</p> <ul> <li>Bluetooth 5.1 system-on-chip (SoC)<ul> <li>Supports up to three connections</li> <li>32-bit Arm\u00ae Cortex\u00ae M0+<ul> <li>Clock frequency: 16 MHz</li> <li>Memory:<ul> <li>Flash: 128 Kb</li> <li>RAM: 48 Kb</li> <li>ROM: 144 Kb</li> <li>OTP: 32 Kb</li> </ul> </li> </ul> </li> </ul> </li> <li>Operating range (1.8 V - 3.6 V)<ul> <li>Receive: 2mA</li> <li>Transmit: 4mA</li> <li>Sleep: 1.8 \u00b5A</li> </ul> </li> <li>Radio<ul> <li>Transmit Power: -19 to +2.2 dBm</li> <li>Receiver Sensitivity: -93 dBm</li> </ul> </li> </ul> Debug Pins <p>The SWD pins for the DA14531MOD are available as 0.1\" test points on the board. However, users are unlikely to utilize these pins unless they wish to modify the pre-existing firmware on the DA14531MOD.</p> <p> GND SWCLK 3.3V | RST SWDIO </p> <p>Info</p> <p>In case users are interested, these are the pin connections of the SWD test points to the DA14531MOD. For more details, please reference the schematic.</p> <ul> <li><code>SWDIO</code>: <code>P0_10</code></li> <li><code>SWCLK</code>: <code>P0_2</code></li> </ul> <p>Note</p> <p>In order to debug the DA14531MOD, users will need a debug probe. We recommend the J-Link debug probes from Segger. However, users should verify the supported devices before purchasing these products; for example, we had a few issues with the J-Link EDU Mini.</p> <p> The SWD pins for the DA14531MOD on the RA6M5 Thing Plus. </p> CodeLess Firmware <p>The CodeLess\u2122 AT command allows users to easily configure the RA6M5 Thing Plus as a central or peripheral Bluetooth device. In addition, users can also potentially implement OTA updates with the CodeLess\u2122 AT commands.</p> <p>The precompiled binary from the CodeLess SDK utilized as the firmware image, on the DA14531MOD of the RA6M5 Thing Plus, is the <code>codeless_531_datapump.hex</code> (CodeLess for DA1453x datapump).</p> <p>Serial Port Setting</p> <p>The default settings of the serial port on the DA14531MOD, for AT commands:</p> <ul> <li>BaudRate : 57600</li> <li>DataBits : 8</li> <li>StopBits : 1</li> <li>Parity : None</li> <li>Flow Control : None</li> <li>Transmit Text: Append CR</li> </ul> <p>For more details, please refer to the DA14531 datasheet, and CodeLess user manual.</p>"},{"location":"print_view/#external-memory","title":"External Memory","text":""},{"location":"print_view/#qspi-flash","title":"QSPI Flash","text":"<p>The RA6M5 Thing Plus features 16MB of QSPI Flash memory, with the MX25L12833F from Macronix. The MX25L12833F QSPI Flash memory provides users with high-speed non-volatile memory to develop and execute data-driven applications. This feature is perfect for data logging, data processing, or executing memory-intensive algorithms. The QSPI Flash memory can also be used to store a firmware backup or enable software updates.</p> <p>The Flash memory is connected to the following GPIO:</p> <ul> <li>CLK: GPIO <code>P100</code> (<code>D40</code>)</li> <li>D0: GPIO <code>P102</code> (<code>D42</code>)</li> <li>D1: GPIO <code>P101</code> (<code>D43</code>)</li> <li>D2: GPIO <code>P104</code> (<code>D44</code>)</li> <li>D3: GPIO <code>P103</code> (<code>D45</code>)</li> <li>SS: GPIO <code>P501</code> (<code>D41</code>)</li> </ul> <p></p> <p>The MX25L12833F QSPI Flash memory IC on the back of the RA6M5 Thing Plus.</p> <p>For more details, please refer to the MX25L12833F datasheet, the schematic, RA6M5 datasheet, and RA6M5 user manual.</p>"},{"location":"print_view/#sd-card-socket","title":"\u00b5SD Card Socket","text":"<p>The \u00b5SD card socket is connected to the SD host interface for fast data logging. This feature is useful for data collection over extended periods and for simplifying data retrieval.</p> <p>The \u00b5SD card slot is connected to the following GPIO:</p> <ul> <li>CLK: GPIO <code>P214</code> (<code>D22</code>)</li> <li>D0: GPIO <code>P208</code> (<code>D24</code>)</li> <li>D1: GPIO <code>P410</code> (<code>D25</code>)</li> <li>D2: GPIO <code>P206</code> (<code>D26</code>)</li> <li>D3: GPIO <code>P205</code> (<code>D27</code>)</li> </ul> <p></p> <p>\u00b5SD card slot on the back of the RA6M5 Thing Plus.</p> <p>Data Corruption</p> <p>To avoid corrupting an SD card, users should disable all activity with the SD card before removing it from the RA6M5 Thing Plus.</p> <p>The FATFileSystem library built into the Renesas-Arduino core, supports \u00b5SD cards with a FAT32 file system (i.e. SD cards up to 32GB in size).</p> <ul> <li>While users may be able to use cards with a higher storage capacity, we highly advise against it. As users may experience data loss due to a corrupt file system (i.e. SD cards with a storage capacity greater than 32GB are not meant to be formatted with a FAT32 file system).</li> </ul> <p>Note</p> <p>The RA6M5 Thing Plus, offers users additional control of the SD card slot with the following pin connections:</p> <p> Pin Name Connection to RA6M5 Operation Function SDEN GPIO <code>P708</code> (<code>D35</code>) Active LOW Controls power to the SD card slot.- A LOW signal will disable power to the SD card slot CD GPIO <code>P210</code> (<code>D28</code>) Active LOW Read the pin latch, to determine if an SD card is inserted- A LOW signal will indicate an SD card is present WP GPIO <code>P414</code> (<code>D29</code>) Active LOW Read if the write protection is engaged on the SD card- A LOW signal will indicate write protection is enabled on the SD card <p></p> <p>For more details, please refer to the schematic, RA6M5 datasheet, and RA6M5 user manual.</p>"},{"location":"print_view/#i2c-bus","title":"I<sup>2</sup>C Bus","text":""},{"location":"print_view/#qwiic-connector","title":"Qwiic Connector","text":"<p>A Qwiic connector is provided for users to seamlessly integrate with SparkFun's Qwiic Ecosystem. Otherwise, users can also access the I<sup>2</sup>C bus through the PTH pins broken out on the board.</p> <p></p> <p>Qwiic connector and I<sup>2</sup>C pins on the RA6M5 Thing Plus.</p> What is Qwiic? <p> </p> <p>The Qwiic connect system is a solderless, polarized connection system that allows users to seamlessly daisy chain I<sup>2</sup>C boards together. Play the video, to learn more about the Qwiic connect system or click on the banner above to learn more about Qwiic products.</p> <p> <p> </p> <p>Features of the Qwiic System</p> No SolderingPolarized ConnectorDaisy Chain-able <p> </p> <p>Qwiic cables (4-pin JST) plug easily from development boards to sensors, shields, accessory boards and more, making easy work of setting up a new prototype.</p> <p> </p> <p>There's no need to worry about accidentally swapping the <code>SDA</code> and <code>SCL</code> wires on your breadboard. The Qwiic connector is polarized so you know you\u2019ll have it wired correctly every time.</p> <p>The part numbers for the PCB connector is <code>SM04B-SRSS</code> (Datasheet) and the mating connector on the cables is <code>SHR04V-S-B</code>; or an equivalent 1mm pitch, 4-pin JST connection.</p> <p> </p> <p>It\u2019s time to leverage the power of the I<sup>2</sup>C bus! Most Qwiic boards will have two or more connectors on them, allowing multiple devices to be connected.</p>"},{"location":"print_view/#battery-fuel-gauge","title":"Battery Fuel Gauge","text":"<p>The MAX17048 fuel gauge, from Analog Devices, measures the approximate charge/discharge rate, state of charge (SOC) (based on ModelGauge algorithm), and voltage of a connected battery. The sensor is also powered directly from a connected LiPo battery (<code>VBAT</code>).</p> <p> I<sup>2</sup>C Address 0x36 (7-bit)0x6C (write)/0x6D (read) Voltage Measurement Range: 2.5 - 5 VPrecision: \u00b17.5 mV/CellResolution 1.25 mV/Cell Current Consumption Sleep: .5 - 2 \u00b5AHibernate: 3 - 5 \u00b5AActive: 23 - 40 \u00b5A <p></p> <p>Alert Pin</p> <p>The fuel gauge features an <code>Alert</code> pin, which can be configured to trigger an interrupt (active LOW) on GPIO <code>P000</code> (<code>D39</code>) of the RA6M5 for:</p> <ul> <li>Low Charge</li> <li>1% Charge (Remaining)</li> <li>IC Reset</li> <li>Overvoltage</li> <li>Undervoltage</li> </ul> <p></p> <p>The MAX17048 fuel gauge on the RA6M5 Thing Plus.</p> <p>For more information, please refer to the MAX17048 datasheet and the schematic.</p>"},{"location":"print_view/#status-leds","title":"Status LEDs","text":"<p>There are four status LEDs on the RA6M5 Thing Plus:</p> <ul> <li><code>PWR</code> - Power (Red)<ul> <li>Illuminates once power is applied to <code>3V3</code></li> </ul> </li> <li><code>RGB</code> - WS2812 (RGB)<ul> <li>An addressable WS2812 LED</li> <li>Connected to GPIO <code>P105</code> (<code>D13</code> or <code>RGB_LED</code>) of the RA6M5</li> </ul> </li> <li><code>STAT</code> - Status (Blue)<ul> <li>Connected to the RA6M5 <code>P106</code> (<code>D14</code>/<code>LED_BUILTIN</code>) GPIO</li> </ul> </li> <li><code>CHG</code> - Battery Charge (Yellow)<ul> <li>ON - Actively charging a battery</li> <li>OFF - The charge controller is shut down or battery charging is complete</li> </ul> </li> </ul> <p></p> <p>The status indicator LEDs on the RA6M5 Thing Plus.</p>"},{"location":"print_view/#buttons","title":"Buttons","text":"<p>There are two buttons on the RA6M5 Thing Plus: RST and USRBTN</p> <p></p> <p>Buttons on the RA6M5 Thing Plus.</p> <ul> <li>USRBTN - The user button is provided as an available input for the RA6M5; it is connected to GPIO <code>P415</code> (<code>D31</code>)</li> <li>RST - The reset button allows users to reset the firmware running on the RA6M5 without interrupting the power     </li> </ul> DFU Mode <p>If users are having issues uploading code to the board, the RA6M5 can be manually forced into DFU mode. This issue, often occurs when the USB connection is busy and a reset can't be triggered on the RA6M5, to initialize the upload process. To force the RA6M5 Thing Plus into DFU mode:</p> <ol> <li>Double-tap the RST button<ul> <li>The <code>STAT</code> LED should be fading in/out very slowly</li> </ul> </li> <li>Users should now, be able to upload a new program<ul> <li>It shouldn't be necessary to select a COM port in the Arduino IDE; only the board needs to be selected</li> </ul> </li> <li>Once programming is complete, the MCU should reboot on its own. Otherwise:<ul> <li>Press the RST button</li> <li>Power cycle the board</li> </ul> </li> </ol> <p>For more details, please refer to the schematic.</p>"},{"location":"print_view/#jumpers","title":"Jumpers","text":"Never modified a jumper before? <p>Check out our Jumper Pads and PCB Traces tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <p>The five jumpers on the back of the board can be used to easily modify the hardware connections on the board.</p> <p></p> <p>The jumpers on the back of the RA6M5 Thing Plus PCB.</p> <ul> <li><code>PWR</code> - Cut this jumper to disable the red, <code>PWR</code> LED</li> <li><code>RST</code> - Cut this jumper to disconnect the reset pin of the DA14531MOD from the RA6M5 <code>P115</code>/<code>D37</code> GPIO</li> <li><code>SHLD</code> - Cut this jumper to isolate the USB-C connector shield from GND</li> <li><code>I2C</code> - Open this dual-jumper to disconnect the pull-up resistors from the <code>SDA</code> and <code>SCL</code></li> <li><code>CHG</code> - Cut this jumper to disable the yellow, <code>CHG</code> LED</li> </ul> <p>For more details, please refer to the schematic.</p>"},{"location":"print_view/#hardware-assembly","title":"Hardware Assembly","text":""},{"location":"print_view/#usb-connector_1","title":"USB Connector","text":"<p>The USB connection is utilized for programming and serial communication. Users only need to plug their RA6M5 Thing Plus into a computer using a USB-C cable.</p> <p></p> <p>The RA6M5 Thing Plus with USB-C cable attached.</p>"},{"location":"print_view/#lipo-battery","title":"LiPo Battery","text":"<p>For remote IoT applications, a LiPo battery can be connected. Additionally, users may be interested in utilizing a solar panel and USB-C cable to recharge their battery.</p> <p></p> <p>The RA6M5 Thing Plus with a battery connected.</p> <ul> <li> <p> <p>Solar Panel Charger - 10W TOL-16835</p> <li> <p> <p>USB 3.1 Cable A to C - 3 Foot TOL-14743</p> <p>Warning</p> <p>Users should avoid pulling on the wires of a battery to disconnect it from the board. Instead, it is recommended that a pair of dikes (i.e. diagonal wire cutters), pliers, or tweezers be used to pull on the JST connector housing, to avoid damaging the battery wiring.</p> <p> Using a pair of dikes to disconnect a battery. </p>"},{"location":"print_view/#breakout-pins","title":"Breakout Pins","text":"<p>The PTH pins on the RA6M5 Thing Plus are broken out into 0.1\"-spaced pins on the edges of the board.</p> New to soldering? <p>If you have never soldered before or need a quick refresher, check out our How to Solder: Through-Hole Soldering guide.</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p>"},{"location":"print_view/#headers","title":"Headers","text":"<p>Headers are versatile in their compatibility with shields, breadboards, or jumper wires.</p> <p></p> <p>Soldering headers to the RA6M5 Thing Plus.</p> Stackable Headers <p>Our Feather Stackable Header Kit is a great option for stacking on shields (w/ Feather footprint) or on a breadboard; while leaving its pins still accessible.</p> <p> Stackable headers on the RA6M5 Thing Plus. </p>"},{"location":"print_view/#hookup-wires","title":"Hookup Wires","text":"<p>For a more permanent connection, users can solder wires directly to the board.</p> <p></p> <p>Soldering wires to the RA6M5 Thing Plus.</p>"},{"location":"print_view/#sd-card-slot","title":"SD Card Slot","text":"<p>The RA6M5 Thing Plus includes a \u00b5SD card slot on the back of the board. The cardholder functions through a push/pull operation. (The card slot doesn't include a spring retention mechanism; cards are held in place through friction.)</p> <p></p> <p>Users can slide-in or pull-out a \u00b5SD card from the cardholder.</p> <p>SD Card Compatibility</p> <p>The R6M5 Thing Plus supports \u00b5SD cards with a FAT32 file system (i.e. only cards up to 32GB in size).</p>"},{"location":"print_view/#qwiic-devices","title":"Qwiic Devices","text":"<p>The Qwiic system allows users to effortlessly prototype with a Qwiic compatible I<sup>2</sup>C device without soldering. Users can attach any Qwiic compatible sensor or board, with just a Qwiic cable. (*The example below, is for demonstration purposes and is not pertinent to the board functionality or this tutorial.)</p> <p></p> <p>The BME688 environmental and VL53L1X distance Qwiic sensor boards connected to the RA6M5 Thing Plus.</p>"},{"location":"print_view/#software-overview-arduino-ide","title":"Software Overview - Arduino IDE","text":"<p>Tip</p> <p>For first-time users, who have never programmed before and are looking to use the Arduino IDE, we recommend beginning with the SparkFun Inventor's Kit (SIK), which is designed to help users get started programming with the Arduino IDE.</p> <p>Most users should already be familiar with the Arduino IDE and its use. However, for those of you who have never heard the name Arduino before, feel free to check out the Arduino website. To get started with using the Arduino IDE, check out our tutorials below:</p> <ul> <li> <p> <p>What is an Arduino?</p> <li> <p> <p>Installing the Arduino IDE</p> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p> <li> <p> <p>Installing an Arduino Library</p>"},{"location":"print_view/#arduino-core","title":"Arduino Core","text":""},{"location":"print_view/#installation","title":"Installation","text":"<p>Installing the Ported Renesas-Arduino Core</p> <p>In order to program the RA6M5 Thing Plus in the Arduino IDE, users will need to install the Arduino Renesas Portenta board definitions from the Renesas-Arduino core. However, until the RA6M5 Thing Plus is officially adopted into the Renesas-Arduino core, users need to utilize our port of the Renesas-Arduino core.</p> <ol> <li>Before users can install our ported version of the Renesas-Arduino core, they should first install the Arduino Renesas Portenta board definitions of the official Renesas-Arduino core in the Arduino IDE.<ul> <li>This will ensure that any required compilation and upload tools are installed for the Arduino core.</li> <li>In the Board Manager of the Arduino IDE, select and install the Arduino Renesas Portenta board definitions from the Renesas-Arduino core.      Installing the Renesas-Arduino core in the Arduino IDE. </li> </ul> </li> <li> <p>Once installed, users will need to locate the <code>packages</code> directory for the Arduino cores in the Arduino IDE:</p> <ul> <li> <p>Windows</p> <p>On Windows, the directory location may vary based on whether the Arduino IDE was installed for an individual user or all users:</p> <ul> <li> <p>The user's <code>AppData</code> directory (hidden folder - primary):</p> <pre><code>C:\\Users\\&lt;insert username&gt;\\AppData\\Local\\Arduino15\\packages\n</code></pre> </li> <li> <p>The user's <code>ArduinoData</code> directory (local):</p> <pre><code>C:\\Users\\&lt;insert username&gt;\\Documents\\Arduino\\hardware\n</code></pre> </li> <li> <p>The <code>Program Files</code> or <code>Program Files(x86)</code> directories:</p> <pre><code>C:\\Program Files(x86)\\Arduino IDE\n</code></pre> </li> </ul> </li> <li> <p>MacOS</p> <p>With Mac OS, users should check the <code>Applications</code> and <code>Library</code> directories:</p> <ul> <li> <p><code>Library</code> directory (primary):</p> <pre><code>~/Library/Arduino15/packages/\n</code></pre> </li> <li> <p><code>Applications</code> directory (local):</p> <pre><code>/Applications/Arduino.app/hardware\n</code></pre> </li> </ul> </li> <li> <p>Linux</p> <p>For Linux, this may be located in the following directories:</p> <ul> <li> <p>Primary:</p> <pre><code>/home/$USER/.arduino15/packages\n</code></pre> </li> <li> <p>Local:</p> <pre><code>/home/$USER/Arduino/hardware\n</code></pre> </li> </ul> Tip <p>As mentioned in Arduino's guide for installing the Arduino IDE on Linux, users may need to run the following commands in the terminal:</p> <pre><code>sudo add-apt-repository universe\nsudo apt install libfuse2\n</code></pre> <p>In order to utilize the serial terminal or recognize the board in DFU mode, users may also need to run the following commands in the terminal:</p> <pre><code>usermod -a -G dialout $USERNAME\nusermod -a -G plugdev $USERNAME\n</code></pre> <ul> <li><code>$USERNAME</code> is the login username</li> <li>After, a restart or logout is required</li> </ul> </li> </ul> </li> <li> <p>After the <code>packages</code> directory has been located, users will need to navigate to the Renesas Arduino core. It is usually located in the <code>./arduino/hardware/renesas_portenta/&lt;version number&gt;/</code> directory of the <code>packages</code> folder.</p> </li> <li>The Arduino core is followed by a directory, named after the Arduino core's release <code>&lt;version number&gt;</code>. From there, users will need to create a new directory/folder in the <code>renesas_portenta</code> directory with the <code>version number</code> bumped up.<ul> <li>For example, if the current version is <code>1.1.0</code>, users can name the new directory <code>1.2.0</code>.</li> </ul> </li> <li>Next, users will need to download and extract the files from our ported version of the Renesas-Arduino core:      \u00a0\u00a0Download our Renesas-Arduino Core (Ported) </li> <li>Once extracted, users will need to copy over the files from our ported version of the Renesas-Arduino coreinto the new directory that was created earlier:      The files extracted from our ported version of the Renesas-Arduino core. </li> <li>Once the extracted files have been copied into the new directory, users will need to install the USB drivers for the board by executing the <code>post-install.*</code> script:<ul> <li>Windows: <code>post-install.bat</code></li> <li>Mac/Linux: <code>post-install.sh</code></li> </ul> </li> </ol> <p>Info</p> <p>This information is accurate as of April 2024; however, it may become irrelevant in the future (once the RA6M5 Thing Plus is included in the Renesas-Arduino core). At which point, users may disregard this note and/or request for this information to be updated by filing an issue.</p> Do Not Use - Hardware Not Officially Supported (yet) <p>Warning</p> <p>The instructions below are invalid; theRA6M5 Thing Plus has not been officially added into the Renesas-Arduino core. In the meantime, users will need to utilize our port of the Renesas-Arduino core (see instructions above).</p> <p>In order to program the RA6M5 Thing Plus in the Arduino IDE, users will need to install the Renesas-Arduino core. The Arduino core can be found by searching for <code>Arduino Renesas Portenta Boards</code> in the Board Manager of the Arduino IDE. Once installed, the RA6M5 Thing Plus will become available in the Board Manager.</p> <pre><code>Arduino Renesas Portenta Boards\n</code></pre> <p>For users who are unfamiliar with this process, please check out our tutorial on installing an Arduino core.</p> <ul> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p> <p> Installing the Renesas-Arduino core in the Arduino IDE. </p>"},{"location":"print_view/#programming-a-board","title":"Programming a Board","text":"<p>In order to upload a sketch from the Arduino IDE onto the RA6M5 Thing Plus, users will need to select the <code>SparkFun Thing Plus RA6M5</code> from the Tools &gt; Board &gt; Arduino Renesas Portenta Boards &gt; SparkFun Thing Plus RA6M5 drop-down menu. Users will also need to select the serial port from the Tools &gt; Port drop-down menu; the port should be automatically labeled, based upon the PID/VID of board in the USB driver.</p> <p></p> <p>Selecting the <code>SparkFun Thing Plus RA6M5</code> from the Tools drop-down menu in the Arduino IDE.</p> <p></p> <p>Searching for the <code>SparkFun Thing Plus RA6M5</code> in the Select Other Board and Port menu in the Arduino IDE.</p> <p>Alternatively, in the Arduino IDE (v2.<code>x</code>.<code>x</code>), users can also search for the board and serial port in the Select Other Board and Port menu. Once the appropriate board and serial port have been selected in the Arduino IDE, users can click the \u2192 (upload) button to begin the compilation and upload process.</p> DFU Mode <p>If users are having issues uploading code to the board, the RA6M5 can be manually forced into DFU mode. This issue, often occurs when the USB connection is busy and a reset can't be triggered on the RA6M5, to initialize the upload process. To force the RA6M5 Thing Plus into DFU mode:</p> <ol> <li>Double-tap the RST button<ul> <li>The <code>STAT</code> LED should be fading in/out very slowly</li> </ul> </li> <li>Users should now, be able to upload a new program<ul> <li>It shouldn't be necessary to select a COM port in the Arduino IDE; only the board needs to be selected</li> </ul> </li> <li>Once programming is complete, the MCU should reboot on its own. Otherwise:<ul> <li>Press the RST button</li> <li>Power cycle the board</li> </ul> </li> </ol>"},{"location":"print_view/#arduino-libraries","title":"Arduino Libraries","text":"<p>In order to utilize some of the peripherals of the RA6M5 Thing Plus with the Arduino IDE, users will need to install Arduino libraries for the peripheral devices/interfaces. For users who are unfamiliar with this process, please check out our tutorial below:</p> <ul> <li> <p> <p>Installing an Arduino Library</p>"},{"location":"print_view/#max17048-fuel-gauge","title":"MAX17048 Fuel Gauge","text":"<p>While users are free to choose any Arduino library that provides support for MAX17048 fuel gauge, we recommend the SparkFun MAX1704x Arduino library; as it has been tested and verified to work with the MAX17048 on the RA6M5 Thing Plus. The SparkFun MAX1704x Fuel Gauge Arduino library can be installed from the Library Manager in the Arduino IDE by searching for:</p> <pre><code>SparkFun MAX1704x Fuel Gauge Arduino Library\n</code></pre> <p>SparkFun MAX1704x Fuel Gauge Arduino library in the library manager of the Arduino IDE.</p> <p>Manually Download the Arduino Library</p> <p>For users who would like to manually download and install the library, the <code>*.zip</code> file can be accessed from the GitHub repository or downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p>"},{"location":"print_view/#ws2812-rgb-led","title":"WS2812 RGB LED","text":"<p>While users are free to choose any Arduino library that provides support for WS2812 LEDs, we recommend the FastLED Arduino library. It has been tested and verified to work with the RGB LED on the RA6M5 Thing Plus. The FastLED Arduino library can be installed from the Library Manager in the Arduino IDE by searching for:</p> <pre><code>FastLED Arduino Library\n</code></pre> <p></p> <p>FastLED Arduino library in the library manager of the Arduino IDE.</p> <p>Manually Download the Arduino Library</p> <p>For users who would like to manually download and install the library, the <code>*.zip</code> file can be accessed from the GitHub repository or downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p> How to Define Parameters <p>While using the FastLED Arduino library, users need to define the following parameters to the WS2812 RGB LED included on the board. However, if additional LEDs are connected externally to the board, then the appropriate values should be provided for the Arduino library.</p> <code>#define NUM_LEDS 1</code> There is only one WS2812 LED on the board <code>#define DATA_PIN LED_RGB</code> Declare which pin is connected to the WS2812 LED. On the RA6M5 Thing Plus, it is defined as <code>D13</code> or <code>RGB_LED</code> in the Arduino core for GPIO <code>P105</code>. <code>#define LED_TYPE WS2812</code> Declare the LED type for the library; the RA6M5 Thing Plus only includes <code>WS2812</code> RGB LED on the board."},{"location":"print_view/#da14531mod-ble-module_1","title":"DA14531MOD BLE Module","text":"<p>While an Arduino library isn't necessary to utilize the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have created an unofficial Arduino library to help users get started. As an official library, users will need to manually download and install the library into the Arduino IDE; it will not be available through the Library Manager.</p> <p>Manually Download the Arduino Library</p> <p>To manually download and install the library, the files can be accessed from our GitHub repository or the <code>*.zip</code> can be downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p> <ul> <li> <p> <p>Installing an Arduino Library</p> <p>Tip</p> <p>In this Arduino library, there are several examples for configuring the Bluetooth connectivity of the DA14531MOD.</p> <p>However, we also include a <code>SerialPassThrough</code> example. Once programmed on the RA6M5 Thing Plus, it allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. Therefore, enabling users to experiment with the CodeLess AT commands and develop their own BLE connectivity solution.</p>"},{"location":"print_view/#software-overview-codeless-at-commands","title":"Software Overview - CodeLess AT Commands","text":"<p>The firmware provided with the DA14531MOD Bluetooth module on the RA66M5 Thing Plus, utilizes Renesas' SmartBond\u2122 - CodeLess\u2122 AT commands platform. This platform allows users to quickly get started on developing wireless IoT applications through a set of AT Commands (ASCII instructions) without having to write a single line of source code. The basic set of AT commands provides control over the Bluetooth\u00ae LE connectivity: BLE connect/disconnect, advertise, stop advertising, change roles (central/peripheral), scan for nearby devices, report BLE address, etc.</p> <p>Default Configuration</p> <p>The default serial port configuration of the DA14531MOD for AT commands:</p> <ul> <li>BaudRate : 57600</li> <li>DataBits : 8</li> <li>StopBits : 1</li> <li>Parity : None</li> <li>Flow Control : None</li> <li>Transmit Text: Append CR</li> </ul> Firmware <p>The precompiled binary from the CodeLess SDK utilized as the firmware image, on the DA14531MOD of the RA6M5 Thing Plus, is the <code>codeless_531_datapump.hex</code> (CodeLess for DA1453x datapump).</p>"},{"location":"print_view/#user-manual","title":"User Manual","text":"<p>Renesas provides documentation for the CodeLess platform:</p> <ul> <li>DA14531 TINY\u2122 Module Getting Started</li> <li>DA145<code>XX</code> CodeLess User Manual</li> </ul>"},{"location":"print_view/#arduino-library","title":"Arduino Library","text":"<p>While an Arduino library isn't necessary to utilize the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have created an unofficial Arduino library to help users get started. As an official library, users will need to manually download and install the library into the Arduino IDE; it will not be available through the Library Manager.</p> <p>Manually Download the Arduino Library</p> <p>To manually download and install the library, the files can be accessed from our GitHub repository or the <code>*.zip</code> can be downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p> <ul> <li> <p> <p>Installing an Arduino Library</p> <p>Tip</p> <p>In this Arduino library, there are several examples for configuring the Bluetooth connectivity of the DA14531MOD.</p> <p>However, we also include a <code>SerialPassThrough</code> example. Once programmed on the RA6M5 Thing Plus, it allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. Therefore, enabling users to experiment with the CodeLess AT commands and develop their own BLE connectivity solution.</p>"},{"location":"print_view/#example-serialpassthrough","title":"Example - SerialPassThrough","text":"<p>In our unofficial Arduino library, there are several examples for configuring the Bluetooth connectivity of the DA14531MOD. Also included, is a <code>SerialPassThrough</code> example. Once programmed on the RA6M5 Thing Plus, it allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. The example, utilizes the default configuration settings for the serial port on the DA14531MOD, as listed above.</p> <p>Serial Terminal Emulator</p> <p>In order to configure the DA14531MOD on the RA6M5 Thing Plus, users will need access to a serial terminal emulator on their computer. The Serial Monitor in the Arduino IDE is more than suitable for this application; however, users are also free to utilize their terminal emulator of choice. Below are a few options, outside of the Arduino IDE:</p> Serial Communication and Serial Terminal <p>Check out our hookup guides on serial communication and installing a terminal emulator:</p> <ul> <li> <p> <p>Serial Communication</p> <li> <p> <p>Serial Terminal Basics</p> WindowsMac OSLinux <p>For Windows computers, we highly recommend TeraTerm (open-source development project).</p> <p>For Mac OS, users can check out CoolTerm (freeware).</p> <p>Some Linux operating systems will already have the <code>screen</code> terminal emulator preinstalled.</p>"},{"location":"print_view/#examples-digital-io","title":"Examples - Digital I/O","text":""},{"location":"print_view/#digital-output","title":"Digital Output","text":"<p>LEDs are a perfect visual indicator for the operation of a digital output.</p>"},{"location":"print_view/#led-blink","title":"LED - Blink","text":"<p>Below, is one of the simplest built-in examples of the Arduino IDE. Users can find this sketch in the File &gt; Examples &gt; 01.Basics &gt; Blink drop-down menu. The example toggles the digital output of the GPIO pin connected to the blue, <code>STAT</code> (status) LED.</p> <p>Tip</p> <p>Users do not have to worry about modifying the sketch for the GPIO pin that is connected to the <code>STAT</code> LED. The pin is already defined in the Arduino core with the <code>LED_BUILTIN</code> variable. Therefore, no adjustments are necessary to utilize this example code.</p> <code>Blink.ino</code> <p></p>"},{"location":"print_view/#led-pwm","title":"LED - PWM","text":"<p>LEDs are also great visual indicators for PWM outputs.</p> <p>On the RA6M5 Thing Plus, the GPIO pin connected to the <code>STAT</code> LED is also capable of generating a PWM output. There are two built-in examples in the Arduino IDE for operating a PWM output on an LED. The sketches operate by oscillating the duty cycle of the PWM signal from the GPIO pin so that the LED appears to be dimming or fading.</p> <p>Tip</p> <p>Users will need to modify the sketches below, for the GPIO pin that is connected to the <code>STAT</code> LED. As mentioned in the example above, they can use the predefined <code>LED_BUILTIN</code> variable. Users will need to replace the highlighted line with the modification using the <code>LED_BUILTIN</code> variable to define the GPIO pin connected to the <code>STAT</code> LED.</p> <p><code>Fade.ino</code></p> <pre><code>    int led = 9;         // the PWM pin the LED is attached to\n    int led = LED_BUILTIN; // the PWM pin the LED is attached to\n</code></pre> <p><code>Fading.ino</code></p> <pre><code>    int ledPin = 9;  // LED connected to digital pin 9\n    int ledPin = LED_BUILTIN;  // LED connected to digital pin 14\n</code></pre> <code>Fade.ino</code><code>Fading.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; 01.Basics &gt; Fade drop-down menu.</p> <code>Fade.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 03.Analog &gt; Fading drop-down menu.</p> <p>PWM \u2260 Analog</p> <p>Although this example is listed under the 03.Analog menu, users should keep in mind that a PWM output is not a true analog signal. PWM signals can only emulate an analog output, based on the average voltage output of their square waveform.</p> <code>Fading.ino</code> <p></p>"},{"location":"print_view/#led-ws2812","title":"LED - WS2812","text":"<p>Warning</p> <p>Support for the new Renesas Arduino boards has not been officially released for the FastLED Arduino library. Users should follow the installation steps documented in the Software Overview.</p> <p>The WS2812 is an addressable RGB LED that operates with a digital signal that stacks frames of 24-bit data, per LED in a chain. We recommend that the FastLED Arduino library be utilized in the Arduino IDE, to control the RGB LED on the RA6M5 Thing Plus. Once the library is installed in the Arduino IDE, users will find several example sketches listed in the File &gt; Examples &gt; FastLED &gt; drop-down menu. We recommend the following examples for users to get started:</p> <ul> <li><code>Blink.ino</code></li> <li><code>ColorTemperature.ino</code></li> <li><code>ColorPalette.ino</code></li> </ul> <p>Tip</p> <p>Below, are a few tips for users to start working with the FastLED Arduino library. However, for more details, users should refer to the documentation for the FastLED Arduino library.</p> Define Parameters <p>When utilizing the examples in the FastLED Arduino library, users may need to define and/or modify a few parameters:</p> <pre><code>// GPIO pins connected to the LED\n#define LED_PIN      LED_RGB // (1)!\n// #define CLOCK_PIN      13 (2)\n\n// Information about the LED (strip)\n#define NUM_LEDS    1        // (3)!\n#define CHIPSET     WS2812   // (4)!\n#define COLOR_ORDER GRB      // (5)!\n\n// Define the array of leds\nCRGB leds[NUM_LEDS];\n\n// \n#define BRIGHTNESS  40       // (6)!\n</code></pre> <ol> <li>For the RA6M5 Thing Plus, users can either refer to the predefined variable <code>LED_RGB</code> or define the pin as <code>13</code> (<code>D13</code>) for the RGB LED</li> <li>A clock pin is not required for the WS2812 LED on the RA6M5 Thing Plus; comment out any mentions of it</li> <li>On the RA6M5 Thing Plus, there is only one RGB LED included on the board</li> <li>The RGB LED on the RA6M5 Thing Plus is a WS2812 LED</li> <li>The format of the color order in the WS2812's data frames is Green, Red, Blue (GRB)</li> <li> <p>Some of the examples may define an LED brightness; this should be an 8-bit value (<code>0</code>-<code>255</code>). Below, is a table of reference values for users to get started with:</p> Environment Description Value Dark Room Start to see primary colors <code>5</code> - <code>12</code> Direct Sunlight Start to see primary colors &gt; <code>60</code> Direct Sunlight Start to see color blending <code>100</code> - <code>180</code> Direct Sunlight Decent color blending &gt; <code>230</code> </li> </ol> Instantiate LED Controller <p>Most of the examples in the FastLED library predefine parameters for the LED (strip), as shown above. Later in the sketches, an instance of the LED controller is created; therefore, if users have already modified all the parameters above, no other modifications should be necessary:</p> <pre><code>FastLED.addLeds&lt;CHIPSET, LED_PIN, COLOR_ORDER&gt;(leds, NUM_LEDS);\n</code></pre> <p>Otherwise, users will need to locate where the instance of the LED controller is created and provide the required values. Users will also need to configure the LED brightness later in the sketch, if that predefined variable isn't provided either:</p> <pre><code>FastLED.addLeds&lt;WS2812, 13, GRB&gt;(leds, 1);\nFastLED.setBrightness(&lt;value&gt;);\n</code></pre> <p>The example code should still enumerate the order of the RGB color channels, required for the data frames of the LED chipset. However, users may need to modify the enumerator to <code>GRB</code>:</p> <pre><code>#define COLOR_ORDER GRB\n</code></pre> <code>Blink.ino</code><code>ColorTemperature.ino</code><code>ColorPalette.ino</code>Sunlight Test <p>Users can find this sketch in the File &gt; Examples &gt; FastLED &gt; Blink drop-down menu.</p> <code>Blink.ino</code> <pre><code>/// @file    Blink.ino\n/// @brief   Blink the first LED of an LED strip\n/// @example Blink.ino\n\n#include &lt;FastLED.h&gt;\n\n// How many leds in your strip?\n#define NUM_LEDS 1\n\n// For led chips like WS2812, which have a data line, ground, and power, you just\n// need to define DATA_PIN.  For led chipsets that are SPI based (four wires - data, clock,\n// ground, and power), like the LPD8806 define both DATA_PIN and CLOCK_PIN\n// Clock pin only needed for SPI based chipsets when not using hardware SPI\n#define DATA_PIN 3\n#define CLOCK_PIN 13\n\n// Define the array of leds\nCRGB leds[NUM_LEDS];\n\nvoid setup() { \n    // Uncomment/edit one of the following lines for your leds arrangement.\n    // ## Clockless types ##\n    FastLED.addLeds&lt;NEOPIXEL, DATA_PIN&gt;(leds, NUM_LEDS);  // GRB ordering is assumed\n    // FastLED.addLeds&lt;SM16703, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1829, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1812, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1809, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1804, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;TM1803, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;UCS1903, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;UCS1903B, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;UCS1904, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;UCS2903, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2812, DATA_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;WS2852, DATA_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;WS2812B, DATA_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;GS1903, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;SK6812, DATA_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;SK6822, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;APA106, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;PL9823, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;SK6822, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2811, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2813, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;APA104, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2811_400, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;GE8822, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;GW6205, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;GW6205_400, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;LPD1886, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;LPD1886_8BIT, DATA_PIN, RGB&gt;(leds, NUM_LEDS);\n    // ## Clocked (SPI) types ##\n    // FastLED.addLeds&lt;LPD6803, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;LPD8806, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // GRB ordering is typical\n    // FastLED.addLeds&lt;WS2801, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;WS2803, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;SM16716, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);\n    // FastLED.addLeds&lt;P9813, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // BGR ordering is typical\n    // FastLED.addLeds&lt;DOTSTAR, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // BGR ordering is typical\n    // FastLED.addLeds&lt;APA102, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // BGR ordering is typical\n    // FastLED.addLeds&lt;SK9822, DATA_PIN, CLOCK_PIN, RGB&gt;(leds, NUM_LEDS);  // BGR ordering is typical\n}\n\nvoid loop() { \n  // Turn the LED on, then pause\n  leds[0] = CRGB::Red;\n  FastLED.show();\n  delay(500);\n  // Now turn the LED off, then pause\n  leds[0] = CRGB::Black;\n  FastLED.show();\n  delay(500);\n}\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; FastLED &gt; ColorTemperature drop-down menu.</p> <code>ColorTemperature.ino</code> <pre><code>/// @file    ColorTemperature.ino\n/// @brief   Demonstrates how to use @ref ColorTemperature based color correction\n/// @example ColorTemperature.ino\n\n#include &lt;FastLED.h&gt;\n\n#define LED_PIN     3\n\n// Information about the LED strip itself\n#define NUM_LEDS    60\n#define CHIPSET     WS2811\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];\n\n#define BRIGHTNESS  128\n\n\n// FastLED provides two color-management controls:\n//   (1) color correction settings for each LED strip, and\n//   (2) master control of the overall output 'color temperature' \n//\n// THIS EXAMPLE demonstrates the second, \"color temperature\" control.\n// It shows a simple rainbow animation first with one temperature profile,\n// and a few seconds later, with a different temperature profile.\n//\n// The first pixel of the strip will show the color temperature.\n//\n// HELPFUL HINTS for \"seeing\" the effect in this demo:\n// * Don't look directly at the LED pixels.  Shine the LEDs aganst\n//   a white wall, table, or piece of paper, and look at the reflected light.\n//\n// * If you watch it for a bit, and then walk away, and then come back \n//   to it, you'll probably be able to \"see\" whether it's currently using\n//   the 'redder' or the 'bluer' temperature profile, even not counting\n//   the lowest 'indicator' pixel.\n//\n//\n// FastLED provides these pre-conigured incandescent color profiles:\n//     Candle, Tungsten40W, Tungsten100W, Halogen, CarbonArc,\n//     HighNoonSun, DirectSunlight, OvercastSky, ClearBlueSky,\n// FastLED provides these pre-configured gaseous-light color profiles:\n//     WarmFluorescent, StandardFluorescent, CoolWhiteFluorescent,\n//     FullSpectrumFluorescent, GrowLightFluorescent, BlackLightFluorescent,\n//     MercuryVapor, SodiumVapor, MetalHalide, HighPressureSodium,\n// FastLED also provides an \"Uncorrected temperature\" profile\n//    UncorrectedTemperature;\n\n#define TEMPERATURE_1 Tungsten100W\n#define TEMPERATURE_2 OvercastSky\n\n// How many seconds to show each temperature before switching\n#define DISPLAYTIME 20\n// How many seconds to show black between switches\n#define BLACKTIME   3\n\nvoid loop()\n{\n  // draw a generic, no-name rainbow\n  static uint8_t starthue = 0;\n  fill_rainbow( leds + 5, NUM_LEDS - 5, --starthue, 20);\n\n  // Choose which 'color temperature' profile to enable.\n  uint8_t secs = (millis() / 1000) % (DISPLAYTIME * 2);\n  if( secs &lt; DISPLAYTIME) {\n    FastLED.setTemperature( TEMPERATURE_1 ); // first temperature\n    leds[0] = TEMPERATURE_1; // show indicator pixel\n  } else {\n    FastLED.setTemperature( TEMPERATURE_2 ); // second temperature\n    leds[0] = TEMPERATURE_2; // show indicator pixel\n  }\n\n  // Black out the LEDs for a few secnds between color changes\n  // to let the eyes and brains adjust\n  if( (secs % DISPLAYTIME) &lt; BLACKTIME) {\n    memset8( leds, 0, NUM_LEDS * sizeof(CRGB));\n  }\n\n  FastLED.show();\n  FastLED.delay(8);\n}\n\nvoid setup() {\n  delay( 3000 ); // power-up safety delay\n  // It's important to set the color correction for your LED strip here,\n  // so that colors can be more accurately rendered through the 'temperature' profiles\n  FastLED.addLeds&lt;CHIPSET, LED_PIN, COLOR_ORDER&gt;(leds, NUM_LEDS).setCorrection( TypicalSMD5050 );\n  FastLED.setBrightness( BRIGHTNESS );\n}\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; FastLED &gt; ColorPalette drop-down menu.</p> <code>ColorPalette.ino</code> <pre><code>/// @file    ColorPalette.ino\n/// @brief   Demonstrates how to use @ref ColorPalettes\n/// @example ColorPalette.ino\n\n#include &lt;FastLED.h&gt;\n\n#define LED_PIN     5\n#define NUM_LEDS    50\n#define BRIGHTNESS  64\n#define LED_TYPE    WS2811\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];\n\n#define UPDATES_PER_SECOND 100\n\n// This example shows several ways to set up and use 'palettes' of colors\n// with FastLED.\n//\n// These compact palettes provide an easy way to re-colorize your\n// animation on the fly, quickly, easily, and with low overhead.\n//\n// USING palettes is MUCH simpler in practice than in theory, so first just\n// run this sketch, and watch the pretty lights as you then read through\n// the code.  Although this sketch has eight (or more) different color schemes,\n// the entire sketch compiles down to about 6.5K on AVR.\n//\n// FastLED provides a few pre-configured color palettes, and makes it\n// extremely easy to make up your own color schemes with palettes.\n//\n// Some notes on the more abstract 'theory and practice' of\n// FastLED compact palettes are at the bottom of this file.\n\n\n\nCRGBPalette16 currentPalette;\nTBlendType    currentBlending;\n\nextern CRGBPalette16 myRedWhiteBluePalette;\nextern const TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM;\n\n\nvoid setup() {\n    delay( 3000 ); // power-up safety delay\n    FastLED.addLeds&lt;LED_TYPE, LED_PIN, COLOR_ORDER&gt;(leds, NUM_LEDS).setCorrection( TypicalLEDStrip );\n    FastLED.setBrightness(  BRIGHTNESS );\n\n    currentPalette = RainbowColors_p;\n    currentBlending = LINEARBLEND;\n}\n\n\nvoid loop()\n{\n    ChangePalettePeriodically();\n\n    static uint8_t startIndex = 0;\n    startIndex = startIndex + 1; /* motion speed */\n\n    FillLEDsFromPaletteColors( startIndex);\n\n    FastLED.show();\n    FastLED.delay(1000 / UPDATES_PER_SECOND);\n}\n\nvoid FillLEDsFromPaletteColors( uint8_t colorIndex)\n{\n    uint8_t brightness = 255;\n\n    for( int i = 0; i &lt; NUM_LEDS; ++i) {\n        leds[i] = ColorFromPalette( currentPalette, colorIndex, brightness, currentBlending);\n        colorIndex += 3;\n    }\n}\n\n\n// There are several different palettes of colors demonstrated here.\n//\n// FastLED provides several 'preset' palettes: RainbowColors_p, RainbowStripeColors_p,\n// OceanColors_p, CloudColors_p, LavaColors_p, ForestColors_p, and PartyColors_p.\n//\n// Additionally, you can manually define your own color palettes, or you can write\n// code that creates color palettes on the fly.  All are shown here.\n\nvoid ChangePalettePeriodically()\n{\n    uint8_t secondHand = (millis() / 1000) % 60;\n    static uint8_t lastSecond = 99;\n\n    if( lastSecond != secondHand) {\n        lastSecond = secondHand;\n        if( secondHand ==  0)  { currentPalette = RainbowColors_p;         currentBlending = LINEARBLEND; }\n        if( secondHand == 10)  { currentPalette = RainbowStripeColors_p;   currentBlending = NOBLEND;  }\n        if( secondHand == 15)  { currentPalette = RainbowStripeColors_p;   currentBlending = LINEARBLEND; }\n        if( secondHand == 20)  { SetupPurpleAndGreenPalette();             currentBlending = LINEARBLEND; }\n        if( secondHand == 25)  { SetupTotallyRandomPalette();              currentBlending = LINEARBLEND; }\n        if( secondHand == 30)  { SetupBlackAndWhiteStripedPalette();       currentBlending = NOBLEND; }\n        if( secondHand == 35)  { SetupBlackAndWhiteStripedPalette();       currentBlending = LINEARBLEND; }\n        if( secondHand == 40)  { currentPalette = CloudColors_p;           currentBlending = LINEARBLEND; }\n        if( secondHand == 45)  { currentPalette = PartyColors_p;           currentBlending = LINEARBLEND; }\n        if( secondHand == 50)  { currentPalette = myRedWhiteBluePalette_p; currentBlending = NOBLEND;  }\n        if( secondHand == 55)  { currentPalette = myRedWhiteBluePalette_p; currentBlending = LINEARBLEND; }\n    }\n}\n\n// This function fills the palette with totally random colors.\nvoid SetupTotallyRandomPalette()\n{\n    for( int i = 0; i &lt; 16; ++i) {\n        currentPalette[i] = CHSV( random8(), 255, random8());\n    }\n}\n\n// This function sets up a palette of black and white stripes,\n// using code.  Since the palette is effectively an array of\n// sixteen CRGB colors, the various fill_* functions can be used\n// to set them up.\nvoid SetupBlackAndWhiteStripedPalette()\n{\n    // 'black out' all 16 palette entries...\n    fill_solid( currentPalette, 16, CRGB::Black);\n    // and set every fourth one to white.\n    currentPalette[0] = CRGB::White;\n    currentPalette[4] = CRGB::White;\n    currentPalette[8] = CRGB::White;\n    currentPalette[12] = CRGB::White;\n\n}\n\n// This function sets up a palette of purple and green stripes.\nvoid SetupPurpleAndGreenPalette()\n{\n    CRGB purple = CHSV( HUE_PURPLE, 255, 255);\n    CRGB green  = CHSV( HUE_GREEN, 255, 255);\n    CRGB black  = CRGB::Black;\n\n    currentPalette = CRGBPalette16(\n                                   green,  green,  black,  black,\n                                   purple, purple, black,  black,\n                                   green,  green,  black,  black,\n                                   purple, purple, black,  black );\n}\n\n\n// This example shows how to set up a static color palette\n// which is stored in PROGMEM (flash), which is almost always more\n// plentiful than RAM.  A static PROGMEM palette like this\n// takes up 64 bytes of flash.\nconst TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM =\n{\n    CRGB::Red,\n    CRGB::Gray, // 'white' is too bright compared to red and blue\n    CRGB::Blue,\n    CRGB::Black,\n\n    CRGB::Red,\n    CRGB::Gray,\n    CRGB::Blue,\n    CRGB::Black,\n\n    CRGB::Red,\n    CRGB::Red,\n    CRGB::Gray,\n    CRGB::Gray,\n    CRGB::Blue,\n    CRGB::Blue,\n    CRGB::Black,\n    CRGB::Black\n};\n\n\n\n// Additional notes on FastLED compact palettes:\n//\n// Normally, in computer graphics, the palette (or \"color lookup table\")\n// has 256 entries, each containing a specific 24-bit RGB color.  You can then\n// index into the color palette using a simple 8-bit (one byte) value.\n// A 256-entry color palette takes up 768 bytes of RAM, which on Arduino\n// is quite possibly \"too many\" bytes.\n//\n// FastLED does offer traditional 256-element palettes, for setups that\n// can afford the 768-byte cost in RAM.\n//\n// However, FastLED also offers a compact alternative.  FastLED offers\n// palettes that store 16 distinct entries, but can be accessed AS IF\n// they actually have 256 entries; this is accomplished by interpolating\n// between the 16 explicit entries to create fifteen intermediate palette\n// entries between each pair.\n//\n// So for example, if you set the first two explicit entries of a compact \n// palette to Green (0,255,0) and Blue (0,0,255), and then retrieved \n// the first sixteen entries from the virtual palette (of 256), you'd get\n// Green, followed by a smooth gradient from green-to-blue, and then Blue.\n</code></pre> <p>This sketch allows users to test the brightness of the WS2812 RGB LED on the RA6M5 Thing Plus in direct sunlight. The sketch implements an interrupt on the USRBTN button to increase the brightness of the LED in increments. The brightness value is then displayed on the Qwiic OLED Display, which is connected by a Qwiic cable.</p> Optional Hardware <ul> <li> <p> <p>Flexible Qwiic Cable - 50mm PRT-17260</p> <li> <p> <p>SparkFun Qwiic OLED Display (0.91 in., 128x32) LCD-24606</p> <p>The example code can be found in the GitHub repository. However, users can simply click the button to download the code or expand the box (below) to copy the code.</p> <code>RGB_sunlight.ino</code> <pre><code>/*\n  RGB_sunlight.ino\n\n  ColorPalette.ino (Original)\n\n  This example shows several ways to set up and use 'palettes' of colors\n  with FastLED.\n\n  These compact palettes provide an easy way to re-colorize your\n  animation on the fly, quickly, easily, and with low overhead.\n\n  USING palettes is MUCH simpler in practice than in theory, so first just\n  run this sketch, and watch the pretty lights as you then read through\n  the code.  Although this sketch has eight (or more) different color schemes,\n  the entire sketch compiles down to about 6.5K on AVR.\n\n  FastLED provides a few pre-configured color palettes, and makes it\n  extremely easy to make up your own color schemes with palettes.\n\n  Some notes on the more abstract 'theory and practice' of\n  FastLED compact palettes are at the bottom of this file.\n\n  Created: June 19, 2014 (Based on GitHub commit)\n  Author: kriegsman\n\n  ===========================================================================\n\n  Used to test the WS2812 RGB LED on the RA6M5 Thing Plus in direct sunlight.\n  The sketch implements an interrupt on the user button to increment the\n  brightness of the LED. The brightness value is displayed on a Qwiic OLED\n  Display (https://www.sparkfun.com/products/24606) connected by a Qwiic\n  cable.\n\n  Modified: April 11, 2024\n  By SparkFun Electronics\n  Author: Wes F\n*/\n\n\n#include &lt;FastLED.h&gt;              // http://librarymanager/All#FastLED\n#include &lt;SparkFun_Qwiic_OLED.h&gt;  // http://librarymanager/All#SparkFun_Qwiic_OLED\n\nQwiicNarrowOLED myOLED;           //\n\n#define LED_PIN 13\n#define NUM_LEDS 1\n// #define BRIGHTNESS 60\n#define LED_TYPE WS2812\n#define COLOR_ORDER GRB\nCRGB leds[NUM_LEDS];\n\n#define UPDATES_PER_SECOND 100\n\nCRGBPalette16 currentPalette;\nTBlendType currentBlending;\n\nextern CRGBPalette16 myRedWhiteBluePalette;\nextern const TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM;\n\nint BRIGHTNESS = 75;\n\nvoid setup() {\n  delay(500);  // power-up safety delay\n  FastLED.addLeds&lt;LED_TYPE, LED_PIN, COLOR_ORDER&gt;(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);\n  FastLED.setBrightness(BRIGHTNESS);\n  pinMode(31, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt(31), ChangeBrightness, HIGH);\n\n  currentPalette = RainbowColors_p;\n  currentBlending = LINEARBLEND;\n  Wire.begin();\n\n  // Initalize the OLED device and related graphics system\n  if (myOLED.begin() == false) {\n    while (true)\n      ;\n  }\n}\n\n\nvoid loop() {\n  FastLED.setBrightness(BRIGHTNESS);\n\n  ChangePalettePeriodically();\n\n  static uint8_t startIndex = 0;\n  startIndex = startIndex + 1; /* motion speed */\n\n  FillLEDsFromPaletteColors(startIndex);\n\n  FastLED.show();\n  FastLED.delay(1000 / UPDATES_PER_SECOND);\n\n  myOLED.erase();\n  myOLED.text(0, 0, \"Brightness: \" + String(BRIGHTNESS), 1);\n  myOLED.display();\n}\n\nvoid ChangeBrightness() {\n  BRIGHTNESS = BRIGHTNESS + 20;\n\n  if (BRIGHTNESS &gt; 255) {\n    BRIGHTNESS = 75;\n  }\n}\n\n\nvoid FillLEDsFromPaletteColors(uint8_t colorIndex) {\n  uint8_t brightness = 255;\n\n  for (int i = 0; i &lt; NUM_LEDS; ++i) {\n    leds[i] = ColorFromPalette(currentPalette, colorIndex, brightness, currentBlending);\n    colorIndex += 3;\n  }\n}\n\n\n// There are several different palettes of colors demonstrated here.\n//\n// FastLED provides several 'preset' palettes: RainbowColors_p, RainbowStripeColors_p,\n// OceanColors_p, CloudColors_p, LavaColors_p, ForestColors_p, and PartyColors_p.\n//\n// Additionally, you can manually define your own color palettes, or you can write\n// code that creates color palettes on the fly.  All are shown here.\n\nvoid ChangePalettePeriodically() {\n  uint8_t secondHand = (millis() / 1000) % 60;\n  static uint8_t lastSecond = 99;\n\n  if (lastSecond != secondHand) {\n    lastSecond = secondHand;\n    if (secondHand == 0) {\n      currentPalette = RainbowColors_p;\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 10) {\n      currentPalette = RainbowStripeColors_p;\n      currentBlending = NOBLEND;\n    }\n    if (secondHand == 15) {\n      currentPalette = RainbowStripeColors_p;\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 20) {\n      SetupPurpleAndGreenPalette();\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 25) {\n      SetupTotallyRandomPalette();\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 30) {\n      SetupBlackAndWhiteStripedPalette();\n      currentBlending = NOBLEND;\n    }\n    if (secondHand == 35) {\n      SetupBlackAndWhiteStripedPalette();\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 40) {\n      currentPalette = CloudColors_p;\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 45) {\n      currentPalette = PartyColors_p;\n      currentBlending = LINEARBLEND;\n    }\n    if (secondHand == 50) {\n      currentPalette = myRedWhiteBluePalette_p;\n      currentBlending = NOBLEND;\n    }\n    if (secondHand == 55) {\n      currentPalette = myRedWhiteBluePalette_p;\n      currentBlending = LINEARBLEND;\n    }\n  }\n}\n\n// This function fills the palette with totally random colors.\nvoid SetupTotallyRandomPalette() {\n  for (int i = 0; i &lt; 16; ++i) {\n    currentPalette[i] = CHSV(random8(), 255, random8());\n  }\n}\n\n// This function sets up a palette of black and white stripes,\n// using code.  Since the palette is effectively an array of\n// sixteen CRGB colors, the various fill_* functions can be used\n// to set them up.\nvoid SetupBlackAndWhiteStripedPalette() {\n  // 'black out' all 16 palette entries...\n  fill_solid(currentPalette, 16, CRGB::Black);\n  // and set every fourth one to white.\n  currentPalette[0] = CRGB::White;\n  currentPalette[4] = CRGB::White;\n  currentPalette[8] = CRGB::White;\n  currentPalette[12] = CRGB::White;\n}\n\n// This function sets up a palette of purple and green stripes.\nvoid SetupPurpleAndGreenPalette() {\n  CRGB purple = CHSV(HUE_PURPLE, 255, 255);\n  CRGB green = CHSV(HUE_GREEN, 255, 255);\n  CRGB black = CRGB::Black;\n\n  currentPalette = CRGBPalette16(\n    green, green, black, black,\n    purple, purple, black, black,\n    green, green, black, black,\n    purple, purple, black, black);\n}\n\n\n// This example shows how to set up a static color palette\n// which is stored in PROGMEM (flash), which is almost always more\n// plentiful than RAM.  A static PROGMEM palette like this\n// takes up 64 bytes of flash.\nconst TProgmemPalette16 myRedWhiteBluePalette_p PROGMEM = {\n  CRGB::Red,\n  CRGB::Gray,  // 'white' is too bright compared to red and blue\n  CRGB::Blue,\n  CRGB::Black,\n\n  CRGB::Red,\n  CRGB::Gray,\n  CRGB::Blue,\n  CRGB::Black,\n\n  CRGB::Red,\n  CRGB::Red,\n  CRGB::Gray,\n  CRGB::Gray,\n  CRGB::Blue,\n  CRGB::Blue,\n  CRGB::Black,\n  CRGB::Black\n};\n\n\n\n// Additional notes on FastLED compact palettes:\n//\n// Normally, in computer graphics, the palette (or \"color lookup table\")\n// has 256 entries, each containing a specific 24-bit RGB color.  You can then\n// index into the color palette using a simple 8-bit (one byte) value.\n// A 256-entry color palette takes up 768 bytes of RAM, which on Arduino\n// is quite possibly \"too many\" bytes.\n//\n// FastLED does offer traditional 256-element palettes, for setups that\n// can afford the 768-byte cost in RAM.\n//\n// However, FastLED also offers a compact alternative.  FastLED offers\n// palettes that store 16 distinct entries, but can be accessed AS IF\n// they actually have 256 entries; this is accomplished by interpolating\n// between the 16 explicit entries to create fifteen intermediate palette\n// entries between each pair.\n//\n// So for example, if you set the first two explicit entries of a compact\n// palette to Green (0,255,0) and Blue (0,0,255), and then retrieved\n// the first sixteen entries from the virtual palette (of 256), you'd get\n// Green, followed by a smooth gradient from green-to-blue, and then Blue.\n</code></pre> <p>  Download the Example Sketch </p> <p>For more information, please refer to the WS2812 datasheet and FastLED Arduino library.</p>"},{"location":"print_view/#digital-input","title":"Digital Input","text":"<p>Buttons are great for learning about digital inputs; and are often paired with LEDs, as a visual indicator for their operation.</p>"},{"location":"print_view/#button-usrbtn","title":"Button - USRBTN","text":"<p>On the RA6M5 Thing Plus, the USRBTN button is the perfect component for operating a digital input. There are several built-in examples in the Arduino IDE for the basic use of a button as an input device. These examples utilize a digital intput to toggle an LED and/or generate an output text on the USB serial port. Users can find these sketches in the File &gt; Examples &gt; 01.Basics &gt; DigitalReadSerial  and File &gt; Examples &gt; 02.Digital drop-down menus.</p> <ul> <li><code>DigitalReadSerial.ino</code></li> <li><code>Button.ino</code></li> <li><code>Debounce.ino</code></li> <li><code>InputPullupSerial.ino</code></li> </ul> <p>Tip</p> <p>Users will need to modify the sketches below, for the GPIO pin that is connected to the <code>STAT</code> LED and USRBTN. As previously, they can use the predefined <code>LED_BUILTIN</code> variable for the GPIO pin that is connected to the <code>STAT</code> LED. For the GPIO pin that is connected to the USRBTN, users till need to modify the pin to <code>D31</code>.</p> <p>For more details, expand the boxes below to see the modifications that required to replace the highlighted values, in order to define the GPIO pins connected to the <code>STAT</code> LEDand USRBTN</p> USRBTN <p><code>DigitalReadSerial.ino</code></p> <pre><code>int pushButton = 2;\nint pushButton = 31;\n</code></pre> <p><code>Button.ino</code> and <code>Debounce.ino</code></p> <pre><code>const int buttonPin = 2;  // the number of the pushbutton pin\nconst int buttonPin = 31;  // the number of the pushbutton pin\n</code></pre> <p><code>InputPullupSerial.ino</code></p> <pre><code>pinMode(2, INPUT_PULLUP);\npinMode(31, INPUT_PULLUP);\n\nint sensorVal = digitalRead(2);\nint sensorVal = digitalRead(31);\n</code></pre> <code>STAT</code> LED <p><code>Button.ino</code> and <code>Debounce.ino</code></p> <pre><code>const int ledPin = 13;    // the number of the LED pin\nconst int ledPin = LED_BUILTIN;    // the number of the LED pin\n</code></pre> <p><code>InputPullupSerial.ino</code></p> <pre><code>pinMode(13, OUTPUT);\ndigitalWrite(13, value);\n\npinMode(LED_BUILTIN, OUTPUT);\ndigitalWrite(LED_BUILTIN, value);\n</code></pre> <code>DigitalReadSerial.ino</code><code>Button.ino</code><code>Debounce.ino</code><code>InputPullupSerial.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; 01.Basics &gt; DigitalReadSerial drop-down menu.</p> <code>DigitalReadSerial.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 02.Digital &gt; Button drop-down menu.</p> <code>Button.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 02.Digital &gt; Debounce drop-down menu.</p> <code>Debounce.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 02.Digital &gt; InputPullupSerial drop-down menu.</p> <code>InputPullupSerial.ino</code> <p></p>"},{"location":"print_view/#interrupts","title":"Interrupts","text":"<p>The RA6M5 provides IRQ support on several of its digital input pins. This feature is great for creating an instantaneous response to a digital input, without having to wait for the MCU to complete its current task.</p> <p>Code</p> <pre><code>const byte ledPin = LED_BUILTIN;\nconst byte interruptPin = 31;\nvolatile byte state = LOW;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n  pinMode(interruptPin, INPUT_PULLUP);\n  attachInterrupt(digitalPinToInterrupt(interruptPin), blink, CHANGE);\n}\n\nvoid loop() {\n  digitalWrite(ledPin, state);\n}\n\nvoid blink() {\n  state = !state;\n}\n</code></pre> <p>Arduino</p> <p>In the Arduino IDE, interrupt requests are configured using the <code>attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)</code> function, where:</p> <ul> <li><code>pin</code> - The GPIO pin</li> <li><code>ISR</code> -   The interrupt service routine to call/execute when the interrupt occurs</li> <li><code>mode</code> - Defines how the interrupt should be triggered:<ul> <li><code>LOW</code> - When the pin is LOW</li> <li><code>CHANGE</code> - Whenever the pin changes value</li> <li><code>RISING</code> - When the pin changes from LOW to HIGH</li> <li><code>FALLING</code>- When the pin changes from HIGH to LOW</li> </ul> </li> </ul> <p>Warning</p> <p>When utilizing an interrupt on a digital GPIO, the attached interrupt service routine should be able to execute within the shortest, possible time frame. Otherwise, the suspended task could trigger various faults or errors.</p>"},{"location":"print_view/#examples-analog-io","title":"Examples - Analog I/O","text":""},{"location":"print_view/#analog-input","title":"Analog Input","text":"<p>The RA6M5 Thing Plus includes several breakout pins with access to the 12-bit ADC channels of the RA6M5. These feature is primarily used to record analog data from potentiometers and various sensors. For this example, users are free to utilize any hardware they have to connect the ADC from the <code>A0</code> GPIO pins to an analog signal. We recommend selecting a device with a product manual that provides electrical diagrams and example code; below, are a few examples:</p> Optional Hardware <ul> <li> <p> <p>SparkFun Electret Microphone Breakout BOB-12758</p> <li> <p> <p>Mini Photocell SEN-09088</p> <li> <p> <p>Trimpot 10K Ohm with Knob COM-09806</p> <li> <p> <p>Jumper Wires Premium 6\" Mixed Pack of 100 PRT-09194</p> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <p>Below, are some basic example sketches for capturing analog data from generic devices such as a potentiometer or photocell.</p> <code>AnalogReadSerial.ino</code><code>ReadAnalogVoltage.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; 01.basics &gt; AnalogReadSerial drop-down menu.</p> <code>AnalogReadSerial.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 01.basics &gt; ReadAnalogVoltage drop-down menu.</p> <code>ReadAnalogVoltage.ino</code> <p></p>"},{"location":"print_view/#analog-output","title":"Analog Output","text":""},{"location":"print_view/#analogwave-library","title":"AnalogWave Library","text":"<p>To implement the <code>AnalogWave</code> library from the Renesas Arduino core, users will need to link the library at the beginning of their sketch.</p> <pre><code>#include \"analogWave.h\" // Include the library for analog waveform generation\n</code></pre> <p>Once linked, users will need to create an instance of the <code>analogWave</code> class and declare a DAC <code>pin</code> for the output.</p> <pre><code>analogWave wave(pin);   // Create an instance of the analogWave class, using a DAC pin\n</code></pre> <p>Tip</p> <p>In the Renesas-Arduino core, <code>DAC</code> and <code>DAC1</code> are predefined variables for their corresponding GPIO pins on the RA6M5 Thing Plus.</p> <p>Code</p> <pre><code>analogWave waveA0(DAC);    // Create an instance of the analogWave class, using the DAC pin (A0)\nanalogWave waveA1(DAC1);   // Create an instance of the analogWave class, using the DAC1 pin (A1)\n</code></pre> <p>Below, are a few of the key methods available for the <code>analogWave</code> class:</p> Methods in <code>analogWave.h</code> <pre><code>/* begin the output of the waweform the frequency is the one the complete\n   set on sample are output (all samples will be output in 1 period */\nbool begin(float freq_hz);\n/* updated the frequency used */\nbool freq(float freq_hz);\n/* make the current index in the buffer to \"jump\" of the specified quantity */\nvoid offset(uint32_t o);\n/* start the generation of sample */\nvoid start();\n/* stop the genration of sample */\nvoid stop();\n/* every sample is multiplied for this factor must be a value between 0 and 1 */\nvoid amplitude(float amplitude);\n\n\nvoid sine(float freq_hz);\nvoid square(float freq_hz);\nvoid saw(float freq_hz);\n</code></pre> <p>For more information, please refer to the <code>analogWave.cpp</code> file in the <code>AnalogWave</code> library.</p> <p>When generating an output signal from the DAC of the RA6M5 Thing Plus, users will need to define the waveform's type and frequency:</p> <pre><code>int freq = 20;       // waveform frequency in Hz\n</code></pre> <pre><code>wave.sine(freq);      // Generates a sine wave with a 20Hz frequency\n</code></pre>"},{"location":"print_view/#oscilloscope","title":"Oscilloscope","text":"<p>Oscilloscopes are the perfect tool to capture the waveform of a signal output. While useful, not all users will have access to this type of test equipment. For this example, user will need connect the probe from an oscilloscope to the <code>DAC</code> (<code>A0</code>) and <code>GND</code> GPIO pins.</p> <p>Sine Wave</p> <pre><code>#include \"analogWave.h\" // Include the library for analog waveform generation\n\nanalogWave wave(DAC);   // Create an instance of the analogWave class, using the DAC pin\n\nint freq = 60;  // in hertz, change accordingly\n\nvoid setup() {\n  wave.sine(freq);       // Generate a sine wave with the initial frequency\n}\n\nvoid loop() {}\n</code></pre> <p></p> <p>A screen capture of a sine wave output from the <code>DAC</code> GPIO, which recorded on an oscilloscope.</p> Oscilloscope Adjustments <p>The DAC of the RA6M5, generates a waveform with a positive voltage. Therefore, user may need to adjust the vertical position of the probe's input channel.</p> <p>Users may also find it helpful, to set the trigger on a discretized voltage step.</p>"},{"location":"print_view/#feedback-loop","title":"Feedback Loop","text":"<p>Another method to record the signal generated by the DAC, is with a jumper (wire) and looping a output signal from the <code>DAC1</code> GPIO pin back into the <code>A2</code> GPIO pin. While an oscilloscope is very useful, this is a more practical and cost-effective alternative for users. With this example, users are free to utilize any method or hardware they have to connect the <code>DAC1</code> and <code>A2</code> GPIO pins together. However, we recommend some IC hooks for a temporary connection.</p> Optional Hardware <ul> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <li> <p> <p>IC Hook with Pigtail CAB-09741</p> <li> <p> <p>Jumper Wires Premium 6\" Mixed Pack of 100 PRT-09194</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Jumper - 2 Pin PRT-09044</p> <p>After users have jumpered the GPIO pins and uploaded the example code, they will need to open the Serial Plotter in the Arduino IDE. Once opened, the tool will begin to plot the values that are received from the serial port. It should be noted that the Serial Plotter tool is unavailable in the legacy Arduino IDE v1.<code>x</code>.<code>x</code>; and some users may need to upgrade to the new Arduino IDE v2.<code>x</code>.<code>x</code> to access this tool. Additionally, the speed and buffer of the Serial Plotter tool are limiting factors in its performance. Therefore, careful consideration should be made when adjusting the waveform frequency and the delay intervals between readings.</p> <p>Sine Wave</p> <pre><code>#include \"analogWave.h\" // Include the library for analog waveform generation\n\nanalogWave wave(DAC1);   // Create an instance of the analogWave class, using the DAC pin\n\nint freq = 1;  // in hertz, change accordingly\n\nvoid setup() {\n  Serial.begin(115200);  // Initialize serial communication at a baud rate of 115200\n  wave.sine(freq);       // Generate a sine wave with the initial frequency\n}\n\nvoid loop() {\n  // Print the updated frequency to the serial monitor\n  Serial.println(String(analogRead(A2)));\n  delay(20);      // Delay for 20ms before repeating\n}\n</code></pre> <p>Serial Plot</p> <p> Serial Plot of a sine wave output from the <code>DAC</code> GPIO, which was read by the <code>A2</code> GPIO. </p> Other Waveforms <p>Users can modify this example to generate other types of waveforms, as shown in the examples below.</p> <p> Serial Plot of a square wave generated by the <code>DAC</code> GPIO, which was recorded by the <code>A2</code> GPIO. </p> <p>Square Wave</p> <p>Users can modify the type of waveform output by the DAC. The modification below will generate a square waveform:</p> <pre><code>wave.sine(freq);\nwave.square(freq);\n</code></pre> <p> Serial Plot of a sawtooth wave generated by the <code>DAC</code> GPIO, which was recorded by the <code>A2</code> GPIO. </p> <p>Sawtooth Wave</p> <p>Users can modify the type of waveform output by the DAC. The modification below will generate a sawtooth waveform:</p> <pre><code>wave.sine(freq);\nwave.saw(freq);\n</code></pre>"},{"location":"print_view/#examples-serial-port","title":"Examples - Serial Port","text":""},{"location":"print_view/#feedback-loop_1","title":"Feedback Loop","text":"<p>The simplest way to test the UART interface is with just a jumper (wire) and looping transmission data from the TX GPIO pin; back into the RX GPIO pin. For this example, users are free to utilize any method or hardware they have to connect the RX and TX GPIO pins together. However, we recommend some IC hooks for a temporary connection.</p> Optional Hardware <ul> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <li> <p> <p>IC Hook with Pigtail CAB-09741</p> <li> <p> <p>Jumper Wires Premium 6\" Mixed Pack of 100 PRT-09194</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Jumper - 2 Pin PRT-09044</p> <p>After users have jumpered the GPIO pins and uploaded the example code, they will need to open the Serial Monitor in the Arduino IDE. Any entries that are sent through the message textbox, should be re-transmitted back into the Serial Monitor by the jumpered GPIO pins.</p> <code>MultiSerial.ino</code><code>SerialPassthrough.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; 04.Communication &gt; MultiSerial drop-down menu.</p> <code>MultiSerial.ino</code> <p></p> <p>Users can find this sketch in the File &gt; Examples &gt; 04.Communication &gt; SerialPassthrough drop-down menu.</p> <code>SerialPassthrough.ino</code> <p></p>"},{"location":"print_view/#peripheral-device","title":"Peripheral Device","text":""},{"location":"print_view/#gnssgps-module","title":"GNSS/GPS Module","text":"<p>For GNSS receivers, we recommend that the TinyGPSPlus Arduino library be utilized to parse the NMEA sentences from the module. Once the library is installed in the Arduino IDE, users will find several example sketches listed in the File &gt; Examples &gt; TinyGPSPlus &gt; drop-down menu. We recommend the following examples for getting started with a GNSS receiver:</p> <ul> <li><code>DeviceExample.ino</code></li> <li><code>FullExample.ino</code></li> </ul> <p>Tip</p> <p>Below, are a few tips for users to start working with the TinyGPSPlus Arduino library. However, for more details, users should refer to the documentation for the TinyGPSPlus Arduino library.</p> Define Parameters <p>When utilizing the examples in the TinyGPSPlus Arduino library, users may need to define and/or modify a few parameters. The baud rate for the GNSS receiver should be configured based upon the information presented in the datasheet.</p> <p>For the RA6M5 Thing Plus, users have two options for configuring the serial port on the <code>RX</code> and <code>TX</code> GPIO pins:</p> <ul> <li>In the examples, they can continue to implement the SoftwareSerial library and update the values of <code>RX</code> and <code>TX</code> GPIO pins in the code</li> <li>Otherwise, users can remove the SoftwareSerial library implementation; and replace it with <code>Serial1</code> UART port</li> </ul> <ul> <li> <p>Baud Rate</p> <p>Check the datasheet or product manual for the default baud rate of the GPS receiver; if necessary, replace the value in the example:</p> <pre><code>static const uint32_t GPSBaud = 4800;\nstatic const uint32_t GPSBaud = 115200;\n</code></pre> <p>In some cases, the datasheet may be inaccurate or the module's configuration was previously changed. In which case, the most common rates to try are:</p> <ul> <li><code>4800</code> bps</li> <li><code>9600</code> bps</li> <li><code>115200</code> bps</li> </ul> </li> <li> <p>Update GPIO Pins</p> <p>Replace the values for the <code>RX</code> (<code>D20</code>) and <code>TX</code> (<code>D21</code>) GPIO pins for those on the RA6M5 Thing Plus:</p> <pre><code>static const int RXPin = 4, TXPin = 3;\nstatic const int RXPin = 20, TXPin = 21;\n</code></pre> </li> <li> <p>Utilize <code>Serial1</code> Port</p> <p>Remove the implementation of the SoftwareSerial library implementation</p> <pre><code>#include &lt;SoftwareSerial.h&gt;\n\nstatic const int RXPin = 4, TXPin = 3;\nSoftwareSerial ss(RXPin, TXPin);\n</code></pre> <p>Then, replace the SoftwareSerial objects with <code>Serial1</code> class</p> <pre><code>void setup()\n{\n    Serial.begin(115200);\n    ssSerial1.begin(GPSBaud);\n\nvoid loop()\n{\n    while (ssSerial1.available() &gt; 0)\n        if (gps.encode(ssSerial1.read()))\n            displayInfo();\n</code></pre> </li> </ul> Hardware Assembly <p>Connecting a GNSS receiver to a microcontroller is relatively straight forward. Users must provide power to the module through the <code>PWR</code>/<code>VCC</code> and <code>GND</code> pins on the board. Additionally, the <code>TX</code> pin from the GNSS receiver, should be connected to the <code>RX</code> pin of the microcontroller. This will allow the module to transmit the NMEA sentences to the microcontroller.</p> <p> Thing Plus GPS Module <code>3V3</code> <code>VCC</code> or <code>PWR</code> <code>GND</code> <code>GND</code> <code>RX</code> (<code>D21</code>) <code>TX</code> <code>TX</code> (<code>D20</code>) --- <p></p> Satellite Fix <p>As with all GNSS receivers, the module's antenna must have a clear view of the sky (it can't operate inside a building) to receive signal from the GNSS constellation. In addition, the GNSS receiver must acquire a fix on its position, before it starts transmitting complete NMEA sentences (with all the data).</p> Optional Hardware <ul> <li> <p> <p>SparkFun GPS Breakout - XA1110 (Qwiic) GPS-14414</p> <li> <p> <p>GPS Module - GP1818MK (56 Channel) GPS-19166</p> <li> <p> <p>IC Hook with Pigtail CAB-09741</p> <li> <p> <p>Hook-Up Wire - Assortment (Stranded, 22 AWG) PRT-11375</p> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>PINECIL Soldering Iron Kit KIT-24063</p> <p>After users have connected their GNSSS module and uploaded the example code, they will need to open the Serial Monitor in the Arduino IDE to view the data. Users should begin to see the data parsed by the TinyGPSPlus Arduino library, from the NMEA sentences transmitted from the GNSS receiver.</p> <code>DeviceExample.ino</code><code>FullExample.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; TinyGPSPlus &gt; DeviceExample drop-down menu.</p> <code>DeviceExample.ino</code> <pre><code>#include &lt;TinyGPSPlus.h&gt;\n#include &lt;SoftwareSerial.h&gt;\n/*\n   This sample sketch demonstrates the normal use of a TinyGPSPlus (TinyGPSPlus) object.\n   It requires the use of SoftwareSerial, and assumes that you have a\n   4800-baud serial GPS device hooked up on pins 4(rx) and 3(tx).\n*/\nstatic const int RXPin = 4, TXPin = 3;\nstatic const uint32_t GPSBaud = 4800;\n\n// The TinyGPSPlus object\nTinyGPSPlus gps;\n\n// The serial connection to the GPS device\nSoftwareSerial ss(RXPin, TXPin);\n\nvoid setup()\n{\n  Serial.begin(115200);\n  ss.begin(GPSBaud);\n\n  Serial.println(F(\"DeviceExample.ino\"));\n  Serial.println(F(\"A simple demonstration of TinyGPSPlus with an attached GPS module\"));\n  Serial.print(F(\"Testing TinyGPSPlus library v. \")); Serial.println(TinyGPSPlus::libraryVersion());\n  Serial.println(F(\"by Mikal Hart\"));\n  Serial.println();\n}\n\nvoid loop()\n{\n  // This sketch displays information every time a new sentence is correctly encoded.\n  while (ss.available() &gt; 0)\n    if (gps.encode(ss.read()))\n      displayInfo();\n\n  if (millis() &gt; 5000 &amp;&amp; gps.charsProcessed() &lt; 10)\n  {\n    Serial.println(F(\"No GPS detected: check wiring.\"));\n    while(true);\n  }\n}\n\nvoid displayInfo()\n{\n  Serial.print(F(\"Location: \")); \n  if (gps.location.isValid())\n  {\n    Serial.print(gps.location.lat(), 6);\n    Serial.print(F(\",\"));\n    Serial.print(gps.location.lng(), 6);\n  }\n  else\n  {\n    Serial.print(F(\"INVALID\"));\n  }\n\n  Serial.print(F(\"  Date/Time: \"));\n  if (gps.date.isValid())\n  {\n    Serial.print(gps.date.month());\n    Serial.print(F(\"/\"));\n    Serial.print(gps.date.day());\n    Serial.print(F(\"/\"));\n    Serial.print(gps.date.year());\n  }\n  else\n  {\n    Serial.print(F(\"INVALID\"));\n  }\n\n  Serial.print(F(\" \"));\n  if (gps.time.isValid())\n  {\n    if (gps.time.hour() &lt; 10) Serial.print(F(\"0\"));\n    Serial.print(gps.time.hour());\n    Serial.print(F(\":\"));\n    if (gps.time.minute() &lt; 10) Serial.print(F(\"0\"));\n    Serial.print(gps.time.minute());\n    Serial.print(F(\":\"));\n    if (gps.time.second() &lt; 10) Serial.print(F(\"0\"));\n    Serial.print(gps.time.second());\n    Serial.print(F(\".\"));\n    if (gps.time.centisecond() &lt; 10) Serial.print(F(\"0\"));\n    Serial.print(gps.time.centisecond());\n  }\n  else\n  {\n    Serial.print(F(\"INVALID\"));\n  }\n\n  Serial.println();\n}\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; TinyGPSPlus* &gt; FullExample drop-down menu.</p> <code>FullExample.ino</code> <pre><code>#include &lt;TinyGPSPlus.h&gt;\n#include &lt;SoftwareSerial.h&gt;\n/*\n   This sample code demonstrates the normal use of a TinyGPSPlus (TinyGPSPlus) object.\n   It requires the use of SoftwareSerial, and assumes that you have a\n   4800-baud serial GPS device hooked up on pins 4(rx) and 3(tx).\n*/\nstatic const int RXPin = 4, TXPin = 3;\nstatic const uint32_t GPSBaud = 4800;\n\n// The TinyGPSPlus object\nTinyGPSPlus gps;\n\n// The serial connection to the GPS device\nSoftwareSerial ss(RXPin, TXPin);\n\nvoid setup()\n{\n  Serial.begin(115200);\n  ss.begin(GPSBaud);\n\n  Serial.println(F(\"FullExample.ino\"));\n  Serial.println(F(\"An extensive example of many interesting TinyGPSPlus features\"));\n  Serial.print(F(\"Testing TinyGPSPlus library v. \")); Serial.println(TinyGPSPlus::libraryVersion());\n  Serial.println(F(\"by Mikal Hart\"));\n  Serial.println();\n  Serial.println(F(\"Sats HDOP  Latitude   Longitude   Fix  Date       Time     Date Alt    Course Speed Card  Distance Course Card  Chars Sentences Checksum\"));\n  Serial.println(F(\"           (deg)      (deg)       Age                      Age  (m)    --- from GPS ----  ---- to London  ----  RX    RX        Fail\"));\n  Serial.println(F(\"----------------------------------------------------------------------------------------------------------------------------------------\"));\n}\n\nvoid loop()\n{\n  static const double LONDON_LAT = 51.508131, LONDON_LON = -0.128002;\n\n  printInt(gps.satellites.value(), gps.satellites.isValid(), 5);\n  printFloat(gps.hdop.hdop(), gps.hdop.isValid(), 6, 1);\n  printFloat(gps.location.lat(), gps.location.isValid(), 11, 6);\n  printFloat(gps.location.lng(), gps.location.isValid(), 12, 6);\n  printInt(gps.location.age(), gps.location.isValid(), 5);\n  printDateTime(gps.date, gps.time);\n  printFloat(gps.altitude.meters(), gps.altitude.isValid(), 7, 2);\n  printFloat(gps.course.deg(), gps.course.isValid(), 7, 2);\n  printFloat(gps.speed.kmph(), gps.speed.isValid(), 6, 2);\n  printStr(gps.course.isValid() ? TinyGPSPlus::cardinal(gps.course.deg()) : \"*** \", 6);\n\n  unsigned long distanceKmToLondon =\n    (unsigned long)TinyGPSPlus::distanceBetween(\n      gps.location.lat(),\n      gps.location.lng(),\n      LONDON_LAT, \n      LONDON_LON) / 1000;\n  printInt(distanceKmToLondon, gps.location.isValid(), 9);\n\n  double courseToLondon =\n    TinyGPSPlus::courseTo(\n      gps.location.lat(),\n      gps.location.lng(),\n      LONDON_LAT, \n      LONDON_LON);\n\n  printFloat(courseToLondon, gps.location.isValid(), 7, 2);\n\n  const char *cardinalToLondon = TinyGPSPlus::cardinal(courseToLondon);\n\n  printStr(gps.location.isValid() ? cardinalToLondon : \"*** \", 6);\n\n  printInt(gps.charsProcessed(), true, 6);\n  printInt(gps.sentencesWithFix(), true, 10);\n  printInt(gps.failedChecksum(), true, 9);\n  Serial.println();\n\n  smartDelay(1000);\n\n  if (millis() &gt; 5000 &amp;&amp; gps.charsProcessed() &lt; 10)\n    Serial.println(F(\"No GPS data received: check wiring\"));\n}\n\n// This custom version of delay() ensures that the gps object\n// is being \"fed\".\nstatic void smartDelay(unsigned long ms)\n{\n  unsigned long start = millis();\n  do \n  {\n    while (ss.available())\n      gps.encode(ss.read());\n  } while (millis() - start &lt; ms);\n}\n\nstatic void printFloat(float val, bool valid, int len, int prec)\n{\n  if (!valid)\n  {\n    while (len-- &gt; 1)\n      Serial.print('*');\n    Serial.print(' ');\n  }\n  else\n  {\n    Serial.print(val, prec);\n    int vi = abs((int)val);\n    int flen = prec + (val &lt; 0.0 ? 2 : 1); // . and -\n    flen += vi &gt;= 1000 ? 4 : vi &gt;= 100 ? 3 : vi &gt;= 10 ? 2 : 1;\n    for (int i=flen; i&lt;len; ++i)\n      Serial.print(' ');\n  }\n  smartDelay(0);\n}\n\nstatic void printInt(unsigned long val, bool valid, int len)\n{\n  char sz[32] = \"*****************\";\n  if (valid)\n    sprintf(sz, \"%ld\", val);\n  sz[len] = 0;\n  for (int i=strlen(sz); i&lt;len; ++i)\n    sz[i] = ' ';\n  if (len &gt; 0) \n    sz[len-1] = ' ';\n  Serial.print(sz);\n  smartDelay(0);\n}\n\nstatic void printDateTime(TinyGPSDate &amp;d, TinyGPSTime &amp;t)\n{\n  if (!d.isValid())\n  {\n    Serial.print(F(\"********** \"));\n  }\n  else\n  {\n    char sz[32];\n    sprintf(sz, \"%02d/%02d/%02d \", d.month(), d.day(), d.year());\n    Serial.print(sz);\n  }\n\n  if (!t.isValid())\n  {\n    Serial.print(F(\"******** \"));\n  }\n  else\n  {\n    char sz[32];\n    sprintf(sz, \"%02d:%02d:%02d \", t.hour(), t.minute(), t.second());\n    Serial.print(sz);\n  }\n\n  printInt(d.age(), d.isValid(), 5);\n  smartDelay(0);\n}\n\nstatic void printStr(const char *str, int len)\n{\n  int slen = strlen(str);\n  for (int i=0; i&lt;len; ++i)\n    Serial.print(i&lt;slen ? str[i] : ' ');\n  smartDelay(0);\n}\n</code></pre>"},{"location":"print_view/#da14531mod","title":"DA14531MOD","text":"<p>For the DA14531MOD, users can interface with the module through the <code>Serial2</code> UART port of the RA6M5 Thing Plus. The firmware on the module implements the CodeLess AT command platform. This means, users can easily configure the BLE connectivity of the board with a few AT commands. For more details, please refer to the section with the DA14531MOD examples.</p>"},{"location":"print_view/#examples-spi-bus","title":"Examples - SPI Bus","text":""},{"location":"print_view/#feedback-loop_2","title":"Feedback Loop","text":"<p>The simplest way to test the SPI interface is with just a jumper (wire) and looping a data transmission from the PICO GPIO pin; back into the POCI GPIO pin. For this example, users are free to utilize any method or hardware they have to connect the PICO and POCI GPIO pins together. However, we recommend some IC hooks for a temporary connection.</p> Optional Hardware <ul> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <li> <p> <p>IC Hook with Pigtail CAB-09741</p> <li> <p> <p>Jumper Wires Premium 6\" Mixed Pack of 100 PRT-09194</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Jumper - 2 Pin PRT-09044</p> <code>SPI_Loopback.ino</code> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;cstdint&gt;\n\nvoid setup()\n{\n    Serial.begin();\n    while(!Serial) {delay(100);};\n\n    Serial.println(\"SPI loopback test.\");\n\n    SPI.begin();\n    SPI.beginTransaction(SPISettings(4000000, MSBFIRST, SPI_MODE1));\n\n    testByteTransfer();\n\n    testWordTransfer();\n\n    testArrayTransfer();\n\n    SPI.endTransaction();\n    SPI.end();\n}\n\nvoid loop()\n{\n\n}\n\nvoid testByteTransfer(void)\n{\n    const uint8_t testByte = 0b10100011;\n\n    Serial.print(\"Sending: 0b\");\n    Serial.println(testByte, BIN);\n\n    uint8_t recvByte = SPI.transfer(testByte);\n\n    Serial.print(\"Received: 0b\");\n    Serial.println(recvByte, BIN);\n\n    if (recvByte == testByte)\n    {\n        Serial.println(\"Byte loopback successful.\");\n    }\n    else\n    {\n        Serial.println(\"Byte loopback unsuccessful. Please check logs.\");\n    }\n}\n\nvoid testWordTransfer(void)\n{\n    const uint8_t testWord = 0b1111000010100101;\n\n    Serial.print(\"Sending: 0b\");\n    Serial.println(testWord, BIN);\n\n    uint8_t recvWord = SPI.transfer(testWord);\n\n    Serial.print(\"Received: 0b\");\n    Serial.println(recvWord, BIN);\n\n    if (recvWord == testWord)\n    {\n        Serial.println(\"Word loopback successful.\");\n    }\n    else\n    {\n        Serial.println(\"Word loopback unsuccessful. Please check logs.\");\n    }\n}\n\nvoid testArrayTransfer(void)\n{\n    const uint8_t numel = 18;\n\n    uint8_t *data = (uint8_t*)malloc(numel);\n\n    uint8_t *data_ptr = data;\n\n    for(uint8_t i = 0; i &lt; numel; ++i)\n    {\n        *data_ptr++ = i;\n    }\n\n    SPI.transfer(data, numel);\n\n    data_ptr = data;\n\n    /* 0 is inital expected results, 255 is when pin is open\n     so initialse result variable to 111 to make it clear the value has changed. */\n    uint8_t result = 111;\n\n    Serial.println();\n    Serial.println(\"Multiple byte transfer test\");\n    Serial.println(\"element value result\");\n\n    for(uint8_t i = 0; i&lt; numel; ++i)\n    {\n        result = *data_ptr++;\n        Serial.print(i);\n        Serial.print(\"\\t\");\n        Serial.print(result);\n        Serial.print(\"\\t\");\n\n        if(result == i)\n        {\n            Serial.println(\"pass\");\n        }\n        else\n        {\n            Serial.println(\"fail\");\n        }\n    }\n}\n</code></pre>"},{"location":"print_view/#peripheral-device_1","title":"Peripheral Device","text":"<p>A more direct method for testing the SPI interface is with an actual SPI device.</p>"},{"location":"print_view/#bme688-environmental-sensor","title":"BME688 Environmental Sensor","text":"<p>Users are free to utilize any hardware they already have; however, we recommend the BME688 environmental sensor, below. Its SPI pins are broken out on the edge of the board and can be easily connected to the RA6M5 Thing Plus. In addition, a hookup guide and Arduino library for the sensor are available.</p> Optional Hardware <ul> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>IC Hook Test Leads CAB-00501</p> <li> <p> <p>Hook-Up Wire - Assortment (Stranded, 22 AWG) PRT-11375</p> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>PINECIL Soldering Iron Kit KIT-24063</p> <li> <p> <p>Hobby Knife TOL-09200</p> Install Arduino Library <p>Users will need to install the Bosch BME68x Arduino library for the sensor. In the Arduino IDE, users can install it by searching for <code>BME68x Sensor Library</code>, in the Library Manager:</p> <pre><code>BME68x Sensor Library\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; BME68x Sensor library &gt; forced_mode drop-down menu. For more details on utilizing the BME68x breakout board, please refer to our hookup guide for the sensor.</p> <code>forced_mode.ino</code> <pre><code>/**\n * Copyright (C) 2021 Bosch Sensortec GmbH\n *\n * SPDX-License-Identifier: BSD-3-Clause\n * \n */\n\n#include \"Arduino.h\"\n#include \"bme68xLibrary.h\"\n\n#ifndef PIN_CS\n#define PIN_CS SS\n#endif\n\nBme68x bme;\n\n/**\n * @brief Initializes the sensor and hardware settings\n */\nvoid setup(void)\n{\n    SPI.begin();\n    Serial.begin(115200);\n\n    while (!Serial)\n        delay(10);\n\n    /* initializes the sensor based on SPI library */\n    bme.begin(PIN_CS, SPI);\n\n    if(bme.checkStatus())\n    {\n        if (bme.checkStatus() == BME68X_ERROR)\n        {\n            Serial.println(\"Sensor error:\" + bme.statusString());\n            return;\n        }\n        else if (bme.checkStatus() == BME68X_WARNING)\n        {\n            Serial.println(\"Sensor Warning:\" + bme.statusString());\n        }\n    }\n\n    /* Set the default configuration for temperature, pressure and humidity */\n    bme.setTPH();\n\n    /* Set the heater configuration to 300 deg C for 100ms for Forced mode */\n    bme.setHeaterProf(300, 100);\n\n    Serial.println(\"TimeStamp(ms), Temperature(deg C), Pressure(Pa), Humidity(%), Gas resistance(ohm), Status\");\n}\n\nvoid loop(void)\n{\n    bme68xData data;\n\n    bme.setOpMode(BME68X_FORCED_MODE);\n    delayMicroseconds(bme.getMeasDur());\n\n    if (bme.fetchData())\n    {\n        bme.getData(data);\n        Serial.print(String(millis()) + \", \");\n        Serial.print(String(data.temperature) + \", \");\n        Serial.print(String(data.pressure) + \", \");\n        Serial.print(String(data.humidity) + \", \");\n        Serial.print(String(data.gas_resistance) + \", \");\n        Serial.println(data.status, HEX);\n    }\n}\n</code></pre>"},{"location":"print_view/#examples-i2c-bus","title":"Examples - I<sup>2</sup>C Bus","text":""},{"location":"print_view/#device-scan","title":"Device Scan","text":"<p>This sketch allows users to scan for devices connected to the primary I<sup>2</sup>C bus of the RAM5 Thing Plus. The example code can be found in the GitHub repository. However, users can also simply click on the button (below), to download the code; or expand the box (below), to copy the code.</p> <code>i2c_scanner.ino</code> <pre><code>// --------------------------------------\n// i2c_scanner\n//\n// Modified from https://playground.arduino.cc/Main/I2cScanner/\n// --------------------------------------\n\n#include &lt;Wire.h&gt;\n\n// Set I2C bus to use: Wire, Wire1, etc.\n#define WIRE Wire\n\nint toggle = 0;\n\nvoid setup() {\n  WIRE.begin();\n\n  pinMode(8, OUTPUT);\n\n  Serial.begin(115200);\n  while (!Serial)\n    delay(10);\n  Serial.println(\"\\nI2C Scanner\");\n}\n\n\nvoid loop() {\n  if (toggle == 0) {\n    digitalWrite(8, HIGH);\n    toggle = 1;\n  } else {\n    digitalWrite(8, LOW);\n    toggle = 0;\n  }\n\n\n  byte error, address;\n  int nDevices;\n\n  Serial.println(\"Scanning...\");\n\n  nDevices = 0;\n  for (address = 1; address &lt; 127; address++) {\n    // The i2c_scanner uses the return value of\n    // the Write.endTransmisstion to see if\n    // a device did acknowledge to the address.\n    WIRE.beginTransmission(address);\n    error = WIRE.endTransmission();\n\n    if (error == 0) {\n      Serial.print(\"I2C device found at address 0x\");\n      if (address &lt; 16)\n        Serial.print(\"0\");\n      Serial.print(address, HEX);\n      Serial.println(\"  !\");\n\n      nDevices++;\n    } else if (error == 4) {\n      Serial.print(\"Unknown error at address 0x\");\n      if (address &lt; 16)\n        Serial.print(\"0\");\n      Serial.println(address, HEX);\n    }\n  }\n  if (nDevices == 0)\n    Serial.println(\"No I2C devices found\\n\");\n  else\n    Serial.println(\"done\\n\");\n\n  delay(700);  // wait 5 seconds for next scan\n}\n</code></pre> <p>  Download the Example Sketch </p>"},{"location":"print_view/#peripheral-devices","title":"Peripheral Devices","text":"<p>The RA6M5 Thing Plus features a Qwiic connector to seamlessly integrate with devices from SparkFun's Qwiic Ecosystem. While users are free to utilize any I<sup>2</sup>C device, we recommend the Qwiic devices from our catalog.</p> Optional Hardware <ul> <li> <p> <p>SparkFun Qwiic Cable Kit KIT-15081</p> <li> <p> <p>Qwiic Cable - Grove Adapter (100mm) PRT-15109</p> <li> <p> <p>SparkFun Qwiic OLED - (1.3in., 128x64) LCD-23453</p> <li> <p> <p>SparkFun GPS Breakout - XA1110 (Qwiic) GPS-14414</p> <li> <p> <p>SparkFun Qwiic Joystick COM-15168</p> <li> <p> <p>SparkFun Qwiic Mux Breakout - 8 Channel (TCA9548A) BOB-16784</p> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>SparkFun Qwiic Mini ToF Imager - VL53L5CX SEN-19013</p>"},{"location":"print_view/#max17048-fuel-gauge_1","title":"MAX17048 Fuel Gauge","text":"<p>The MAX17048 fuel gauge measures the approximate charge/discharge rate, state of charge, and voltage of a connected LiPo battery. We recommend the SparkFun MAX1704x Arduino library be utilized in the Arduino IDE, to connect to the MAX17048 on the RA6M5 Thing Plus. Once the library is installed in the Arduino IDE, users will find several example sketches listed in the File &gt; Examples &gt; SparkFun MAX1704x Fuel Gauge Arduino Library &gt; drop-down menu. We recommend the following examples for users:</p> <ul> <li><code>Example1_Simple.ino</code></li> <li><code>Example4_MAX17048_KitchenSink.ino</code></li> </ul> Optional Hardware <ul> <li> <p> <p>Lithium Ion Battery - 2Ah PRT-13855</p> <li> <p> <p>Lithium Ion Battery - 400mAh PRT-13851</p> <li> <p> <p>Lithium Ion Battery - 1Ah PRT-13813</p> <li> <p> <p>Lithium Ion Battery - 110mAh PRT-13853</p> <code>Example1_Simple.ino</code><code>Example4_MAX17048_KitchenSink.ino</code> <p>Users can find this sketch in the File &gt; Examples &gt; SparkFun MAX1704x Fuel Gauge Arduino Library &gt; Example1_Simple drop-down menu.</p> <code>Example1_Simple.ino</code> <pre><code>/******************************************************************************\nExample1_Simple\nBy: Paul Clark\nDate: October 23rd 2020\n\nBased extensively on:\nMAX17043_Simple_Serial.cpp\nSparkFun MAX17043 Example Code\nJim Lindblom @ SparkFun Electronics\nOriginal Creation Date: June 22, 2015\n\nThis file demonstrates the simple API of the SparkFun MAX17043 Arduino library.\n\nThis example will print the gauge's voltage and state-of-charge (SOC) readings\nto Serial (115200 baud)\n\nThis code is released under the MIT license.\n\nDistributed as-is; no warranty is given.\n******************************************************************************/\n\n#include &lt;Wire.h&gt; // Needed for I2C\n\n#include &lt;SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h&gt; // Click here to get the library: http://librarymanager/All#SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library\n\nSFE_MAX1704X lipo; // Defaults to the MAX17043\n\n//SFE_MAX1704X lipo(MAX1704X_MAX17043); // Create a MAX17043\n//SFE_MAX1704X lipo(MAX1704X_MAX17044); // Create a MAX17044\n//SFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n//SFE_MAX1704X lipo(MAX1704X_MAX17049); // Create a MAX17049\n\ndouble voltage = 0; // Variable to keep track of LiPo voltage\ndouble soc = 0; // Variable to keep track of LiPo state-of-charge (SOC)\nbool alert; // Variable to keep track of whether alert has been triggered\n\nvoid setup()\n{\n    Serial.begin(115200); // Start serial, to output debug data\n  while (!Serial)\n    ; //Wait for user to open terminal\n  Serial.println(F(\"MAX17043 Example\"));\n\n  Wire.begin();\n\n  lipo.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial\n\n  // Set up the MAX17043 LiPo fuel gauge:\n  if (lipo.begin() == false) // Connect to the MAX17043 using the default wire port\n  {\n    Serial.println(F(\"MAX17043 not detected. Please check wiring. Freezing.\"));\n    while (1)\n      ;\n  }\n\n    // Quick start restarts the MAX17043 in hopes of getting a more accurate\n    // guess for the SOC.\n    lipo.quickStart();\n\n    // We can set an interrupt to alert when the battery SoC gets too low.\n    // We can alert at anywhere between 1% - 32%:\n    lipo.setThreshold(20); // Set alert threshold to 20%.\n}\n\nvoid loop()\n{\n  // lipo.getVoltage() returns a voltage value (e.g. 3.93)\n  voltage = lipo.getVoltage();\n  // lipo.getSOC() returns the estimated state of charge (e.g. 79%)\n  soc = lipo.getSOC();\n  // lipo.getAlert() returns a 0 or 1 (0=alert not triggered)\n  alert = lipo.getAlert();\n\n  // Print the variables:\n  Serial.print(\"Voltage: \");\n  Serial.print(voltage);  // Print the battery voltage\n  Serial.println(\" V\");\n\n  Serial.print(\"Percentage: \");\n  Serial.print(soc); // Print the battery state of charge\n  Serial.println(\" %\");\n\n  Serial.print(\"Alert: \");\n  Serial.println(alert);\n  Serial.println();\n\n  delay(500);\n}\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; SparkFun MAX1704x Fuel Gauge Arduino Library &gt; Example4_MAX17048_KitchenSink drop-down menu.</p> <code>Example4_MAX17048_KitchenSink.ino</code> <pre><code>/******************************************************************************\nExample4: test all the things on the MAX17048\nBy: Paul Clark, SparkFun Electronics\nDate: October 23rd 2020\n\nThis example is an everything-but-the-kitchen-sink test of the MAX17048.\n\nThis code is released under the MIT license.\n\nDistributed as-is; no warranty is given.\n******************************************************************************/\n\n#include &lt;Wire.h&gt; // Needed for I2C\n\n#include &lt;SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h&gt; // Click here to get the library: http://librarymanager/All#SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library\n\nSFE_MAX1704X lipo(MAX1704X_MAX17048); // Create a MAX17048\n\nvoid setup()\n{\n    Serial.begin(115200); // Start serial, to output debug data\n  while (!Serial)\n    ; //Wait for user to open terminal\n  Serial.println(F(\"MAX17048 Example\"));\n\n  Wire.begin();\n\n  lipo.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial\n\n  // Set up the MAX17048 LiPo fuel gauge:\n  if (lipo.begin() == false) // Connect to the MAX17048 using the default wire port\n  {\n    Serial.println(F(\"MAX17048 not detected. Please check wiring. Freezing.\"));\n    while (1)\n      ;\n  }\n\n  // Just because we can, let's reset the MAX17048\n  Serial.println(F(\"Resetting the MAX17048...\"));\n  delay(1000); // Give it time to get its act back together\n\n  // Read and print the reset indicator\n  Serial.print(F(\"Reset Indicator was: \"));\n  bool RI = lipo.isReset(true); // Read the RI flag and clear it automatically if it is set\n  Serial.println(RI); // Print the RI\n  // If RI was set, check it is now clear\n  if (RI)\n  {\n    Serial.print(F(\"Reset Indicator is now: \"));\n    RI = lipo.isReset(); // Read the RI flag\n    Serial.println(RI); // Print the RI    \n  }\n\n  // To quick-start or not to quick-start? That is the question!\n  // Read the following and then decide if you do want to quick-start the fuel gauge.\n  // \"Most systems should not use quick-start because the ICs handle most startup problems transparently,\n  //  such as intermittent battery-terminal connection during insertion. If battery voltage stabilizes\n  //  faster than 17ms then do not use quick-start. The quick-start command restarts fuel-gauge calculations\n  //  in the same manner as initial power-up of the IC. If the system power-up sequence is so noisy that the\n  //  initial estimate of SOC has unacceptable error, the system microcontroller might be able to reduce the\n  //  error by using quick-start.\"\n  // If you still want to try a quick-start then uncomment the next line:\n    //lipo.quickStart();\n\n  // Read and print the device ID\n  Serial.print(F(\"Device ID: 0x\"));\n  uint8_t id = lipo.getID(); // Read the device ID\n  if (id &lt; 0x10) Serial.print(F(\"0\")); // Print the leading zero if required\n  Serial.println(id, HEX); // Print the ID as hexadecimal\n\n  // Read and print the device version\n  Serial.print(F(\"Device version: 0x\"));\n  uint8_t ver = lipo.getVersion(); // Read the device version\n  if (ver &lt; 0x10) Serial.print(F(\"0\")); // Print the leading zero if required\n  Serial.println(ver, HEX); // Print the version as hexadecimal\n\n  // Read and print the battery threshold\n  Serial.print(F(\"Battery empty threshold is currently: \"));\n  Serial.print(lipo.getThreshold());\n  Serial.println(F(\"%\"));\n\n    // We can set an interrupt to alert when the battery SoC gets too low.\n    // We can alert at anywhere between 1% and 32%:\n    lipo.setThreshold(20); // Set alert threshold to 20%.\n\n  // Read and print the battery empty threshold\n  Serial.print(F(\"Battery empty threshold is now: \"));\n  Serial.print(lipo.getThreshold());\n  Serial.println(F(\"%\"));\n\n  // Read and print the high voltage threshold\n  Serial.print(F(\"High voltage threshold is currently: \"));\n  float highVoltage = ((float)lipo.getVALRTMax()) * 0.02; // 1 LSb is 20mV. Convert to Volts.\n  Serial.print(highVoltage, 2);\n  Serial.println(F(\"V\"));\n\n  // Set the high voltage threshold\n  lipo.setVALRTMax((float)4.1); // Set high voltage threshold (Volts)\n\n  // Read and print the high voltage threshold\n  Serial.print(F(\"High voltage threshold is now: \"));\n  highVoltage = ((float)lipo.getVALRTMax()) * 0.02; // 1 LSb is 20mV. Convert to Volts.\n  Serial.print(highVoltage, 2);\n  Serial.println(F(\"V\"));\n\n  // Read and print the low voltage threshold\n  Serial.print(F(\"Low voltage threshold is currently: \"));\n  float lowVoltage = ((float)lipo.getVALRTMin()) * 0.02; // 1 LSb is 20mV. Convert to Volts.\n  Serial.print(lowVoltage, 2);\n  Serial.println(F(\"V\"));\n\n  // Set the low voltage threshold\n  lipo.setVALRTMin((float)3.9); // Set low voltage threshold (Volts)\n\n  // Read and print the low voltage threshold\n  Serial.print(F(\"Low voltage threshold is now: \"));\n  lowVoltage = ((float)lipo.getVALRTMin()) * 0.02; // 1 LSb is 20mV. Convert to Volts.\n  Serial.print(lowVoltage, 2);\n  Serial.println(F(\"V\"));\n\n  // Enable the State Of Change alert\n  Serial.print(F(\"Enabling the 1% State Of Change alert: \"));\n  if (lipo.enableSOCAlert())\n  {\n    Serial.println(F(\"success.\"));\n  }\n  else\n  {\n    Serial.println(F(\"FAILED!\"));\n  }\n\n  // Read and print the HIBRT Active Threshold\n  Serial.print(F(\"Hibernate active threshold is: \"));\n  float actThr = ((float)lipo.getHIBRTActThr()) * 0.00125; // 1 LSb is 1.25mV. Convert to Volts.\n  Serial.print(actThr, 5);\n  Serial.println(F(\"V\"));\n\n  // Read and print the HIBRT Hibernate Threshold\n  Serial.print(F(\"Hibernate hibernate threshold is: \"));\n  float hibThr = ((float)lipo.getHIBRTHibThr()) * 0.208; // 1 LSb is 0.208%/hr. Convert to %/hr.\n  Serial.print(hibThr, 3);\n  Serial.println(F(\"%/h\"));\n}\n\nvoid loop()\n{\n  // Print the variables:\n  Serial.print(\"Voltage: \");\n  Serial.print(lipo.getVoltage());  // Print the battery voltage\n  Serial.print(\"V\");\n\n  Serial.print(\" Percentage: \");\n  Serial.print(lipo.getSOC(), 2); // Print the battery state of charge with 2 decimal places\n  Serial.print(\"%\");\n\n  Serial.print(\" Change Rate: \");\n  Serial.print(lipo.getChangeRate(), 2); // Print the battery change rate with 2 decimal places\n  Serial.print(\"%/hr\");\n\n  Serial.print(\" Alert: \");\n  Serial.print(lipo.getAlert()); // Print the generic alert flag\n\n  Serial.print(\" Voltage High Alert: \");\n  Serial.print(lipo.isVoltageHigh()); // Print the alert flag\n\n  Serial.print(\" Voltage Low Alert: \");\n  Serial.print(lipo.isVoltageLow()); // Print the alert flag\n\n  Serial.print(\" Empty Alert: \");\n  Serial.print(lipo.isLow()); // Print the alert flag\n\n  Serial.print(\" SOC 1% Change Alert: \");\n  Serial.print(lipo.isChange()); // Print the alert flag\n\n  Serial.print(\" Hibernating: \");\n  Serial.print(lipo.isHibernating()); // Print the alert flag\n\n  Serial.println();\n\n  delay(500);\n}\n</code></pre>"},{"location":"print_view/#bme688-environmental-sensor_1","title":"BME688 Environmental Sensor","text":"<p>Users are free to utilize any hardware they already have; however, we recommend the BME688 environmental sensor. The board includes a Qwiic connector on the edge of the board and can be easily attached to the RA6M5 Thing Plus with a Qwiic cable. In addition, a hookup guide and Arduino library for the sensor are available.</p> Optional Hardware <ul> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>Flexible Qwiic Cable - 50mm PRT-17260</p> Install Arduino Library <p>Users will need to install the Bosch BME68x Arduino library for the sensor. In the Arduino IDE, users can install it by searching for <code>BME68x Sensor Library</code>, in the Library Manager:</p> <pre><code>BME68x Sensor Library\n</code></pre> <p>Users can find this sketch in the File &gt; Examples &gt; BME68x Sensor library &gt; forced_mode drop-down menu. For more details on utilizing the BME68x breakout board, please refer to our hookup guide for the sensor.</p> <code>forced_mode.ino</code> <p>I<sup>2</sup>C Modifications</p> <p>By default, this example utilizes the SPI bus; therefore, some modifications must be made:</p> <ul> <li> <p>The chip select pin no longer needs to be defined:</p> <pre><code>#ifndef PIN_CS\n#define PIN_CS SS\n#endif\n</code></pre> </li> <li> <p>The I<sup>2</sup>C bus must be initialized, instead of the SPI bus:</p> <pre><code>SPI.begin();\nWire.begin();\n</code></pre> </li> <li> <p>The sensor must be initialized with the Wire class, instead of the SPI class:</p> <pre><code>/* initializes the sensor based on SPIWire library */\nbme.begin(PIN_CS, SPI);\nbme.begin(BME68X_I2C_ADDR_LOW, Wire)\n</code></pre> </li> </ul> <pre><code>/**\n * Copyright (C) 2021 Bosch Sensortec GmbH\n *\n * SPDX-License-Identifier: BSD-3-Clause\n * \n */\n\n#include \"Arduino.h\"\n#include \"bme68xLibrary.h\"\n\n#ifndef PIN_CS\n#define PIN_CS SS\n#endif\n\nBme68x bme;\n\n/**\n * @brief Initializes the sensor and hardware settings\n */\nvoid setup(void)\n{\n    SPI.begin();\n    Serial.begin(115200);\n\n    while (!Serial)\n        delay(10);\n\n    /* initializes the sensor based on SPI library */\n    bme.begin(PIN_CS, SPI);\n\n    if(bme.checkStatus())\n    {\n        if (bme.checkStatus() == BME68X_ERROR)\n        {\n            Serial.println(\"Sensor error:\" + bme.statusString());\n            return;\n        }\n        else if (bme.checkStatus() == BME68X_WARNING)\n        {\n            Serial.println(\"Sensor Warning:\" + bme.statusString());\n        }\n    }\n\n    /* Set the default configuration for temperature, pressure and humidity */\n    bme.setTPH();\n\n    /* Set the heater configuration to 300 deg C for 100ms for Forced mode */\n    bme.setHeaterProf(300, 100);\n\n    Serial.println(\"TimeStamp(ms), Temperature(deg C), Pressure(Pa), Humidity(%), Gas resistance(ohm), Status\");\n}\n\nvoid loop(void)\n{\n    bme68xData data;\n\n    bme.setOpMode(BME68X_FORCED_MODE);\n    delayMicroseconds(bme.getMeasDur());\n\n    if (bme.fetchData())\n    {\n        bme.getData(data);\n        Serial.print(String(millis()) + \", \");\n        Serial.print(String(data.temperature) + \", \");\n        Serial.print(String(data.pressure) + \", \");\n        Serial.print(String(data.humidity) + \", \");\n        Serial.print(String(data.gas_resistance) + \", \");\n        Serial.println(data.status, HEX);\n    }\n}\n</code></pre>"},{"location":"print_view/#examples-memorystorage","title":"Examples - Memory/Storage","text":"<p>Data Corruption</p> <p>To avoid any data loss or corrupting the SD card, users should disable all activity with the SD card before removing it from the RA6M5 Thing Plus.</p> <p>The FATFileSystem library built into the Renesas-Arduino core, supports \u00b5SD cards with a FAT32 file system (i.e. SD cards up to 32GB in size).</p> <ul> <li>While users may be able to use cards with a higher storage capacity, we highly advise against it. As users may experience data loss due to a corrupt file system (i.e. SD cards with a storage capacity greater than 32GB are not meant to be formatted with a FAT32 file system).</li> </ul>"},{"location":"print_view/#sd-card-test","title":"SD Card - Test","text":"<p>The Renesas-Arduino core includes a built-in FATFileSystem library that controls the SD host interface. The library that supports SD cards with a FAT32 file system (i.e. SD cards up to 32GB in size). Users can find an example sketch in the File &gt; Examples &gt; Storage &gt; TestSDCARD drop-down menu.</p> Optional Hardware <ul> <li> <p> <p>microSD Card - 1GB (Class 4) COM-15107</p> <li> <p> <p>microSD Card - 32GB (Class 10) COM-19041</p> <li> <p> <p>microSD USB Reader COM-13004</p> <code>TestSDCARD.ino</code> <pre><code>/*\n  Portenta H33 - TestSDCARD with Fat FS\n\n  The sketch shows how to mount an SDCARD and list its content.\n\n  The circuit:\n   - Portenta H33 + Portenta Breakout \n\n  created January 31th, 2023\n  by Daniele Aimo\n\n  This example code is in the public domain.\n*/\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include \"SDCardBlockDevice.h\"\n#include \"FATFileSystem.h\"\n\n#define TEST_FS_NAME \"fs\"\n#define TEST_FOLDER_NAME \"TEST_FOLDER\"\n#define TEST_FILE \"test.txt\"\n#define DELETE_FILE_DIMENSION 150\n\n\nSDCardBlockDevice block_device(PIN_SDHI_CLK, PIN_SDHI_CMD, PIN_SDHI_D0, PIN_SDHI_D1, PIN_SDHI_D2, PIN_SDHI_D3, PIN_SDHI_CD, PIN_SDHI_WP);\nFATFileSystem fs(TEST_FS_NAME);\n\nstd::string root_folder       = std::string(\"/\") + std::string(TEST_FS_NAME);\nstd::string folder_test_name  = root_folder + std::string(\"/\") + std::string(TEST_FOLDER_NAME);\nstd::string file_test_name    = folder_test_name + std::string(\"/\") + std::string(TEST_FILE); \n\nvoid setup() {\n  /*\n   *  SERIAL INITIALIZATION\n   */\n  Serial.begin(9600);\n  while(!Serial) {\n\n  }\n\n  /* list to store all directory in the root */\n  std::vector&lt;std::string&gt; dir_list;\n\n  Serial.println();\n  Serial.println(\"##### TEST SD CARD with FAT FS\");\n  Serial.println();\n\n  /* \n   *  MOUNTING SDCARD AS FATFS filesystem\n   */\n  Serial.println(\"Mounting SDCARD...\");\n  int err =  fs.mount(&amp;block_device);\n  if (err) {\n    // Reformat if we can't mount the filesystem\n    // this should only happen on the first boot\n    Serial.println(\"No filesystem found, formatting... \");\n    err = fs.reformat(&amp;block_device);\n  }\n  if (err) {\n     Serial.println(\"Error formatting SDCARD \");\n     while(1);\n  }\n\n  /* \n   *  READING root folder\n   */\n\n  DIR *dir;\n  struct dirent *ent;\n  int dirIndex = 0;\n\n  Serial.println(\"*** List SD CARD content: \");\n  if ((dir = opendir(root_folder.c_str())) != NULL) {\n    while ((ent = readdir (dir)) != NULL) {\n\n      if(ent-&gt;d_type == DT_REG) {\n        Serial.print(\"- [File]: \");\n      }\n\n      else if(ent-&gt;d_type == DT_DIR) {\n        Serial.print(\"- [Fold]: \");\n        dir_list.push_back(ent-&gt;d_name);\n      }\n      Serial.println(ent-&gt;d_name);\n      dirIndex++;\n    }\n    closedir (dir);\n  } \n  else {\n    // Could not open directory\n    Serial.println(\"Error opening SDCARD\\n\");\n    while(1);\n  }\n\n  if(dirIndex == 0) {\n    Serial.println(\"Empty SDCARD\");\n  }\n\n  bool found_test_folder = false;\n\n  /* \n   *  LISTING CONTENT of the first level folders (the one immediately present in root folder)\n   */\n\n  if(dir_list.size()) {\n    Serial.println();\n    Serial.println(\"Listing content of folders in root: \");\n  }\n  for(unsigned int i = 0; i &lt; dir_list.size(); i++) {\n    if(dir_list[i] == TEST_FOLDER_NAME) {\n      found_test_folder = true;\n    }\n    Serial.print(\"- \");\n    Serial.print(dir_list[i].c_str());\n    Serial.println(\":\");\n\n    std::string d = root_folder + std::string(\"/\") + dir_list[i];\n    if ((dir = opendir(d.c_str())) != NULL) {\n      while ((ent = readdir (dir)) != NULL) {\n        if(ent-&gt;d_type == DT_REG) {\n          Serial.print(\"   - [File]: \");\n        }\n        else if(ent-&gt;d_type == DT_DIR) {\n          Serial.print(\"   - [Fold]: \");\n        }\n        Serial.println(ent-&gt;d_name);\n      }\n      closedir (dir);\n    }\n    else {\n      Serial.print(\"ERROR OPENING SUB-FOLDER \");\n      Serial.println(d.c_str());\n    }\n  }\n\n  /* \n   *  CREATING TEST FOLDER (if does not exist already)\n   */\n\n  err = 0;\n  if(!found_test_folder) {\n    Serial.println(\"TEST FOLDER NOT FOUND... creating folder test\"); \n    err = mkdir(folder_test_name.c_str(), S_IRWXU | S_IRWXG | S_IRWXO);\n    if(err != 0) {\n      Serial.print(\"FAILED folder creation with error \");\n      Serial.println(err);\n    }\n  }\n\n  /* \n   *  READING TEST FILE CONTENT\n   */\n\n  if(err == 0) {\n    int file_dimension = 0; \n    FILE* fp = fopen(file_test_name.c_str(), \"r\");\n    if(fp != NULL) {\n      Serial.print(\"Opened file: \");\n      Serial.print(file_test_name.c_str());\n      Serial.println(\" for reading\");\n\n      fseek(fp, 0L, SEEK_END);\n      int numbytes = ftell(fp);\n      fseek(fp, 0L, SEEK_SET);  \n\n      Serial.print(\"Bytes in the file: \");\n      Serial.println(numbytes);\n      file_dimension = numbytes;\n\n      if(numbytes &gt; 0) {\n        Serial.println();\n        Serial.println(\"-------------------- START FILE CONTENT --------------------\");\n      }\n\n      for(int i = 0; i &lt; numbytes; i++) {\n        char ch;\n        fread(&amp;ch, sizeof(char), 1, fp);\n        Serial.print(ch);\n      }\n\n      if(numbytes &gt; 0) {\n        Serial.println(\"--------------------- END FILE CONTENT ---------------------\");\n        Serial.println();\n      }\n      else {\n        Serial.println(\"File is EMPTY!\");\n        Serial.println();\n      }\n\n      fclose(fp);\n    }\n    else {\n      Serial.print(\"FAILED open file \");\n      Serial.println(file_test_name.c_str());\n    }\n\n    /*\n     * DELETE FILE IF THE File dimension is greater than 150 bytes\n     */\n\n    if(file_dimension &gt; DELETE_FILE_DIMENSION) {\n      Serial.println(\"Test file reached the delete dimension... deleting it!\");\n      if(remove(file_test_name.c_str()) == 0) {\n        Serial.println(\"TEST FILE HAS BEEN DELETED!\");\n      }\n    }\n\n    /*\n     * APPENDING SOMETHING TO FILE \n     */\n\n    fp = fopen(file_test_name.c_str(), \"a\");\n    if(fp != NULL) {\n      Serial.print(\"Opened file: \");\n      Serial.print(file_test_name.c_str());\n      Serial.println(\" for writing (append)\");\n      char text[] = \"This line has been appended to file!\\n\";\n      fwrite(text, sizeof(char), strlen(text), fp);\n      fclose(fp); \n    }\n    else {\n      Serial.print(\"FAILED open file for appending \");\n      Serial.println(file_test_name.c_str());\n    }\n\n    /*\n     * READING AGAIN FILE CONTENT\n     */\n\n    fp = fopen(file_test_name.c_str(), \"r\");\n    if(fp != NULL) {\n      Serial.print(\"Opened file: \");\n      Serial.print(file_test_name.c_str());\n      Serial.println(\" for reading\");\n\n      fseek(fp, 0L, SEEK_END);\n      int numbytes = ftell(fp);\n      fseek(fp, 0L, SEEK_SET);  \n\n      Serial.print(\"Bytes in the file: \");\n      Serial.println(numbytes);\n\n      if(numbytes &gt; 0) {\n        Serial.println();\n        Serial.println(\"-------------------- START FILE CONTENT --------------------\");\n      }\n\n      for(int i = 0; i &lt; numbytes; i++) {\n        char ch;\n        fread(&amp;ch, sizeof(char), 1, fp);\n        Serial.print(ch);\n      }\n\n      if(numbytes &gt; 0) {\n        Serial.println(\"--------------------- END FILE CONTENT ---------------------\");\n        Serial.println();\n      }\n      else {\n        Serial.println(\"File is EMPTY!\");\n        Serial.println();\n      }\n\n      fclose(fp);\n\n    }\n    else {\n      Serial.print(\"FAILED open file for appending \");\n      Serial.println(file_test_name.c_str());\n    }\n  }  \n\n}\n\nvoid loop() {\n  // Empty\n}\n</code></pre>"},{"location":"print_view/#mx25l12833f","title":"MX25L12833F","text":"<p>The Renesas-Arduino core includes a built-in FATFileSystem library to control the QSPI flash memory. This example code demonstrates how to initialize the flash memory, a file is written, and data is read from the file. Users can also find other example sketches in the File &gt; Examples &gt; Storage drop-down menu.</p> <code>QSPI_Flash_FileSystem_Test.ino</code> <p>// Always close the file after writing to save changes</p> <pre><code>??? code\n    ```cpp\n      Name: QSPI_Flash_FileSystem_Test.ino\n      Purpose: This sketch test the onboard QSPI Flash memory\n      file system by writing and reading a file.\n\n      @author Arduino Team\n      @version 1.0 20/06/23\n    */\n\n    // Include necessary libraries and drivers\n    #include \"QSPIFlashBlockDevice.h\"\n    #include \"FATFileSystem.h\"\n\n    ```\n</code></pre> <p>fclose(fp);</p> <pre><code>??? code\n    ```cpp\n    #define QSPI_FS_NAME \"qspi\"\n    #define TEST_FILE \"test.txt\"\n\n    // Instantiate flash block device and file system\n    QSPIFlashBlockDevice block_device(PIN_QSPI_CLK, PIN_QSPI_SS, PIN_QSPI_D0, PIN_QSPI_D1, PIN_QSPI_D2, PIN_QSPI_D3); \n    FATFileSystem fs(QSPI_FS_NAME);\n\n    // Define full path to the test file\n    std::string file_test_name = std::string(\"/\") + std::string(QSPI_FS_NAME) + std::string(\"/\") + std::string(TEST_FILE); \n\n    void setup() {\n      // Initialize serial communication and wait a connection\n      Serial.begin(9600);\n      while(!Serial);\n\n    ```\n</code></pre> <p>}</p> <pre><code>??? code\n    ```cpp\n    Serial.println();\n    Serial.println(\"- SIMPLE QSPI FLASH TEST\");\n    Serial.println();\n\n    // Try to mount the QSPI Flash file system\n    // If mounting fails, try to format the file system\n    int err =  fs.mount(&amp;block_device);\n    if (err) {\n      Serial.println(\"- No filesystem found, formatting... \");\n      err = fs.reformat(&amp;block_device);\n    }\n    if (err) {\n      // If formatting fails, print error and halt\n      Serial.println(\"- Error formatting QSPI Flash \");\n      while(1);\n    }\n\n    ```\n</code></pre>"},{"location":"print_view/#eslov-connector","title":"ESLOV Connector","text":"<p>The Portenta C33 board features an onboard ESLOV connector to extend the I2C communication bus. This connector simplifies connecting various sensors, actuators, and other modules to the Portenta C33 without soldering or wiring; Nicla family boards can also be connected to the Portenta C33 through this connector. </p> <p></p> <p>The ESLOV connector is a small 5-pin connector with a 1.00 mm pitch. The mechanical details of the connector can be found in the connector's datasheet.</p> <p>The pin layout of the ESLOV connector is the following:</p> <ol> <li>VCC</li> <li>INT</li> <li>SCL</li> <li>SDA</li> <li>GND</li> </ol> <p><code>VCC</code> pin works as a 5 V output if the board is connected to a USB-C\u00ae cable. The manufacturer part number of the ESLOV connector is SM05B-SRSS, and its matching receptacle manufacturer part number is SHR-05V-S-B.</p>"},{"location":"print_view/#external-memory_1","title":"External Memory","text":"<p>The Portenta C33 board features an onboard 16 MB QSPI Flash memory, the MX25L12833F from Macronix\u00ae. Having an onboard QSPI Flash memory enhances the capabilities of the Portenta C33, enabling you to develop and run more complex and data-intensive applications.</p> <p></p> <p>Some key advantages of having an onboard QSPI Flash memory are the following:</p> <ul> <li>Storage capacity: The MX25L12833F QSPI Flash memory adds significant non-volatile storage to the board.</li> <li>Extended functionality: The additional memory space allows more complex applications to be developed and run on your Portenta C33. This application includes data logging, image processing, audio processing, and executing complex algorithms.</li> <li>Firmware updates: The MX25L12833F QSPI Flash memory can also store firmware or software updates for your Arduino board. This means you can update the firmware without requiring a complete reprogramming of the board.</li> </ul> <p>The Arduino Renesas Core has built-in libraries and drivers that immediately let you use the onboard QSPI Flash memory. Let's walk through an example code demonstrating some of the onboard Flash memory capabilities; the main tasks performed in the sketch are initializing the Flash memory, writing to a file, and reading from a file.</p> <p>```arduino /**   QSPI Flash File System test   Name: QSPI_Flash_FileSystem_Test.ino   Purpose: This sketch test the onboard QSPI Flash memory   file system by writing and reading a file.</p> <p>@author Arduino Team   @version 1.0 20/06/23 */</p> <p>// Include necessary libraries and drivers</p>"},{"location":"print_view/#include-qspiflashblockdeviceh","title":"include \"QSPIFlashBlockDevice.h\"","text":""},{"location":"print_view/#include-fatfilesystemh","title":"include \"FATFileSystem.h\"","text":"<p>// Define constants for file system and test file name</p>"},{"location":"print_view/#define-qspi_fs_name-qspi","title":"define QSPI_FS_NAME \"qspi\"","text":""},{"location":"print_view/#define-test_file-testtxt","title":"define TEST_FILE \"test.txt\"","text":"<p>// Instantiate flash block device and file system QSPIFlashBlockDevice block_device(PIN_QSPI_CLK, PIN_QSPI_SS, PIN_QSPI_D0, PIN_QSPI_D1, PIN_QSPI_D2, PIN_QSPI_D3);  FATFileSystem fs(QSPI_FS_NAME);</p> <p>// Define full path to the test file std::string file_test_name = std::string(\"/\") + std::string(QSPI_FS_NAME) + std::string(\"/\") + std::string(TEST_FILE); </p> <p>void setup() {   // Initialize serial communication and wait a connection   Serial.begin(9600);   while(!Serial);</p> <p>// Print test start message   Serial.println();   Serial.println(\"- SIMPLE QSPI FLASH TEST\");   Serial.println();</p> <p>// Try to mount the QSPI Flash file system   // If mounting fails, try to format the file system   int err =  fs.mount(&amp;block_device);   if (err) {     Serial.println(\"- No filesystem found, formatting... \");     err = fs.reformat(&amp;block_device);   }   if (err) {     // If formatting fails, print error and halt     Serial.println(\"- Error formatting QSPI Flash \");     while(1);   }</p> <p>// Try to open a test file for writing   // If file opened successfully, write some text to the file   FILE* fp = fopen(file_test_name.c_str(), \"w\");   if(fp != NULL) {</p>"},{"location":"print_view/#examples-codeless","title":"Examples -  CodeLess","text":""},{"location":"print_view/#at-commands","title":"AT Commands","text":"<p>To help users get started with the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have provided an <code>SerialPassthrough</code> example in our unofficial Arduino library. Once programmed on the RA6M5 Thing Plus, the example allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. Thereby, enabling users to experiment with the CodeLess AT commands and develop their own BLE connectivity solution. Users can find this sketch in the File &gt; Examples &gt; SparkFun Renesas Codeless BLE &gt; SerialPassthrough drop-down menu.</p> <code>SerialPassthrough.ino</code> <pre><code>/*\n  SerialPassthrough sketch\n\n  Some boards have a USB serial port that operates independently from the\n  hardware serial port(s) attached their Digital pins. This means that the\n  \"serial passthrough\" which is possible with the Arduino UNO (commonly used\n  to interact with devices/shields that require configuration via serial AT\n  commands) will not operate in a similar manner.\n\n  This sketch allows users to emulate the serial passthrough behaviour. (i.e.\n  Any text typed in the IDE Serial monitor will be written to the serial port\n  oof the Digital pins, and vice-versa.)\n\n  created 23 May 2016\n  by Erik Nyquist\n\n  https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialPassthrough\n\n\n  This sketch has been modified for the SparkFun Ting Plus - RA6M5. \"Serial\"\n  refers to the USB Serial port attached to the Serial Monitor, and \"Serial2\"\n  refers to the hardware serial port attached to pins D31 and D32; for the\n  DA14531MOD Bluetooth module. This sketch will emulate Serial passthrough\n  for those two Serial ports on the bSparkFun Ting Plus - RA6M5. The default\n  communication settings for the DA14531MOD are:\n\n  BaudRate : 57600\n  DataBits : 8\n  StopBits : 1\n  Parity : None\n  Flow Control : None\n  Transmit Text: Append CR\n\n  Modified 18 March 2024\n  by SparkFun Electronics\n  author: Wes F\n\n*/\n\nvoid setup() {\n  Serial.begin(57600);\n  Serial2.begin(57600);\n}\n\nvoid loop() {\n  if (Serial.available()) {        // If anything comes in Serial (USB),\n    Serial2.write(Serial.read());  // read it and send it out Serial1 (pins 0 &amp; 1)\n  }\n\n  if (Serial2.available()) {       // If anything comes in Serial1 (pins 0 &amp; 1)\n    Serial.write(Serial2.read());  // read it and send it out Serial (USB)\n  }\n}\n</code></pre> <p>Serial Monitor</p> <p>Users should configure the serial port with a baud rate at 57600 bps and enable the carriage return on the transmissions.</p>"},{"location":"print_view/#demo-ble-solution","title":"Demo - BLE Solution","text":"<p>While an Arduino library isn't necessary to utilize the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have created an unofficial Arduino library to help users get started. Once the library is installed in the Arduino IDE, users will find several example sketches listed in the File &gt; Examples &gt; SparkFun Renesas Codeless BLE drop-down menu. We recommend users check out the following examples that demonstrate a basic BLE connectivity solution:</p> <ul> <li><code>codelessBLE_peripheral.ino</code></li> <li><code>codelessBLE_central.ino</code></li> </ul> <p>In order to operate the <code>codelessBLE_peripheral.ino</code> and <code>codelessBLE_central.ino</code> examples, users will need two RA6M5 Thing Plus boards, Qwiic OLED Display, Qwiic BME280 sensor, and some Qwiic cables.</p> Required Hardware <ul> <li> <p> <p>RA6M5 Thing Plus WRL-24243</p> <li> <p> <p>SparkFun Qwiic Cable Kit KIT-15081</p> <li> <p> <p>SparkFun Qwiic OLED Display (0.91 in., 128x32) LCD-24606</p> <li> <p> <p>SparkFun Atmospheric Sensor Breakout - BME280 (Qwiic) SEN-15440</p> <code>codelessBLE_peripheral.ino</code><code>codelessBLE_central.ino</code> <p>This sketch requires a Qwiic BME280 sensor, connected by a Qwiic cable, to be connected the RA6M5 Thing Plus. The sketch demonstrates a basic BLE solution, by transmitting data from the BME280 to another BLE device. Users can find this sketch in the File &gt; Examples &gt; SparkFun Renesas Codeless BLE &gt; codelessBLE_peripheral drop-down menu.</p> Install Arduino Library <p>For this example, the SparkFun BME280 Arduino Library will need to be installed. In the Arduino IDE, users can install it by searching for <code>SparkFun BME280 Arduino Library</code>, in the Library Manager:</p> <pre><code>SparkFun BME280 Arduino Library\n</code></pre> <code>codelessBLE_peripheral.ino</code> <pre><code>/**\n * @file codelessBLE_peripheral.ino\n * @brief This file contains the code for a BLE peripheral device that \n * communicates with a BME280 sensor.\n * \n * The code sets up a BLE peripheral device using the CodelessBLEPeripheral \n * class and establishes a connection with the onboard BLE coprocessor. It \n * also initializes a BME280 sensor and reads temperature, humidity, and \n * pressure values from it. The sensor data is then sent to the connected BLE \n * central device periodically.\n * \n * The code handles the connection and disconnection events from the BLE device\n * and prints the received data to the Serial monitor.\n * \n * This code is intended to be used with the SparkFun Thing Plus - RA6M5 \n * development board.\n */\n#include &lt;codelessBLEPeripheral.h&gt;\n#include &lt;Wire.h&gt;\n#include \"SparkFunBME280.h\"\n\nCodelessPeripheralDevice myBLEPeripheral;\nBME280 myBME280;\n\nbool bleConnected = false;\nbool reset_loop = false;\nuint32_t loop_start_time = 0;\nString printstring = \"\";\n\nvoid setup()\n{\n    pinMode(LED_BUILTIN, OUTPUT);\n    digitalWrite(LED_BUILTIN, HIGH);\n\n    Serial.begin(57600);\n    // while(!Serial){delay(100);}; // Uncomment during testing and needing a serial connection.\n    Serial.println(\"Begin BLE Peripheral Demo.\");\n\n    #if defined(CODELESS_DBG)\n    Serial.println(\"CODELESS_DBG defined.\");\n    #endif\n\n    Wire.begin();\n\n    if(!myBME280.beginI2C())\n    {\n        Serial.println(\"Sensor didn't respond. Check wiring!\");\n        while(1);\n    }\n\n    Serial.println(\"Connected to BME280.\");\n\n    myBLEPeripheral.begin();\n    while(!Serial2){delay(100);};\n    Serial.println(\"Connected to BLE coprocessor.\");\n\n    Serial.println(\"Running default setup routine.\");\n    myBLEPeripheral.setupDefault();\n\n    Serial.print(\"Peripheral Device Address: \");\n    Serial.print(myBLEPeripheral.sendCommand(\"AT+BDADDR\"));\n\n    Serial.println(\"Setup complete.\");\n    digitalWrite(LED_BUILTIN, LOW);\n\n    loop_start_time = millis();\n}\n\nvoid loop()\n{\n    if((loop_start_time - millis()) &gt; 100) // If it's been more than 100ms\n    {\n        reset_loop = true;\n        if(bleConnected)\n        {\n            digitalWrite(LED_BUILTIN, HIGH);\n            printstring = \"|\"+String(myBME280.readTempC())+\",\"+String(myBME280.readFloatHumidity())+\",\"+String(myBME280.readFloatPressure());\n            Serial.print(myBLEPeripheral.sendCommand(printstring));\n            digitalWrite(LED_BUILTIN, LOW);\n        }\n\n        if (myBLEPeripheral.available()) {       // If anything comes in Serial2 (BLE device)\n            String localstring = myBLEPeripheral.readOutput();\n            if(!bleConnected)\n            {\n                if(localstring.endsWith(\"+CONNECTED\\r\\n\"))\n                {\n                    #ifdef CODELESS_DBG\n                    Serial.println(\"[DBG] - outloop - Got connected output.\");\n                    #endif\n                    bleConnected = true;\n                }\n            }\n\n            if(bleConnected)\n            {\n                if(localstring.endsWith(\"+DISCONNECTED\\r\\n\"))\n                {\n                    #ifdef CODELESS_DBG\n                    Serial.println(\"[DBG] - outloop - Got disconnected output.\");\n                    #endif\n                    bleConnected = false;\n                }\n            }\n            Serial.print(localstring);\n        }\n        if(reset_loop &amp;&amp; bleConnected)\n        {\n            reset_loop = false;\n            #ifdef CODELESS_DBG\n            Serial.println();\n            Serial.println(\"Resetting loop\");\n            #endif\n            loop_start_time = millis();\n        }\n    }  \n}\n</code></pre> <p>BME688 Replacement</p> <p>Users can also modify this example to utilize the Qwiic BME688 sensor that is mentioned in some of the other examples. For more details on utilizing the BME68x breakout board, please refer to our hookup guide for the sensor.</p> <ul> <li> <p> <p>SparkFun Environmental Sensor - BME688 (Qwiic) SEN-19096</p> <li> <p> <p>Flexible Qwiic Cable - 50mm PRT-17260</p> Install Arduino Library <p>Users will need to install the Bosch BME68x Arduino library for the sensor. In the Arduino IDE, users can install it by searching for <code>BME68x Sensor Library</code>, in the Library Manager:</p> <pre><code>BME68x Sensor Library\n</code></pre> Modifications <ul> <li> <p>Link the BME68x Arduino library:</p> <pre><code>#include \"SparkFunBME280.h\"\n#include \"bme68xLibrary.h\"\n</code></pre> </li> <li> <p>Create an instance of the <code>Bme68x</code> class:</p> <pre><code>BME280 myBME280;\nBme68x bme;\n</code></pre> </li> <li> <p>Initialize and configure the sensor in the <code>setup()</code>:</p> <pre><code>if(!myBME280.beginI2C())\n{\n    Serial.println(\"Sensor didn't respond. Check wiring!\");\n    while(1);\n}\n\nSerial.println(\"Connected to BME280.\");\n\nbme.begin(BME68X_I2C_ADDR_LOW, Wire);\n\nif(bme.checkStatus())\n{\n    if (bme.checkStatus() == BME68X_ERROR)\n    {\n        Serial.println(\"Sensor error:\" + bme.statusString());\n        return;\n    }\n    else if (bme.checkStatus() == BME68X_WARNING)\n    {\n        Serial.println(\"Sensor Warning:\" + bme.statusString());\n    }\n}\n\n/* Set the default configuration for temperature, pressure and humidity */\nbme.setTPH();\n\n/* Configure the sensor to forced mode */\nbme.setOpMode(BME68X_FORCED_MODE);\n</code></pre> </li> <li> <p>Update the <code>loop()</code> to retrieve data from the BME688</p> <pre><code>if((loop_start_time - millis()) &gt; 100) // If it's been more than 100ms\n{\n    reset_loop = true;\n    if(bleConnected)\n    {\n        digitalWrite(LED_BUILTIN, HIGH);\n        printstring = \"|\"+String(myBME280.readTempC())+\",\"+String(myBME280.readFloatHumidity())+\",\"+String(myBME280.readFloatPressure());\n        Serial.println(myBLEPeripheral.sendCommand(printstring));\n        digitalWrite(LED_BUILTIN, LOW);\n    }\n\nbme68xData data;\n\nif((loop_start_time - millis()) &gt; 100)    // If it's been more than 100ms\n{\n    reset_loop = true;\n    if(bleConnected)\n    {\n        digitalWrite(LED_BUILTIN, HIGH);\n\n        delayMicroseconds(bme.getMeasDur());  // Wait for measurement data\n\n        /* Retrieve data from BME688 sensor*/\n        if (bme.fetchData())\n        {\n            bme.getData(data);\n            printstring = \"|\"+String(data.temperature)+\",\"+String(data.humidity)+\",\"+String(data.pressure);\n        }\n\n        Serial.print(myBLEPeripheral.sendCommand(printstring));\n        digitalWrite(LED_BUILTIN, LOW);\n    }\n</code></pre> </li> </ul> <p>This sketch requires a Qwiic OLED Display to be connected the RA6M5 Thing Plus, by a Qwiic cable. The sketch receives data transmitted from a RA6M5 Thing Plus, programmed with the <code>codelessBLE_peripheral.ino</code> sketch, and displays that data on the OLED display. Users can find this sketch in the File &gt; Examples &gt; SparkFun Renesas Codeless BLE &gt; codelessBLE_central drop-down menu.</p> <code>codelessBLE_central.ino</code> <pre><code>/**\n * @file codelessBLE_central.ino\n * @brief This file contains the code for a BLE central device that connects to\n * a peripheral device and displays sensor data on an OLED display.\n * \n * The code sets up a BLE central device using the CodelessBLECentral class. It \n * establishes a connection with a specific peripheral device, then receives \n * and displays the data on an OLED display using the SparkFun_Qwiic_OLED \n * library.\n * \n * The RA6M5 processor communicates to the BLE coprocessor over a serial \n * connection. It sends commands to the peripheral device and receives \n * responses, which are then displayed on the serial monitor. The sensor data \n * received from the peripheral device is parsed and displayed on the OLED \n * display.\n * \n * This code is intended to be used with the SparkFun Thing Plus - RA6M5 \n * development board.\n */\n\n#include &lt;codelessBLECentral.h&gt;\n#include &lt;Wire.h&gt;\n#include &lt;SparkFun_Qwiic_OLED.h&gt; // https://librarymanager/All#SparkFun_Qwiic_OLED\n#include &lt;res/qw_fnt_5x7.h&gt;\n\nCodelessCentralDevice myBLECentral;\nQwiicNarrowOLED myOLED;\n\nString peripheralAddress = \"48:23:35:34:74:D3\"; // Hardware specific, change to your peripheral's address.\nString localstring = \"\";\nString printstring_temp = \"\";\nString printstring_hum = \"\";\nString printstring_press = \"\";\n\nvoid setup()\n{\n    pinMode(LED_BUILTIN, OUTPUT);\n    digitalWrite(LED_BUILTIN, HIGH);\n    Serial.begin(DEFAULT_CODELESS_BAUD_RATE);\n    // while(!Serial){delay(100);}; // Uncomment during testing and needing a serial connection.\n    Serial.println(\"Begin BLE Central Demo.\");\n\n    #if defined(CODELESS_DBG)\n    Serial.println(\"CODELESS_DBG defined.\");\n    #endif\n\n    Wire.begin();\n    if(myOLED.begin() == false)\n    {\n        Serial.println(\"Unable to communicate with display. Freezing...\");\n        while(1);\n    }\n\n    Serial.println(\"Connected to display.\");\n    myOLED.setFont(QW_FONT_5X7);\n\n    myOLED.erase();\n\n    String hello = \"Codeless BLE Demo\";\n\n    int x0 = (myOLED.getWidth() - myOLED.getStringWidth(hello)) / 2;\n    int y0 = (myOLED.getHeight() - myOLED.getStringHeight(\"a\")) / 2;\n    myOLED.text(x0, y0, hello);\n    myOLED.display();\n\n    myBLECentral.begin();\n    while(!Serial2){delay(100);};\n    Serial.println(\"Connected to BLE coprocessor.\");\n\n    Serial.println(\"Running default setup routine.\");\n    myBLECentral.setupDefault();\n\n    Serial.print(\"Central device address: \");\n    Serial.print(myBLECentral.sendCommand(\"AT+BDADDR\"));\n\n    myBLECentral.connectToPeripheral(peripheralAddress);\n\n    Serial.println(\"Setup complete.\");\n    digitalWrite(LED_BUILTIN, LOW);\n\n    hello = \"Wait for conn...\";\n    x0 = (myOLED.getWidth() - myOLED.getStringWidth(hello)) / 2;\n    y0 = (myOLED.getHeight() - myOLED.getStringHeight(\"a\")) / 2;\n    myOLED.erase();\n    myOLED.text(x0, y0, hello);\n    myOLED.display();\n}\n\nvoid loop()\n{\n    if (Serial.available()) {        // If anything comes in Serial (USB),\n        Serial.print(myBLECentral.sendCommand(Serial.readString()));  // read, then command BLE, write response back to Serial.\n    }\n\n    if (myBLECentral.available()) {       // If anything comes in Serial2 (BLE device)\n        localstring = myBLECentral.readOutput();\n        localstring.trim(); // remove leading and trailing \\r \\n whitespace.\n        int16_t index = localstring.indexOf(\"|\");\n\n        if(index &gt; -1)\n        {\n            #ifdef CODELESS_DBG\n            Serial.print(\"[DBG] - loop - readOutput - String contains | at index \");\n            Serial.print(index);\n            Serial.println(\".\");\n            #endif\n            localstring+=\"\\r\";\n            localstring.remove(index,1);\n            String temp = localstring.substring(0,localstring.indexOf(\",\"));\n            String hum = localstring.substring(localstring.indexOf(\",\")+1, localstring.indexOf(\",\", localstring.indexOf(\",\")+1));\n            String press = localstring.substring(localstring.lastIndexOf(\",\")+1);\n            Serial.print(\"T: \");\n            Serial.print(temp);\n            Serial.print(\" H: \");\n            Serial.print(hum);\n            Serial.print(\" P: \");\n            Serial.println(press);\n\n            printstring_temp = \"T: \"+temp+\" dC\";\n            int ytemp = (myOLED.getHeight()/3) - myOLED.getStringHeight(printstring_temp);\n            printstring_hum = \"H: \"+hum+\" %RH\";\n            int yhum = (myOLED.getHeight() / 3 * 2) - myOLED.getStringHeight(printstring_hum);\n            printstring_press = \"P: \"+press+\" Pa\";\n            int ypress = myOLED.getHeight() - myOLED.getStringHeight(printstring_press);\n\n            myOLED.erase();\n            myOLED.text(3, ytemp, printstring_temp);\n            myOLED.display();\n            myOLED.text(3, yhum, printstring_hum);\n            myOLED.display();\n            myOLED.text(3, ypress, printstring_press);\n            myOLED.display();\n        }\n        else\n        {\n            Serial.println(localstring);\n        }\n    }\n}\n</code></pre>"},{"location":"print_view/#resources","title":"Resources","text":""},{"location":"print_view/#product-resources","title":"Product Resources","text":"<ul> <li> Product Page</li> <li> Design Files:<ul> <li> Schematic</li> <li> Board Dimensions</li> <li> Eagle Files</li> </ul> </li> <li> Graphical Datasheet</li> <li> Renesas Arduino Core</li> <li> Arduino Libraries:<ul> <li>FastLED Arduino library</li> <li>SparkFun MAX1704x Fuel Gauge Arduino library</li> <li> CodeLess Arduino Library (unofficial - <code>CodeLess.zip</code>)</li> </ul> </li> <li> SFE Product Showcase</li> <li> Hardware Repo</li> </ul>"},{"location":"print_view/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p> Component Documentation:</p> <ul> <li> <p>RA6M5 Microcontroller</p> <ul> <li> Datasheet</li> <li> User Manual</li> </ul> </li> <li> <p>DA14531MOD Bluetooth Module</p> <ul> <li> Datasheet</li> <li> Codeless\u2122 User Manual</li> </ul> </li> <li> <p>Peripherals Devices</p> <ul> <li> MAX17048 Battery Fuel Gauge</li> <li> WS2812 RGB LED</li> <li> MX25L12833F QSPI FLash</li> </ul> </li> <li> <p>Power Components</p> <ul> <li> RT9080 LDO Voltage Regulator</li> <li> LM66200 Ideal Diode Switch</li> <li> MCP73831 Charge Controller</li> </ul> </li> </ul> </li> <li> <p>Thing Plus Comparison Guide</p> </li> <li>Qwiic Information Page</li> <li> SparkFun Technical Assistance</li> </ul>"},{"location":"print_view/#manufacturers-resources","title":"\ud83c\udfed\u00a0Manufacturer's Resources","text":"<p>Renesas also provides great resources for the RA6M5 and DA14531MOD:</p> <ul> <li>SmartBond\u2122 Flash Programmer</li> <li> RenesasRulz Forum</li> </ul> <ul> <li> <p>RA6M5 Product Page</p> <ul> <li>Documentation<ul> <li>RA6M5 Group Datasheet</li> <li>RA6M5 Group User Manual: Hardware</li> </ul> </li> <li>Software and Tools</li> </ul> </li> <li> <p>DA14531MOD Product Page</p> <ul> <li>Documentation<ul> <li>DA14531MOD Datasheet</li> </ul> </li> <li>Software and Tools<ul> <li>DA145<code>XX</code> CodeLess\u2122 User Manual</li> <li>SmartBond\u2122 - CodeLess\u2122 AT commands</li> <li>DA1453<code>x</code> SW Platform Reference Manual</li> </ul> </li> <li>Tutorials:<ul> <li>Tutorial - Sleep Modes</li> <li>Tutorial - Peripheral Drivers (Dialog SDK 6.0.<code>x</code>)</li> <li>Tutorial - Debugging (Dialog SDK 6.0.<code>x</code>)</li> <li>Tutorial - BLE Serial Port Service</li> <li>Tutorial - BLE Advertising</li> <li>Tutorial - Create a Custom GATT Profile</li> <li> SDK 6.0.<code>x</code> BLE Examples</li> </ul> </li> </ul> </li> </ul> <p> </p>"},{"location":"print_view/#troubleshooting-tips","title":"Troubleshooting Tips","text":"<p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun GNSS Forum is a great place to ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"print_view/#upload-issues","title":"Upload Issues","text":"<p>If users have issues during the uploading process, they can try to manually force the board into DFU mode with the reset button. Double-tapping the RST button will force the MCU to into the Device Firmware Update mode. The board will remain in this mode, until it power cycles (which happens automatically, after uploading new firmware) or the reset button is pressed.</p> <ol> <li>Double-tap the RST button<ul> <li>The <code>STAT</code> LED should be fading in/out very slowly</li> </ul> </li> <li>Users should now, be able to upload a new program<ul> <li>It shouldn't be necessary to select a COM port in the Arduino IDE; only the board needs to be selected</li> </ul> </li> <li>Once programming is complete, the MCU should reboot on its own. Otherwise:<ul> <li>Press the RST button</li> <li>Power cycle the board</li> </ul> </li> </ol> <p></p> <p>RST button on the RA6M5 Thing Plus.</p>"},{"location":"print_view/#digital-io","title":"Digital I/O","text":""},{"location":"print_view/#utilizing-interrupts","title":"Utilizing Interrupts","text":"<p>When utilizing an interrupt on a digital GPIO, the attached interrupt service routine should be able to execute within the shortest, possible time frame. Otherwise, the suspended task could trigger various faults or errors.</p>"},{"location":"print_view/#sd-card","title":"\u00b5SD Card","text":""},{"location":"print_view/#compatibility","title":"Compatibility","text":"<p>The FATFileSystem library built into the Renesas-Arduino core, supports \u00b5SD cards with a FAT32 file system (i.e. SD cards up to 32GB in size).</p> <ul> <li>While users may be able to use cards with a higher storage capacity, we highly advise against it. As users may experience data loss due to a corrupt file system (i.e. SD cards with a storage capacity greater than 32GB are not meant to be formatted with a FAT32 file system).</li> </ul>"},{"location":"print_view/#hot-swapping","title":"Hot Swapping","text":"<p>To avoid corrupting an SD card, users should disable all activity with the SD card and disconnect power before removing it from the RA6M5 Thing Plus.</p>"},{"location":"resources/","title":"Hardware Resources","text":""},{"location":"resources/#product-resources","title":"Product Resources","text":"<ul> <li> Product Page</li> <li> Design Files:<ul> <li> Schematic</li> <li> Board Dimensions</li> <li> Eagle Files</li> </ul> </li> <li> Graphical Datasheet</li> <li> Renesas Arduino Core</li> <li> Arduino Libraries:<ul> <li>FastLED Arduino library</li> <li>SparkFun MAX1704x Fuel Gauge Arduino library</li> <li> CodeLess Arduino Library (unofficial - <code>CodeLess.zip</code>)</li> </ul> </li> <li> SFE Product Showcase</li> <li> Hardware Repo</li> </ul>"},{"location":"resources/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p> Component Documentation:</p> <ul> <li> <p>RA6M5 Microcontroller</p> <ul> <li> Datasheet</li> <li> User Manual</li> </ul> </li> <li> <p>DA14531MOD Bluetooth Module</p> <ul> <li> Datasheet</li> <li> Codeless\u2122 User Manual</li> </ul> </li> <li> <p>Peripherals Devices</p> <ul> <li> MAX17048 Battery Fuel Gauge</li> <li> WS2812 RGB LED</li> <li> MX25L12833F QSPI FLash</li> </ul> </li> <li> <p>Power Components</p> <ul> <li> RT9080 LDO Voltage Regulator</li> <li> LM66200 Ideal Diode Switch</li> <li> MCP73831 Charge Controller</li> </ul> </li> </ul> </li> <li> <p>Thing Plus Comparison Guide</p> </li> <li>Qwiic Information Page</li> <li> SparkFun Technical Assistance</li> </ul>"},{"location":"resources/#manufacturers-resources","title":"\ud83c\udfed\u00a0Manufacturer's Resources","text":"<p>Renesas also provides great resources for the RA6M5 and DA14531MOD:</p> <ul> <li>SmartBond\u2122 Flash Programmer</li> <li> RenesasRulz Forum</li> </ul> <ul> <li> <p>RA6M5 Product Page</p> <ul> <li>Documentation<ul> <li>RA6M5 Group Datasheet</li> <li>RA6M5 Group User Manual: Hardware</li> </ul> </li> <li>Software and Tools</li> </ul> </li> <li> <p>DA14531MOD Product Page</p> <ul> <li>Documentation<ul> <li>DA14531MOD Datasheet</li> </ul> </li> <li>Software and Tools<ul> <li>DA145<code>XX</code> CodeLess\u2122 User Manual</li> <li>SmartBond\u2122 - CodeLess\u2122 AT commands</li> <li>DA1453<code>x</code> SW Platform Reference Manual</li> </ul> </li> <li>Tutorials:<ul> <li>Tutorial - Sleep Modes</li> <li>Tutorial - Peripheral Drivers (Dialog SDK 6.0.<code>x</code>)</li> <li>Tutorial - Debugging (Dialog SDK 6.0.<code>x</code>)</li> <li>Tutorial - BLE Serial Port Service</li> <li>Tutorial - BLE Advertising</li> <li>Tutorial - Create a Custom GATT Profile</li> <li> SDK 6.0.<code>x</code> BLE Examples</li> </ul> </li> </ul> </li> </ul> <p> </p>"},{"location":"software-DA14531MOD/","title":"software DA14531MOD","text":"<p>While an Arduino library isn't necessary to utilize the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have created an unofficial Arduino library to help users get started. As an official library, users will need to manually download and install the library into the Arduino IDE; it will not be available through the Library Manager.</p> <p>Manually Download the Arduino Library</p> <p>To manually download and install the library, the files can be accessed from our GitHub repository or the <code>*.zip</code> can be downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p> <ul> <li> <p> <p>Installing an Arduino Library</p> <p>Tip</p> <p>In this Arduino library, there are several examples for configuring the Bluetooth connectivity of the DA14531MOD.</p> <p>However, we also include a <code>SerialPassThrough</code> example. Once programmed on the RA6M5 Thing Plus, it allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. Therefore, enabling users to experiment with the CodeLess AT commands and develop their own BLE connectivity solution.</p>"},{"location":"software_overview-arduino/","title":"Arduino IDE","text":"<p>Tip</p> <p>For first-time users, who have never programmed before and are looking to use the Arduino IDE, we recommend beginning with the SparkFun Inventor's Kit (SIK), which is designed to help users get started programming with the Arduino IDE.</p> <p>Most users should already be familiar with the Arduino IDE and its use. However, for those of you who have never heard the name Arduino before, feel free to check out the Arduino website. To get started with using the Arduino IDE, check out our tutorials below:</p> <ul> <li> <p> <p>What is an Arduino?</p> <li> <p> <p>Installing the Arduino IDE</p> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p> <li> <p> <p>Installing an Arduino Library</p>"},{"location":"software_overview-arduino/#arduino-core","title":"Arduino Core","text":""},{"location":"software_overview-arduino/#installation","title":"Installation","text":"<p>Installing the Ported Renesas-Arduino Core</p> <p>In order to program the RA6M5 Thing Plus in the Arduino IDE, users will need to install the Arduino Renesas Portenta board definitions from the Renesas-Arduino core. However, until the RA6M5 Thing Plus is officially adopted into the Renesas-Arduino core, users need to utilize our port of the Renesas-Arduino core.</p> <ol> <li>Before users can install our ported version of the Renesas-Arduino core, they should first install the Arduino Renesas Portenta board definitions of the official Renesas-Arduino core in the Arduino IDE.<ul> <li>This will ensure that any required compilation and upload tools are installed for the Arduino core.</li> <li>In the Board Manager of the Arduino IDE, select and install the Arduino Renesas Portenta board definitions from the Renesas-Arduino core.      Installing the Renesas-Arduino core in the Arduino IDE. </li> </ul> </li> <li> <p>Once installed, users will need to locate the <code>packages</code> directory for the Arduino cores in the Arduino IDE:</p> <ul> <li> <p>Windows</p> <p>On Windows, the directory location may vary based on whether the Arduino IDE was installed for an individual user or all users:</p> <ul> <li> <p>The user's <code>AppData</code> directory (hidden folder - primary):</p> <pre><code>C:\\Users\\&lt;insert username&gt;\\AppData\\Local\\Arduino15\\packages\n</code></pre> </li> <li> <p>The user's <code>ArduinoData</code> directory (local):</p> <pre><code>C:\\Users\\&lt;insert username&gt;\\Documents\\Arduino\\hardware\n</code></pre> </li> <li> <p>The <code>Program Files</code> or <code>Program Files(x86)</code> directories:</p> <pre><code>C:\\Program Files(x86)\\Arduino IDE\n</code></pre> </li> </ul> </li> <li> <p>MacOS</p> <p>With Mac OS, users should check the <code>Applications</code> and <code>Library</code> directories:</p> <ul> <li> <p><code>Library</code> directory (primary):</p> <pre><code>~/Library/Arduino15/packages/\n</code></pre> </li> <li> <p><code>Applications</code> directory (local):</p> <pre><code>/Applications/Arduino.app/hardware\n</code></pre> </li> </ul> </li> <li> <p>Linux</p> <p>For Linux, this may be located in the following directories:</p> <ul> <li> <p>Primary:</p> <pre><code>/home/$USER/.arduino15/packages\n</code></pre> </li> <li> <p>Local:</p> <pre><code>/home/$USER/Arduino/hardware\n</code></pre> </li> </ul> Tip <p>As mentioned in Arduino's guide for installing the Arduino IDE on Linux, users may need to run the following commands in the terminal:</p> <pre><code>sudo add-apt-repository universe\nsudo apt install libfuse2\n</code></pre> <p>In order to utilize the serial terminal or recognize the board in DFU mode, users may also need to run the following commands in the terminal:</p> <pre><code>usermod -a -G dialout $USERNAME\nusermod -a -G plugdev $USERNAME\n</code></pre> <ul> <li><code>$USERNAME</code> is the login username</li> <li>After, a restart or logout is required</li> </ul> </li> </ul> </li> <li> <p>After the <code>packages</code> directory has been located, users will need to navigate to the Renesas Arduino core. It is usually located in the <code>./arduino/hardware/renesas_portenta/&lt;version number&gt;/</code> directory of the <code>packages</code> folder.</p> </li> <li>The Arduino core is followed by a directory, named after the Arduino core's release <code>&lt;version number&gt;</code>. From there, users will need to create a new directory/folder in the <code>renesas_portenta</code> directory with the <code>version number</code> bumped up.<ul> <li>For example, if the current version is <code>1.1.0</code>, users can name the new directory <code>1.2.0</code>.</li> </ul> </li> <li>Next, users will need to download and extract the files from our ported version of the Renesas-Arduino core:      \u00a0\u00a0Download our Renesas-Arduino Core (Ported) </li> <li>Once extracted, users will need to copy over the files from our ported version of the Renesas-Arduino coreinto the new directory that was created earlier:      The files extracted from our ported version of the Renesas-Arduino core. </li> <li>Once the extracted files have been copied into the new directory, users will need to install the USB drivers for the board by executing the <code>post-install.*</code> script:<ul> <li>Windows: <code>post-install.bat</code></li> <li>Mac/Linux: <code>post-install.sh</code></li> </ul> </li> </ol> <p>Info</p> <p>This information is accurate as of April 2024; however, it may become irrelevant in the future (once the RA6M5 Thing Plus is included in the Renesas-Arduino core). At which point, users may disregard this note and/or request for this information to be updated by filing an issue.</p> Do Not Use - Hardware Not Officially Supported (yet) <p>Warning</p> <p>The instructions below are invalid; theRA6M5 Thing Plus has not been officially added into the Renesas-Arduino core. In the meantime, users will need to utilize our port of the Renesas-Arduino core (see instructions above).</p> <p>In order to program the RA6M5 Thing Plus in the Arduino IDE, users will need to install the Renesas-Arduino core. The Arduino core can be found by searching for <code>Arduino Renesas Portenta Boards</code> in the Board Manager of the Arduino IDE. Once installed, the RA6M5 Thing Plus will become available in the Board Manager.</p> <pre><code>Arduino Renesas Portenta Boards\n</code></pre> <p>For users who are unfamiliar with this process, please check out our tutorial on installing an Arduino core.</p> <ul> <li> <p> <p>Installing Board Definitions in the Arduino IDE</p> <p> Installing the Renesas-Arduino core in the Arduino IDE. </p>"},{"location":"software_overview-arduino/#programming-a-board","title":"Programming a Board","text":"<p>In order to upload a sketch from the Arduino IDE onto the RA6M5 Thing Plus, users will need to select the <code>SparkFun Thing Plus RA6M5</code> from the Tools &gt; Board &gt; Arduino Renesas Portenta Boards &gt; SparkFun Thing Plus RA6M5 drop-down menu. Users will also need to select the serial port from the Tools &gt; Port drop-down menu; the port should be automatically labeled, based upon the PID/VID of board in the USB driver.</p> <p></p> <p>Selecting the <code>SparkFun Thing Plus RA6M5</code> from the Tools drop-down menu in the Arduino IDE.</p> <p></p> <p>Searching for the <code>SparkFun Thing Plus RA6M5</code> in the Select Other Board and Port menu in the Arduino IDE.</p> <p>Alternatively, in the Arduino IDE (v2.<code>x</code>.<code>x</code>), users can also search for the board and serial port in the Select Other Board and Port menu. Once the appropriate board and serial port have been selected in the Arduino IDE, users can click the \u2192 (upload) button to begin the compilation and upload process.</p> DFU Mode <p>If users are having issues uploading code to the board, the RA6M5 can be manually forced into DFU mode. This issue, often occurs when the USB connection is busy and a reset can't be triggered on the RA6M5, to initialize the upload process. To force the RA6M5 Thing Plus into DFU mode:</p> <ol> <li>Double-tap the RST button<ul> <li>The <code>STAT</code> LED should be fading in/out very slowly</li> </ul> </li> <li>Users should now, be able to upload a new program<ul> <li>It shouldn't be necessary to select a COM port in the Arduino IDE; only the board needs to be selected</li> </ul> </li> <li>Once programming is complete, the MCU should reboot on its own. Otherwise:<ul> <li>Press the RST button</li> <li>Power cycle the board</li> </ul> </li> </ol>"},{"location":"software_overview-arduino/#arduino-libraries","title":"Arduino Libraries","text":"<p>In order to utilize some of the peripherals of the RA6M5 Thing Plus with the Arduino IDE, users will need to install Arduino libraries for the peripheral devices/interfaces. For users who are unfamiliar with this process, please check out our tutorial below:</p> <ul> <li> <p> <p>Installing an Arduino Library</p>"},{"location":"software_overview-arduino/#max17048-fuel-gauge","title":"MAX17048 Fuel Gauge","text":"<p>While users are free to choose any Arduino library that provides support for MAX17048 fuel gauge, we recommend the SparkFun MAX1704x Arduino library; as it has been tested and verified to work with the MAX17048 on the RA6M5 Thing Plus. The SparkFun MAX1704x Fuel Gauge Arduino library can be installed from the Library Manager in the Arduino IDE by searching for:</p> <pre><code>SparkFun MAX1704x Fuel Gauge Arduino Library\n</code></pre> <p>SparkFun MAX1704x Fuel Gauge Arduino library in the library manager of the Arduino IDE.</p> <p>Manually Download the Arduino Library</p> <p>For users who would like to manually download and install the library, the <code>*.zip</code> file can be accessed from the GitHub repository or downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p>"},{"location":"software_overview-arduino/#ws2812-rgb-led","title":"WS2812 RGB LED","text":"<p>While users are free to choose any Arduino library that provides support for WS2812 LEDs, we recommend the FastLED Arduino library. It has been tested and verified to work with the RGB LED on the RA6M5 Thing Plus. The FastLED Arduino library can be installed from the Library Manager in the Arduino IDE by searching for:</p> <pre><code>FastLED Arduino Library\n</code></pre> <p></p> <p>FastLED Arduino library in the library manager of the Arduino IDE.</p> <p>Manually Download the Arduino Library</p> <p>For users who would like to manually download and install the library, the <code>*.zip</code> file can be accessed from the GitHub repository or downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p> How to Define Parameters <p>While using the FastLED Arduino library, users need to define the following parameters to the WS2812 RGB LED included on the board. However, if additional LEDs are connected externally to the board, then the appropriate values should be provided for the Arduino library.</p> <code>#define NUM_LEDS 1</code> There is only one WS2812 LED on the board <code>#define DATA_PIN LED_RGB</code> Declare which pin is connected to the WS2812 LED. On the RA6M5 Thing Plus, it is defined as <code>D13</code> or <code>RGB_LED</code> in the Arduino core for GPIO <code>P105</code>. <code>#define LED_TYPE WS2812</code> Declare the LED type for the library; the RA6M5 Thing Plus only includes <code>WS2812</code> RGB LED on the board."},{"location":"software_overview-arduino/#da14531mod-ble-module","title":"DA14531MOD BLE Module","text":"<p>While an Arduino library isn't necessary to utilize the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have created an unofficial Arduino library to help users get started. As an official library, users will need to manually download and install the library into the Arduino IDE; it will not be available through the Library Manager.</p> <p>Manually Download the Arduino Library</p> <p>To manually download and install the library, the files can be accessed from our GitHub repository or the <code>*.zip</code> can be downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p> <ul> <li> <p> <p>Installing an Arduino Library</p> <p>Tip</p> <p>In this Arduino library, there are several examples for configuring the Bluetooth connectivity of the DA14531MOD.</p> <p>However, we also include a <code>SerialPassThrough</code> example. Once programmed on the RA6M5 Thing Plus, it allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. Therefore, enabling users to experiment with the CodeLess AT commands and develop their own BLE connectivity solution.</p>"},{"location":"software_overview-codeless/","title":"CodeLess AT Commands","text":"<p>The firmware provided with the DA14531MOD Bluetooth module on the RA66M5 Thing Plus, utilizes Renesas' SmartBond\u2122 - CodeLess\u2122 AT commands platform. This platform allows users to quickly get started on developing wireless IoT applications through a set of AT Commands (ASCII instructions) without having to write a single line of source code. The basic set of AT commands provides control over the Bluetooth\u00ae LE connectivity: BLE connect/disconnect, advertise, stop advertising, change roles (central/peripheral), scan for nearby devices, report BLE address, etc.</p> <p>Default Configuration</p> <p>The default serial port configuration of the DA14531MOD for AT commands:</p> <ul> <li>BaudRate : 57600</li> <li>DataBits : 8</li> <li>StopBits : 1</li> <li>Parity : None</li> <li>Flow Control : None</li> <li>Transmit Text: Append CR</li> </ul> Firmware <p>The precompiled binary from the CodeLess SDK utilized as the firmware image, on the DA14531MOD of the RA6M5 Thing Plus, is the <code>codeless_531_datapump.hex</code> (CodeLess for DA1453x datapump).</p>"},{"location":"software_overview-codeless/#user-manual","title":"User Manual","text":"<p>Renesas provides documentation for the CodeLess platform:</p> <ul> <li>DA14531 TINY\u2122 Module Getting Started</li> <li>DA145<code>XX</code> CodeLess User Manual</li> </ul>"},{"location":"software_overview-codeless/#arduino-library","title":"Arduino Library","text":"<p>While an Arduino library isn't necessary to utilize the CodeLess\u2122 AT commands for the DA14531MOD Bluetooth module, we have created an unofficial Arduino library to help users get started. As an official library, users will need to manually download and install the library into the Arduino IDE; it will not be available through the Library Manager.</p> <p>Manually Download the Arduino Library</p> <p>To manually download and install the library, the files can be accessed from our GitHub repository or the <code>*.zip</code> can be downloaded by clicking the button below.</p> <p>  Download the Arduino Library </p> <ul> <li> <p> <p>Installing an Arduino Library</p> <p>Tip</p> <p>In this Arduino library, there are several examples for configuring the Bluetooth connectivity of the DA14531MOD.</p> <p>However, we also include a <code>SerialPassThrough</code> example. Once programmed on the RA6M5 Thing Plus, it allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. Therefore, enabling users to experiment with the CodeLess AT commands and develop their own BLE connectivity solution.</p>"},{"location":"software_overview-codeless/#example-serialpassthrough","title":"Example - SerialPassThrough","text":"<p>In our unofficial Arduino library, there are several examples for configuring the Bluetooth connectivity of the DA14531MOD. Also included, is a <code>SerialPassThrough</code> example. Once programmed on the RA6M5 Thing Plus, it allows users to directly interface with the DA14531MOD's UART port through the board's USB connection using a serial terminal. The example, utilizes the default configuration settings for the serial port on the DA14531MOD, as listed above.</p> <p>Serial Terminal Emulator</p> <p>In order to configure the DA14531MOD on the RA6M5 Thing Plus, users will need access to a serial terminal emulator on their computer. The Serial Monitor in the Arduino IDE is more than suitable for this application; however, users are also free to utilize their terminal emulator of choice. Below are a few options, outside of the Arduino IDE:</p> Serial Communication and Serial Terminal <p>Check out our hookup guides on serial communication and installing a terminal emulator:</p> <ul> <li> <p> <p>Serial Communication</p> <li> <p> <p>Serial Terminal Basics</p> WindowsMac OSLinux <p>For Windows computers, we highly recommend TeraTerm (open-source development project).</p> <p>For Mac OS, users can check out CoolTerm (freeware).</p> <p>Some Linux operating systems will already have the <code>screen</code> terminal emulator preinstalled.</p>"},{"location":"troubleshooting_tips/","title":"Troubleshooting Tips","text":"<p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun GNSS Forum is a great place to ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"troubleshooting_tips/#upload-issues","title":"Upload Issues","text":"<p>If users have issues during the uploading process, they can try to manually force the board into DFU mode with the reset button. Double-tapping the RST button will force the MCU to into the Device Firmware Update mode. The board will remain in this mode, until it power cycles (which happens automatically, after uploading new firmware) or the reset button is pressed.</p> <ol> <li>Double-tap the RST button<ul> <li>The <code>STAT</code> LED should be fading in/out very slowly</li> </ul> </li> <li>Users should now, be able to upload a new program<ul> <li>It shouldn't be necessary to select a COM port in the Arduino IDE; only the board needs to be selected</li> </ul> </li> <li>Once programming is complete, the MCU should reboot on its own. Otherwise:<ul> <li>Press the RST button</li> <li>Power cycle the board</li> </ul> </li> </ol> <p></p> <p>RST button on the RA6M5 Thing Plus.</p>"},{"location":"troubleshooting_tips/#digital-io","title":"Digital I/O","text":""},{"location":"troubleshooting_tips/#utilizing-interrupts","title":"Utilizing Interrupts","text":"<p>When utilizing an interrupt on a digital GPIO, the attached interrupt service routine should be able to execute within the shortest, possible time frame. Otherwise, the suspended task could trigger various faults or errors.</p>"},{"location":"troubleshooting_tips/#sd-card","title":"\u00b5SD Card","text":""},{"location":"troubleshooting_tips/#compatibility","title":"Compatibility","text":"<p>The FATFileSystem library built into the Renesas-Arduino core, supports \u00b5SD cards with a FAT32 file system (i.e. SD cards up to 32GB in size).</p> <ul> <li>While users may be able to use cards with a higher storage capacity, we highly advise against it. As users may experience data loss due to a corrupt file system (i.e. SD cards with a storage capacity greater than 32GB are not meant to be formatted with a FAT32 file system).</li> </ul>"},{"location":"troubleshooting_tips/#hot-swapping","title":"Hot Swapping","text":"<p>To avoid corrupting an SD card, users should disable all activity with the SD card and disconnect power before removing it from the RA6M5 Thing Plus.</p>"},{"location":"github/contribute/","title":"Contribute: Make an Augmentation!","text":"<p>Spot an improvement opportunity? Feel free to contribute to our open-source design and documentation. </p>"},{"location":"github/contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun RA6M5 Thing Plus repository.</li> </ul>"},{"location":"github/contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your corrections or improvements to the markdown file.</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun RA6M5 Thing Plus repository.</li> </ul>"},{"location":"github/contribute/#submit-a-design-enhancement","title":"Submit a Design Enhancement","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"},{"location":"github/contribute/#contributors","title":"Contributors","text":"<p>Let's provide some recognition to the contributors for this project!</p> <p> </p>"},{"location":"github/file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. This Submit Issues page is not where users should seek assistance.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search the product forums and ask questions.</p> <p>Account Registration Required</p> <p>For your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"github/file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of our documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun RA6M5 Thing Plus repository.</li> </ul>"},{"location":"github/file_issue/#spot-something-wrong","title":"\ud83d\udd0d Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"github/file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun RA6M5 Thing Plus repository.</li> </ul>"},{"location":"github/file_issue/#does-something-not-make-sense","title":"Does something not make sense? \ud83e\udd14","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"github/file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board? \ud83e\udd26","text":"<p>If part of the board's functionality is missing, please open an issue and file a feature request.</p> <p>Design Considerations</p> <p>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements.</p> <ul> <li>For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.</li> </ul>"},{"location":"github/file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"}]}